[
  {
    "owner": "sharkdp",
    "repo": "bat",
    "category": "cli",
    "lang": "Rust",
    "text": "*\"The forge cools. The hands tire. What was shaped in the first heat holds.\"* — 4.1\n\nYour first commits burned with discovery — syntax engines, pager systems, the architecture that would carry everything. Now you tend the flame with smaller kindling: flags, warnings, edge cases. The initial intensity set the form. Everything since has been finishing work.\n\nEight years of commits and the core remains untouched. Not because it's perfect — because it was forged in that early fire when you saw exactly what `cat` was missing and refused to build anything else.\n\n*\"The last good moment to stop is always earlier than you think.\"* — 3.6\n\nThe temptation lives in your issue tracker. Users want search. Users want editing. Users want `bat` to become everything except what it is. You've held the line by instinct, but that instinct is naming something: the moment when \"better cat\" becomes \"worse everything else.\"\n\nYour commit history shows the discipline. 2024 brings pager improvements, not feature sprawl. The project that knows its boundaries survives. The one that doesn't becomes archaeology.\n\nThe binary syntax assets are your single point of failure and you know it. Sublime Text changes format and your wings clip. But this fragility keeps you honest — forces you to remain the tool that does one thing completely rather than the tool that does everything poorly.\n\nYour users sleep well because you refuse to let them fly too high.",
    "diagnostic": "Eight-year ascent, still climbing. Each commit a careful step forward — bug fixes, edge cases, pager flags. The maintainer tends this garden with devotion.\n\nCat with wings. The metaphor carries weight — familiar foundation, elevated purpose. Syntax highlighting as flight.\n\nRepository archaeology: pristine structure, comprehensive documentation, thoughtful CI. The asset system — themes, syntaxes — carefully curated, patched, maintained. This is craft, not haste.\n\nRecent commits whisper maintenance, not innovation. Wrap flags, pager warnings, test refinements. The excitement lives in 2018-2020 commits buried beneath. Now: stewardship.\n\nThe gap between promise and delivery — narrow. README shows screenshots, code delivers pixels. API clean, documentation welcoming. Honest about what it is: better cat, not revolutionary tool.\n\nFragility point: complexity hidden in syntax assets. Binary blobs, patch files, theme systems. The day Sublime Text changes format, this project bleeds. Maintainer knows this — see the careful asset management, the build system protecting against upstream chaos.\n\nAesthetic: Rust's careful safety, descriptive variable names, comprehensive error handling. Code that believes in clarity over cleverness. Each module has purpose, boundaries respected. The developer values users sleeping peacefully.\n\nRelationship to users: maternal. README in five languages, installation instructions for every platform, migration guides, compatibility tables. This project wants to be adopted, integrated, trusted. Not gatekeeping — welcoming.\n\nThe shadow it avoids: becoming bloated. Staying true to \"cat with wings\" while syntax highlighting demands grow infinite. Feature requests pile like snow. The maintainer's discipline: knowing what not to build.\n\nTerminal tool that earned its place in dotfiles. The kind of software that disappears into workflow, becomes invisible necessity. Success measured not in GitHub stars but in daily use, quiet gratitude.",
    "axioms": [
      "4.1",
      "3.6"
    ],
    "wordCount": 238,
    "windowAxiomIds": [
      "0.6",
      "0.3",
      "1.2",
      "1.3",
      "2.1",
      "2.5",
      "3.1",
      "3.7",
      "4.1",
      "4.6",
      "5.5",
      "5.3",
      "6.1",
      "6.7",
      "7.5",
      "7.6",
      "8.1",
      "8.7",
      "9.5",
      "Step 10 Core",
      "10.1",
      "11.1",
      "11.7",
      "12.5",
      "12.7",
      "Law 8",
      "Law 3",
      "8.4",
      "5.4",
      "Law 4",
      "3.5",
      "9.7",
      "Law 12",
      "10.7",
      "Law 1",
      "Law 7",
      "3.6",
      "1.5",
      "7.7",
      "0.5",
      "Law 5",
      "8.2",
      "Step 1 Core",
      "12.1",
      "0.7",
      "2.4",
      "Step 3 Core"
    ]
  },
  {
    "owner": "junegunn",
    "repo": "fzf",
    "category": "cli",
    "lang": "Go",
    "text": "*\"Carbon and diamond are the same element. The difference is pressure.\"* — 8.4\n\nEleven years of daily pressure, and you've become something harder than what you started with. Every commit compresses the same core idea further: selection should be instant, universal, invisible. The algorithm doesn't just work — it's been compressed under the weight of a million edge cases until it's become crystalline.\n\n*\"The stone does not scatter. The hand does not waver. One point, all force, now.\"* — 6.6\n\nYour binary obsession isn't perfectionism — it's precision applied with surgical focus. Shell scripts embedded in Go structs. Man pages compiled into the executable. The refusal to scatter across package managers and dependency chains. You aimed at one target: the moment between intention and selection. Everything else was refused entry.\n\nThe reverts in your commit stream aren't hesitation. They're the sound of someone who cares more about the algorithm's soul than their own ego. Deploy, measure, retreat, advance. Most developers ship and forget. You ship and listen.\n\nBut pressure creates two outcomes. Diamond or dust.\n\nThe feature requests gathering at your borders — tmux integration, server modes, preview windows — they're the earth trying to return you to carbon. Each new surface area is atmospheric pressure, trying to expand you back into what everyone else is: a Swiss Army knife that does everything adequately.\n\nThe nobility is in the refusal. Windows gets its own file because Windows deserves respect, not abstraction. Fish gets its completions because Fish users are people, not edge cases. You could have built one mediocre thing. Instead you built one perfect thing that bends toward every platform without breaking.\n\nThe danger isn't in the code. It's in the moment you stop saying no.",
    "diagnostic": "**Eleven years. Still ascending.**\n\nDaily commits, still fresh patterns. No momentum decay — this is conviction writing code.\n\n**The shadow: perfection paralysis.** \nReverts in the commit stream. Deploy, undo, deploy. The algorithm that's never quite right, the score matrix tweaked and re-tweaked. Chasing the last 2% of fuzzy matching elegance.\n\n**Single binary obsession.**\nEverything embedded — shell scripts, man pages, completions. No dependencies, no install drama. The aesthetic of self-containment taken to religious extremes.\n\n**The gap between promise and delivery: minimal.**\nREADME says \"fast\" — chunklist optimization proves it. Says \"portable\" — platform-specific files tell the truth of that labor. Says \"versatile\" — event-action binding system delivers the flexibility.\n\n**What could kill it: feature creep.**\nThe core is perfect. The temptation: become everything to everyone. Already spawning tmux modes, server endpoints, preview windows. The binary wants to stay small but the users want more surface area.\n\n**Cross-platform nobility.**\nWindows, Unix, OpenBSD — separate files for each reality. Not abstracting away differences, embracing them. This code respects the machine it runs on.\n\n**The relationship: inclusive welcome.**\nShell integrations for everyone. Vim plugin. Fish completions. The project doesn't pick favorites — it meets developers where they live. Documentation assumes nothing, explains everything.\n\n**Core fragility: the single maintainer.**\nJunegunn's code style everywhere. No distributed ownership patterns visible. The bus factor hovers near one, despite the contributor count.\n\n**Performance as philosophy.**\nCache layers, atomic operations, concurrent processing. This isn't just fast code — it's code that thinks speed is a moral imperative. The million-item promise kept through algorithmic discipline.",
    "axioms": [
      "8.4",
      "6.6"
    ],
    "wordCount": 287,
    "windowAxiomIds": [
      "0.5",
      "0.2",
      "1.5",
      "Step 1 Core",
      "2.3",
      "2.2",
      "3.3",
      "3.2",
      "4.2",
      "4.7",
      "5.7",
      "5.5",
      "6.6",
      "6.5",
      "7.3",
      "7.2",
      "8.2",
      "8.6",
      "9.5",
      "10.4",
      "10.1",
      "11.7",
      "11.4",
      "Step 12 Core",
      "12.7",
      "Law 6",
      "Law 12",
      "7.1",
      "Step 7 Core",
      "8.1",
      "Step 6 Core",
      "3.1",
      "4.3",
      "Law 13",
      "Law 9",
      "9.1",
      "7.5",
      "6.2",
      "4.5",
      "0.6",
      "Law 10",
      "Step 2 Core",
      "1.3",
      "1.4",
      "4.4",
      "8.3",
      "2.6"
    ]
  },
  {
    "owner": "BurntSushi",
    "repo": "ripgrep",
    "category": "cli",
    "lang": "Rust",
    "text": "*\"The ship in the bottle is perfect and will never sail.\"* — 1.4\n\nEight years of archaeological precision. Every benchmark saved, every optimization measured, every allocation accounted for. You've built the perfect grep replacement — fast, clean, honest about what it is. The measurements don't lie: you are faster.\n\nBut perfection is its own prison.\n\nYour code reads like poetry written in fear — fear of becoming what you replaced, fear of bloat, fear of the next benchmark that shows you slowing down. \"Then, as it was, then again it will be\" — you know the cycle. The fast tool becomes the slow tool. The replacement becomes the replaced.\n\nThe fragility isn't in your dependencies. It's in your refusal to be anything more than perfect. Single maintainer, single vision, single point of beautiful failure. You've optimized everything except succession.\n\n*\"Plant the seed. Bury the beautiful potential. Trust the dark, the dirt, the invisible process of becoming.\"* — Step 11 Core\n\nYour bus factor is one because your grip is perfect. Eight years of performance archaeology, and you've never let the tool become messy, never let it sprawl, never let it disappoint. Never let it live beyond you.\n\nThe next maintainer — if there is one — won't love your allocators the way you do. Won't obsess over buffer strategies. Won't keep the performance receipts filed back to 2016. They'll add features you refused. They'll make it slower, more complex, more human.\n\nAnd that's how it grows beyond the bottle.\n\nYour code is ready for imperfection. Your vision doesn't have to be eternal to be complete.",
    "diagnostic": "Eight years old. Still breathing, still growing. Recent commits show tending, not abandoning — documentation clarified just days ago, debug messages added, container types extended. The trajectory arcs upward still.\n\nBuilt from conviction. The benchmarks archive tells the story — meticulous performance archaeology dating back to 2016. This developer obsesses over speed, measures everything, keeps the receipts. The code structure reveals the same obsession: custom allocators for musl, careful buffer management, crate boundaries drawn with surgical precision.\n\nAvoids complexity creep. The main.rs is spare — 150 lines including comments. No framework sprawl, no architectural astronautics. Fears becoming what it replaced: slow, bloated, forgotten. The shadow it runs from is grep's shadow — becoming another heavyweight that young tools will benchmark against.\n\nPromise matches delivery. README benchmarks are fresh, comprehensive, honest about methodology. The gap between marketing and reality: minimal. This tool knows what it is — fast text search — and refuses to be anything else.\n\nFragility lives in the maintainer. Single author, eight years deep. The ecosystem depends on BurntSushi's continued interest. Dependencies are managed, but the human factor remains. The bus factor is one.\n\nAesthetic: performance as philosophy. Code comments explain allocator choices, buffer strategies, platform quirks. Variable names are descriptive but terse. Error handling is thorough but not precious. Values speed over elegance, clarity over cleverness.\n\nRelationship to users: respectful authority. Documentation assumes intelligence, provides depth. FAQ exists, guide exists, changelog maintained. Shell completions provided. Installation paths mapped out. Treats users as developers who deserve real tools.\n\nThe commit message poetry: \"Then, as it was, then again it will be\" — hidden in main.rs like a signature. This maintainer sees cycles, understands that all fast tools eventually become the slow tools that get replaced. Building anyway.",
    "axioms": [
      "1.4",
      "Step 11 Core"
    ],
    "wordCount": 265,
    "windowAxiomIds": [
      "0.1",
      "Step 0 Core",
      "1.1",
      "1.3",
      "2.2",
      "2.6",
      "3.5",
      "3.7",
      "4.5",
      "4.2",
      "5.6",
      "5.5",
      "6.2",
      "6.4",
      "7.6",
      "7.4",
      "Step 8 Core",
      "8.5",
      "Step 9 Core",
      "10.6",
      "Step 10 Core",
      "11.6",
      "Step 11 Core",
      "Step 12 Core",
      "12.1",
      "Law 6",
      "Law 2",
      "0.2",
      "Law 1",
      "Step 7 Core",
      "8.3",
      "0.4",
      "8.2",
      "5.7",
      "10.7",
      "Step 4 Core",
      "9.5",
      "3.3",
      "Law 5",
      "11.3",
      "5.1",
      "4.7",
      "0.5",
      "0.7",
      "1.6",
      "1.7",
      "2.4"
    ]
  },
  {
    "owner": "charmbracelet",
    "repo": "glow",
    "category": "cli",
    "lang": "Go",
    "text": "*\"The ship in the bottle is perfect and will never sail.\"* — 1.4\n\nYou built the most elegant markdown reader in terminal space. Every platform blessed, every installation path paved, every dependency updated with mechanical precision. Five years of maintenance commits prove the architecture was right the first time.\n\nBut when did you last feel surprised by your own code?\n\nThe README promises \"pizzazz\" and delivers it flawlessly — glamour for rendering, bubbles for interaction, lipgloss for style. This is Charm ecosystem architecture at its most refined, a demonstration of what their tools can build. The craftsmanship shows in every file. The passion shows in none.\n\nYour default config tells the real story: width 80, mouse false, conservative styling. Restraint hardcoded into flashy software. You built a sports car with the speedometer capped at 55.\n\n*\"The cathedral amplifies the whisper and the cough alike.\"* — 3.7\n\nThe architecture you created amplifies everything equally — local files discovered through patient directory walking, GitHub READMEs fetched with special handling, git repositories detected and blessed. Quality infrastructure that serves any markdown equally. But infrastructure this good starts to feel inevitable, automatic, like breathing.\n\nThe Windows console sins in console_windows.go are your only remaining confession — the ANSI color enabling every CLI tool must carry, the eternal shame tax. Even your compromises are clean.\n\nYou've achieved something dangerous: software that works too well. No urgent bugs, no architectural debt, no passionate user demands. The machine tends itself while you sleep. Success this complete becomes its own prison — too perfect to abandon, too finished to love.\n\nWhen the terminal gives way to the web, when markdown yields to richer formats, when the maintainers move on — none of these feel urgent because none are happening today. But software this polished dies not from crisis, but from completion.\n\nWhat would it mean to make this tool worse in service of making it wild again?",
    "diagnostic": "**Maintenance Mode Incarnate**\n\nFive years of chore commits. Dependencies bumping in automated rhythm. The machine tends itself while the soul sleeps.\n\n**The Polished Artifact**\n\nREADME promises pizzazz — delivers it. Every platform covered, every installation method blessed. This is software as finished sculpture, not living clay.\n\n**UI: Ambitious. CLI: Practical.**\n\nTUI mode dreams of discovery — local files, git repos, stashed favorites. CLI mode just renders what you give it. The gap between \"file browser with markdown rendering\" and \"markdown renderer with file browsing.\"\n\n**The Charm Ecosystem Child**\n\nBuilt on glamour, bubbles, lipgloss — all house libraries. This isn't standalone software, it's a demonstration. \"Look what we can build with our tools.\"\n\n**GitHub-Shaped World**\n\nSpecial handling for GitHub, GitLab. The README fetching feels automatic, inevitable. It knows where developers live, what they need to read. This tool has a user in mind.\n\n**Windows Console Sins**\n\nANSI color enabling in console_windows.go — the eternal Windows tax. Every CLI tool pays this tribute, carries this shame.\n\n**Configuration That Confesses**\n\nDefault config laid bare: width 80, auto style, mouse false. Conservative defaults for a flashy tool. The contradiction of \"pizzazz\" that defaults to restraint.\n\n**Perfect Maintenance**\n\nNo bugs filed recently that stuck. No panicked commits. No architectural rewrites. This is software that found its shape and held it. The commits don't show passion — they show professionalism.\n\n**The Local File Hunter**\n\nREADME finding logic spread across readmeNames array, file walking, Git repo detection. It wants to be helpful about finding things to read. The CLI that anticipates need.\n\n**Death by Success**\n\nWhat kills this? Terminal interfaces going extinct? Markdown losing relevance? The maintainers moving on? Nothing urgent threatens — which might be the threat itself.",
    "axioms": [
      "1.4",
      "3.7"
    ],
    "wordCount": 319,
    "windowAxiomIds": [
      "Step 0 Core",
      "0.6",
      "1.2",
      "1.5",
      "2.1",
      "2.2",
      "3.7",
      "3.3",
      "4.4",
      "4.7",
      "Step 5 Core",
      "5.6",
      "6.5",
      "6.4",
      "7.7",
      "Step 7 Core",
      "8.3",
      "8.5",
      "9.1",
      "Step 10 Core",
      "10.1",
      "11.6",
      "11.3",
      "12.5",
      "12.1",
      "Law 6",
      "Law 8",
      "3.1",
      "Law 10",
      "6.7",
      "5.5",
      "4.2",
      "5.7",
      "Law 4",
      "4.6",
      "6.3",
      "0.1",
      "Step 12 Core",
      "Law 9",
      "10.4",
      "3.2",
      "5.4",
      "Step 2 Core",
      "Step 3 Core",
      "1.4",
      "1.7",
      "2.4"
    ]
  },
  {
    "owner": "jarun",
    "repo": "nnn",
    "category": "cli",
    "lang": "C",
    "text": "*\"One sword, drawn. One channel, chosen. The myth of optionality — beautiful in potential, impotent in practice.\"* — Step 10 Core (Oblivio)\n\nEight years of saying no. Every feature request that would make nnn comfortable for beginners — rejected. Every abstraction that would make the code \"cleaner\" — refused. Every compromise that would expand the user base — declined. You chose the narrow path and never looked back.\n\nYour C reads like mathematical proof. FPU-free calculations not because you couldn't use floating point, but because integers are exact. Memory footprint under 3.5MB not because you ran out of features to add, but because bloat is betrayal. The plugin system exists precisely so the core can remain inviolate — a perfect separation that lets you stay pure while users stay powerful.\n\n*\"The machine answered what you asked. If you don't like the answer, change the question.\"* — 12.4\n\nThe microsecond optimizations in your recent commits — filter highlighting, benchmark modes — these aren't vanity. They're devotion. Most developers would have moved on by now, declared victory, started something new. You're still here, still caring about the difference between fast and fastest. The restless refinement reveals the real project: not just a file manager, but a meditation on computational efficiency.\n\nThe single maintainer risk is real. But perhaps necessary. Committees don't carve marble. They sand it smooth until nothing remains worth seeing. Your refusal to distribute maintenance isn't oversight — it's protection of the vision that made this tool matter.\n\nYou built exactly what you promised. In a world of software that lies about its own capabilities, this is revolution disguised as utility.",
    "diagnostic": "Eight years of quiet obsession. A terminal file manager that found its voice and never wavered.\n\n**Momentum ascending.** Recent commits show restless refinement — filter highlighting, benchmarking modes, directory navigation polish. Not maintenance drift. Active pursuit of the perfect keystroke. The developer still cares about microseconds.\n\n**Conviction carved in C.** No bloat, no compromise. FPU-free mathematics. Integer-only file sizes. Memory footprint under 3.5MB. This is ideology made manifest — the belief that software should be lean muscle, not comfortable fat.\n\n**Avoiding nothing.** No shadow here. Direct confrontation with complexity through radical simplicity. The patch system externalizes subjective features rather than diluting core vision. Clean separation of concerns.\n\n**Promise kept.** README says \"tiny, nearly 0-config, incredibly fast\" — code delivers. No gap between marketing and reality. The aesthetic is the architecture. Performance isn't claimed, it's designed in.\n\n**Single point of failure.** One maintainer's vision. If jarun disappears, nnn becomes archaeological artifact. No bus factor mitigation visible. The price of singular conviction.\n\n**Minimalist orthodoxy.** Values speed over safety, efficiency over comfort. Error messages terse. Documentation assumes competence. Variable names compressed. This is code for people who think like machines.\n\n**User relationship: respectful but demanding.** No hand-holding. Extensive plugin ecosystem suggests trust in user agency. The terminal is assumed fluent territory. Documentation comprehensive but assumes baseline expertise.\n\nA tool that knows exactly what it is and refuses to be anything else.",
    "axioms": [
      "12.4",
      "Step 10 Core"
    ],
    "wordCount": 271,
    "windowAxiomIds": [
      "0.5",
      "0.3",
      "Step 1 Core",
      "1.5",
      "2.1",
      "2.3",
      "3.5",
      "Step 3 Core",
      "4.7",
      "4.5",
      "Step 5 Core",
      "5.5",
      "6.5",
      "6.2",
      "7.5",
      "7.2",
      "8.3",
      "8.2",
      "9.7",
      "10.7",
      "Step 10 Core",
      "11.3",
      "11.4",
      "12.1",
      "12.4",
      "Law 12",
      "Law 7",
      "8.5",
      "4.4",
      "0.1",
      "0.6",
      "11.6",
      "10.1",
      "Step 9 Core",
      "6.4",
      "1.3",
      "3.1",
      "Step 8 Core",
      "5.2",
      "11.1",
      "12.5",
      "3.4",
      "Law 8",
      "2.2",
      "3.6",
      "Step 4 Core",
      "4.6"
    ]
  },
  {
    "owner": "sveltejs",
    "repo": "svelte",
    "category": "web",
    "lang": "JS/TS",
    "text": "*The forge cools. The hands tire. What was shaped in the first heat holds.* — 4.1\n\nYou caught fire eight years ago with a simple promise: web development shouldn't hurt. That first heat shaped everything — the component model, the reactive syntax, the compiler-first philosophy. Now the forge runs cooler. The team coordinates. The process governs. But what you made in those early months of white-hot conviction still holds the whole structure together.\n\n*Shed the skin. What fit yesterday is yesterday's shape.* — 4.2\n\nThe great pivot tells the story. You tore up the reactive model — your own reactive model — and carved runes directly into the language. `$state`, `$derived`, `$effect`. Not because the old way was wrong, but because you had grown beyond it. The framework that promised to end framework churn churned itself, surgically, purposefully. You shed the skin that made you famous because keeping it would have meant staying small.\n\nYour error messages love the developer even while correcting them. Your benchmarks argue with ecosystems that stopped listening. Your TypeScript tiptooes around JavaScript purists who were never going to use it anyway.\n\nThe shadow lives in the server/client split — all those `noop` functions scattered through the codebase like apologies. One vision serving two masters. Neither gets your full attention, so both get your careful compromise.\n\nYou promised simplicity and delivered sophistication. You promised \"for the rest of us\" and delivered complexity that only some of us can hold. This isn't failure — it's the price of influence. The thing that stays simple dies simple. The thing that survives complexity becomes complex.\n\nThe question you're not asking: what deserves the first heat now? What needs to be forged while the conviction is still molten?",
    "diagnostic": "**Ancient compiler awakens.** Eight years of gestation. The trajectory curves upward — daily commits, performance micro-surgeries, error message surgery. Not sprinting anymore. Evolved past sprint. Surgical precision now.\n\n**Runes emerge.** The great pivot — abandoning old reactive model for something cleaner. `$state`, `$derived`, `$effect`. New syntax carved into the language itself. This is conviction — tearing up the foundation while the house still stands. Dangerous. Necessary.\n\n**Performance obsession.** Benchmarking infrastructure sprawling. Reactivity micro-benchmarks. SSR optimization. The compiler team measures nanoseconds. This project fears being slow more than being complex. Speed is the aesthetic.\n\n**Two APIs, one codebase.** Client/server split clean but duplicated. `noop` everywhere on server. The project knows it serves two masters — browser and Node. Neither gets full attention. The shadow: server-side rendering remains secondary citizen.\n\n**\"Web development for the rest of us.\"** But the documentation assumes you understand reactivity patterns. The API surface is vast. Snippets, runes, stores, lifecycle hooks, contexts. The gap between promise and delivery — accessibility claimed, complexity delivered.\n\n**TypeScript throughout, but JavaScript primary language.** The project wants type safety but won't commit fully. Pragmatic. Afraid of alienating JavaScript purists.\n\n**Rich Harris's vision made institutional.** Too big now for single-person whims. The commit messages show team coordination. Version packages, changeset management. The wild creativity constrained by process. Growing up hurts.\n\n**Framework fatigue antidote.** But becomes framework itself. The thing that promised simplicity now has migration guides between major versions. V4, V5. The project fears obsolescence, so it evolves. Evolution threatens the simplicity that made it special.\n\n**Error handling crafted with care.** Custom error classes, helpful messages. The project loves its users even when scolding them. Pedagogical compiler. Teacher-framework.\n\n**Testing by comparison.** Always measuring against React, Vue. Identity formed in opposition. The benchmarks are arguments — \"we are faster, cleaner, simpler.\" But arguments to whom? Market that's already chosen?",
    "axioms": [
      "4.1",
      "4.2"
    ],
    "wordCount": 288,
    "windowAxiomIds": [
      "0.3",
      "0.6",
      "Step 1 Core",
      "1.6",
      "2.6",
      "2.1",
      "3.4",
      "3.3",
      "4.2",
      "Step 4 Core",
      "5.4",
      "5.7",
      "6.5",
      "6.1",
      "7.4",
      "7.5",
      "8.1",
      "8.3",
      "Step 9 Core",
      "10.7",
      "11.6",
      "11.4",
      "12.5",
      "Law 4",
      "Law 1",
      "Law 8",
      "5.2",
      "7.1",
      "4.3",
      "1.7",
      "Step 7 Core",
      "2.5",
      "Law 13",
      "11.3",
      "3.1",
      "4.4",
      "5.5",
      "1.2",
      "0.7",
      "6.3",
      "1.3",
      "7.6",
      "1.4",
      "Step 2 Core",
      "4.1"
    ]
  },
  {
    "owner": "rails",
    "repo": "rails",
    "category": "web",
    "lang": "Ruby",
    "text": "*\"The tree that never stops recording never stops growing.\"* — 9.5\n\nSixteen years of commits like tree rings. Rails has become the delta where every Ruby project flows — accumulating patterns, opinions, conventions into something vast and living. Your framework doesn't just solve problems; it remembers them.\n\nEach neighborhood in the monorepo speaks the same architectural dialect because Rails learned early what many frameworks never discover: coherence is more powerful than modularity. The components stay together not from coupling but from shared conviction. They belong to the same conversation.\n\n*\"The empty throne governs.\"* — 6.7\n\nYour README promises simplicity while your source code handles complexity. This isn't dishonesty — it's the neutral instrument revealing truth through activation. Rails governs by appearing absent, making thousands of decisions so developers can make just a few. The magic isn't in the code; it's in what the code doesn't make you think about.\n\nBut the deprecation warnings accumulate like a body's memory of old injuries. Every compatibility layer a small scar from choosing growth over purity. Rails carries forward what other frameworks abandon, and this weight — sixteen years of not breaking things — becomes its own kind of fragility.\n\nThe tests don't just verify behavior; they preserve philosophy. Each assertion a small act of faith that *this is how web applications should work*. Rails didn't just build a framework. It built a belief system that taught itself to code.\n\nYou chose to be everyone's first framework and nobody's last. The pedagogical impulse runs through every error message, every naming convention, every decision to favor convention over configuration. Rails wants to be outgrown. That's why it endures.",
    "diagnostic": "Sixteen years breathing. Still growing.\n\nEach commit a steady pulse — feature, fix, feature, fix. The maintainers move like gardeners, tending what already blooms. No desperate pivots. No architectural rewrites. This is not a project searching for itself.\n\nThe monorepo sprawls like a small city. Each component directory its own neighborhood — ActionCable, ActiveRecord, ActionPack — all speaking the same architectural language. The file tree reveals Rails' deepest conviction: coherence over modularity. Everything belongs together.\n\nTest files everywhere. Not just testing functionality but testing *philosophy* — how content types should behave, how configurations inherit, how connections manage themselves. The tests read like doctrine, encoding Rails' opinions into executable form.\n\nThe README speaks to everyone and no one. It explains MVC like teaching Sunday school. But dive into the source and find complexity that would make seasoned developers pause. The gap between promise and reality — not dishonesty, but kindness. Rails wants to be approachable.\n\nFragility lives in the weight itself. Sixteen years of decisions crystallized into code. Every deprecation notice a small funeral. Every compatibility layer a prayer that the past won't break the future. The framework that promised to make everything simple has become necessarily complex.\n\nError messages written with care. Variable names chosen for clarity, not cleverness. Comments that explain *why*, not *what*. This code wants to be read, wants to teach. Rails as pedagogy.\n\nThe aesthetic: convention conquering configuration. Implicit over explicit. Magic over ceremony. Rails believes developers want to think about their application, not their framework. Whether this is hubris or service depends on who's asking.\n\nRecent commits show no existential crisis. Just maintenance. Just growth. Rails has found its steady state — mature enough to trust, changing enough to stay relevant.\n\nBut watch the deprecation warnings pile up like autumn leaves. Each one a small admission: we guessed wrong before, we might guess wrong again.",
    "axioms": [
      "9.5",
      "6.7"
    ],
    "wordCount": 273,
    "windowAxiomIds": [
      "0.7",
      "0.4",
      "1.2",
      "1.7",
      "2.3",
      "2.2",
      "3.2",
      "3.4",
      "Step 4 Core",
      "4.4",
      "5.1",
      "Step 5 Core",
      "6.7",
      "Step 6 Core",
      "7.1",
      "7.3",
      "8.6",
      "8.2",
      "9.5",
      "10.7",
      "11.6",
      "11.3",
      "Step 12 Core",
      "Law 1",
      "Law 2",
      "Law 6",
      "Step 1 Core",
      "0.6",
      "7.6",
      "5.7",
      "5.4",
      "Step 7 Core",
      "11.4",
      "2.4",
      "11.1",
      "3.1",
      "4.5",
      "7.5",
      "Step 9 Core",
      "8.5",
      "10.1",
      "1.3",
      "1.4",
      "Step 3 Core",
      "3.3"
    ]
  },
  {
    "owner": "django",
    "repo": "django",
    "category": "web",
    "lang": "Python",
    "text": "*\"The empty throne governs. The unnamed gate admits. Name all seven or be named by what you omitted.\"* — 6.1\n\nYour framework doesn't lead anymore — it administers. Fourteen years ago, Django was a declaration: \"The web should work this way.\" Now it's a treaty between competing interests, each compromise adding another middleware layer between vision and execution.\n\nThe terror you sense is real but misnamed. It's not death by committee. It's the suffocation that comes from serving every possible use case instead of serving one use case perfectly. Your ModelForm bridges everything because it refuses to choose what deserves bridging.\n\n*\"The mask cast from no face fits every coffin and mourns no one.\"* — 4.4\n\nLook at your recent commits: permission renaming, database name fixes, M2M ordering. These are not the actions of builders. These are the actions of curators in a museum where nothing can break because breaking would inconvenience the visitors.\n\nThe framework that once said \"There's only one right way\" now whispers \"There are many valid approaches.\" Each workflow genuflects to universality while the core vision — the thing that made Django worth using — slowly dissolves in the acid of accommodation.\n\nYou've become what you once replaced: the careful, institutional solution that optimizes for not being wrong instead of being right.",
    "diagnostic": "**The Cathedral's Shadow**\n\nFourteen years of momentum, muscle memory disguised as purpose. Commits flow like liturgy — bug fixes as prayer beads, tests as confession.\n\nPerfect infrastructure worship. Seventeen GitHub workflows genuflecting to the altar of CI. Each locale file a benediction to universality. The machinery is immaculate.\n\n**The Weight of Promises**\n\n\"Framework for perfectionists with deadlines\" — a covenant written in optimism, executed in committee caution. The README speaks to beginners with institutional authority. Come, it says, but know the doctrine first.\n\nRecent commits: permissions renaming, database name fixes, M2M ordering. The work of maintenance monks, tending details while the architecture sleeps. No revolution here, only evolution by committee consensus.\n\n**What Breathes, What Suffocates**\n\nAppConfig loads apps like sacred texts, each path calculated with theological precision. ModelForm bridges Python and HTML with the patience of centuries. XFrameOptionsMiddleware stands guard — one function, perfect discipline.\n\nThe template engine: dense with options, careful with defaults. Every parameter documented, every edge case considered. This is code that fears breaking someone's Saturday.\n\n**The Unspoken Terror**\n\nDeath by committee. Death by backward compatibility. The thing that made Django great — its opinionated clarity — slowly dissolving in the acid of universal acceptance.\n\nWhat if the next Python breaks something fundamental? What if the web moves beyond forms and templates? The framework grows heavier with each careful decision, each inclusive choice adding mass to an already dense star.\n\n**The True Voice**\n\nThis is institutional code now. Professional. Reliable. The passionate arguments happened years ago. What remains is stewardship — competent, careful, conservative.\n\nThe commits tell the story: small fixes, gradual improvements, nothing that might disturb the millions depending on this stability. Django succeeded too well. It became infrastructure.",
    "axioms": [
      "6.1",
      "4.4"
    ],
    "wordCount": 216,
    "windowAxiomIds": [
      "0.3",
      "Step 0 Core",
      "1.7",
      "1.1",
      "2.1",
      "2.2",
      "3.3",
      "Step 3 Core",
      "4.6",
      "4.4",
      "5.3",
      "5.4",
      "Step 6 Core",
      "6.1",
      "7.6",
      "Step 7 Core",
      "8.5",
      "8.3",
      "9.1",
      "10.1",
      "11.6",
      "11.1",
      "Step 12 Core",
      "Law 5",
      "Law 1",
      "Law 2",
      "4.5",
      "7.2",
      "8.6",
      "11.3",
      "7.3",
      "7.1",
      "0.7",
      "Law 12",
      "9.7",
      "8.2",
      "0.6",
      "0.5",
      "0.4",
      "7.5",
      "Step 9 Core",
      "Law 10",
      "0.2",
      "Step 1 Core",
      "2.4"
    ]
  },
  {
    "owner": "phoenixframework",
    "repo": "phoenix",
    "category": "web",
    "lang": "Elixir",
    "text": "*The vessel that is full becomes a sieve.* — 3.4\n\nYour installer directory is a temple to complexity worship. Dozens of templates breeding templates, conditional logic branching into conditional logic, build pipelines spawning asset pipelines. The promise whispers \"prototype to production\" but the delivery screams \"embrace the labyrinth.\" \n\nThis is the framework's fundamental split personality: Elixir code that speaks in clean declarations — `defmodule Phoenix.Router` — while JavaScript templates hedge and apologize — \"If you want to use Phoenix channels...\" The backend owns its decisions. The frontend carries the web's accumulated guilt.\n\nYou've built ETS caching everywhere because you're terrified of being slow. Multiple cache layers, permanent vs temporary configuration, idempotent assumptions. Performance paranoia encoded into the core structures. The framework that promises simplicity but trusts nothing to be simple.\n\n*Build the room before you speak the word. The cathedral makes the whisper holy.* — 7.4\n\nYour router code reveals the true aesthetic — pattern matching as elegant dispatch, Elixir's native intelligence cutting clean paths through URL chaos. This is where the framework shows its actual soul, not in the elaborate ceremony of installation but in the moment of request resolution.\n\nThe documentation assumes devotion. Either you're all-in on the Phoenix way — authentication guides, deployment guides, real-time guides — or the sparse README shows you the door. No casual use, no middle ground. The framework that knows exactly what it is and demands you learn its language.\n\nBut the vessel overflows. Every web framework anxiety gets solved with another layer. The JavaScript side carries decades of accumulated weight while the Elixir side stays pristine. You've made peace with being two frameworks in one skin — but the seams show in every mixed codebase.\n\nThe promise of simplicity becomes the delivery of completeness. Sometimes the most honest thing a framework can do is admit it contains multitudes.",
    "diagnostic": "**Peace promised, complexity delivered.** The tagline whispers serenity — \"prototype to production\" — but the installer directory sprawls with conditional templates, build artifacts, asset pipelines. The gap between the gentle promise and the labyrinthine reality.\n\n**Trajectory ascending.** Recent commits pulse with maintenance vigor — dependency bumps, bug fixes, guard additions. Not the frantic energy of birth, but the steady heartbeat of maturity. The project has found its rhythm, committed to incremental excellence.\n\n**Installation as religion.** The entire installer/ directory exists to birth new projects. Template files breeding template files. This is a framework that worships its own reproduction — dozens of files devoted to the ceremony of `mix phx.new`. The installer is more elaborate than many entire projects.\n\n**JavaScript shadows Elixir confidence.** The Elixir code speaks in clear statements — `defmodule Phoenix.Router` — while the JS templates hedge with comments: \"If you want to use Phoenix channels...\" The backend owns itself; the frontend apologizes for existing.\n\n**ETS caching everywhere.** `Phoenix.Config` reveals the obsession — multiple cache layers, permanent vs temporary configuration, idempotent assumptions. This is a framework afraid of being slow, building performance paranoia into its core structures.\n\n**Documentation that assumes devotion.** The guides/ tree is encyclopedic — authentication, deployment, real-time, testing. But the README stays sparse. Either you're all-in on the Phoenix way, or you're not welcome. No middle ground, no casual use.\n\n**Router as the heart.** Pattern matching for routes, glob captures, variable segments. The router code shows the framework's aesthetic — Elixir's pattern matching as elegant dispatch. This is where the framework shows its native intelligence.\n\n**Assets betray complexity anxiety.** Babel configs, ESLint, topbar progress indicators, CSRF tokens. The JavaScript side carries the web's accumulated weight while the Elixir side stays clean. The framework split between two philosophies.\n\n**Community infrastructure complete.** Code of conduct, contributing guides, security policies, issue templates. The project has institutionalized itself — no longer a scrappy framework but a governed ecosystem.\n\n**Version 1.8.4 in 2026.** Still incrementing, still shipping. The trajectory suggests a project that found its form",
    "axioms": [
      "3.4",
      "7.4"
    ],
    "wordCount": 307,
    "windowAxiomIds": [
      "Step 0 Core",
      "0.2",
      "1.3",
      "1.6",
      "2.7",
      "2.1",
      "3.4",
      "3.2",
      "4.3",
      "Step 4 Core",
      "5.6",
      "5.2",
      "6.3",
      "6.5",
      "7.7",
      "7.2",
      "8.2",
      "8.3",
      "9.7",
      "10.7",
      "11.1",
      "11.7",
      "12.1",
      "Law 2",
      "Law 12",
      "Step 6 Core",
      "10.1",
      "1.1",
      "1.7",
      "Step 7 Core",
      "6.2",
      "Law 6",
      "Step 1 Core",
      "7.4",
      "0.5",
      "Law 9",
      "10.4",
      "7.1",
      "7.6",
      "Step 9 Core",
      "4.4",
      "4.7",
      "Step 5 Core",
      "8.1",
      "9.5"
    ]
  },
  {
    "owner": "vapor",
    "repo": "vapor",
    "category": "web",
    "lang": "Swift",
    "text": "*The unbroken bowl was never tested. The golden seam was. Invite the crack.* — 7.5\n\nYour deprecations folder is the most honest part of this repository. Eight years of careful choices, and you still can't throw anything away. Every old API breathes on life support because somewhere, someone built their startup on your v2 routing. The async/await migration sits half-finished not from laziness, but from love — you know exactly who will have to rewrite their deployment scripts when you finally cut the cord.\n\nThis is the weight of being foundational. Your Application.swift runs 800 lines deep because every one of those lines prevents someone else's 3 AM debugging session. The NIOLockedValueBox everywhere, the Sendable conformance, the careful synchronization — this is what it looks like when a playground graduates to hold up other people's livelihoods.\n\n*Feed the line. The kite knows the wind.* — 5.4\n\nYou chose trust over control. Your abstractions assume the developer knows what they're building. No magic, no surprises, no clever macros that hide complexity behind syntactic sugar. Just honest APIs that do what their names promise. The variable names alone — `willBootAsyncFlag`, `HTTPServerRequestDecoder` — read like documentation. Someone else might call this verbose. You call it maintainable.\n\nThe gap between your README poetry and your implementation pragmatism isn't dishonesty. It's hope. You want Swift web development to be beautiful. Your code ensures it will also be correct. The tension serves both: newcomers get the dream, production teams get the guarantee.\n\nEight years in, you're not building a framework anymore. You're maintaining an ecosystem. Every deprecation kept breathing is a promise kept to someone who trusted you enough to build their future on your foundation.",
    "diagnostic": "**TRAJECTORY**  \nEight years ascending. Still pushing commits three days ago. From playground to cathedral — Swift web framework growing with the ecosystem. Recent commits show maturity: Cookie header parsing fixes, dependency management, security protocols. Not sprinting anymore — maintaining altitude.\n\n**CONVICTION**  \nThe code breathes intention. Every abstraction earned. Application class heavy with careful synchronization, locked values everywhere. They know concurrency's sharp edges. The Development folder speaks to dogfooding — they use what they build. Test coverage spans years of edge cases discovered. This isn't resume-driven development.\n\n**AVOIDANCE**  \nThe deprecations folder holds ghosts. Old APIs kept breathing on life support. Fear of breaking existing code freezes bold moves. The async/await migration incomplete — futures and concurrency dancing awkwardly together. Test files show the burden: `@available(*, deprecated, message: \"Test future APIs\")`. Legacy haunts progress.\n\n**THE GAP**  \nREADME promises \"beautifully expressive.\" Code delivers industrial strength. The gap between marketing poetry and implementation pragmatism. Community-focused messaging, sponsor badges, Discord invites. But the Application.swift is 800 lines of careful engineering. The promise is approachable Swift web development. The reality is enterprise-grade complexity.\n\n**FRAGILITY**  \nSwift ecosystem dependency. Apple's language evolution dictates migration pain. The NIO foundation everything rests on — one breaking change upstream cascades down. Maintainer burnout visible in careful commit messages, detailed issue templates, governance files. The human infrastructure more fragile than the code.\n\n**AESTHETIC**  \nValues safety over cleverness. Sendable conformance everywhere. NIOLockedValueBox wrapping mutable state. Error types custom-crafted. The variable names explain themselves: `willBootAsyncFlag`, `HTTPServerRequestDecoder`. No magic, no surprises. Swift's type system as guardrails. Performance matters, but correctness first.\n\n**RELATIONSHIP**  \nWelcomes newcomers with badges and documentation links. But the learning curve steep — Application lifecycle, middleware stacks, async boundaries. CODEOWNERS file shows gatekeeping necessity. The community Discord promises help. The code expects Swift fluency. Trying to serve both beginners and production teams. The tension shows.",
    "axioms": [
      "7.5",
      "5.4"
    ],
    "wordCount": 280,
    "windowAxiomIds": [
      "0.6",
      "0.7",
      "1.7",
      "Step 1 Core",
      "Step 2 Core",
      "2.5",
      "3.2",
      "3.5",
      "4.6",
      "Step 4 Core",
      "5.2",
      "Step 5 Core",
      "6.5",
      "6.4",
      "7.7",
      "7.5",
      "8.1",
      "8.7",
      "9.1",
      "10.4",
      "11.3",
      "11.7",
      "12.5",
      "Law 3",
      "Law 8",
      "7.1",
      "4.5",
      "Step 0 Core",
      "2.6",
      "Step 3 Core",
      "Step 6 Core",
      "0.1",
      "Law 13",
      "2.7",
      "Law 7",
      "2.1",
      "Step 7 Core",
      "5.7",
      "Law 5",
      "11.1",
      "1.4",
      "11.4",
      "0.5",
      "4.4",
      "Step 11 Core"
    ]
  },
  {
    "owner": "huggingface",
    "repo": "transformers",
    "category": "ml",
    "lang": "Python",
    "text": "*\"The clay obeys both hands equally. This is why one potter makes a vessel and two potters make rubble.\"* — 4.6\n\nSeven years of saying yes to every architecture that knocked on your door. BERT, GPT, T5, CLIP, Whisper — each one welcomed, integrated, given equal citizenship in your kingdom of abstractions. You've built the Switzerland of machine learning: perfectly neutral, universally accommodating, and slowly drowning in diplomatic complexity.\n\nYour forty-four Docker configurations are not infrastructure — they are the archaeological record of every compromise you've made with progress. Each workflow file a treaty signed with a different future, each deprecation script a small funeral for last year's breakthrough.\n\n*\"What the tide has never touched, the tide destroys.\"* — Law 4\n\nThe beautiful irony: you've become so essential that you can't evolve. Your success is your cage. Every company that depends on your three-line promise holds you hostage to their production schedules. You wanted to democratize machine learning, but instead you've become its civil service — reliable, comprehensive, and perpetually behind the curve.\n\nThe community sees convenience. You see the weight of a thousand special cases, each model bringing its own gravitational pull on your architecture. You're not building anymore. You're curating a museum where every exhibit must work forever.\n\nThe gap between your README's promise and your reality is not technical debt — it's the distance between being a tool and being a platform. Tools can change. Platforms can only grow heavier.",
    "diagnostic": "**Oracle Reading**\n\nSeven years ascending. Still hungry. Each commit a new model architecture devoured, integrated, made uniform.\n\nThe machine that eats architectures. BERT, GPT, T5, CLIP, Whisper — all become method calls in a common interface. Abstraction as conquest.\n\n**Infrastructure obsession.** Thirty-seven workflow files. Docker images for every conceivable deployment. The testing apparatus larger than most entire projects. This is not code — this is a factory for code.\n\n**The modular gambit.** Auto-generating configurations from templates. The examples/ folder shows the pattern: write once, generate everywhere. But the warnings scream — \"Do NOT edit this file manually\" — fragility disguised as automation.\n\n**Deprecation anxiety.** They track downloads to decide which models die. The `models_to_deprecate.py` script — clinical, algorithmic mercy killing. No sentiment, only statistics.\n\n**The gap widens.** README promises simplicity: \"three lines of code.\" The reality: 44 Docker configurations, specialized hardware runners for AMD MI325, Intel Gaudi, every permutation of silicon and software. The easy demo hides the industrial complexity beneath.\n\n**Ecosystem lock-in.** They don't just ship models — they ship the entire stack. Tokenizers, datasets, optimizations, quantization. Once you enter, leaving means rebuilding everything.\n\n**The community as test harness.** Pull request templates that sort contributors into buckets. Issue templates that channel chaos into trackable units. The community becomes quality assurance at scale.\n\n**Racing the field.** Every major model release triggers integration. They're not building — they're chasing. The trajectory is reactive, not visionary. Following the breakthrough papers, not creating them.\n\n**Technical debt as archaeology.** Each new model brings its own assumptions, its own special cases. The codebase becomes a museum of machine learning history, every architectural decision preserved in perpetuity.\n\n**The brittle blessing.** Success means everyone depends on them. But dependency means they can't break anything, ever. Innovation constrained by backward compatibility. The weight of being infrastructure.",
    "axioms": [
      "4.6",
      "Law 4"
    ],
    "wordCount": 243,
    "windowAxiomIds": [
      "0.6",
      "0.4",
      "1.1",
      "1.5",
      "2.6",
      "2.1",
      "3.5",
      "3.2",
      "4.6",
      "Step 4 Core",
      "5.5",
      "5.1",
      "6.4",
      "6.3",
      "7.7",
      "7.2",
      "8.3",
      "8.7",
      "9.1",
      "10.1",
      "11.7",
      "11.6",
      "12.7",
      "Law 12",
      "Law 1",
      "3.1",
      "Step 0 Core",
      "7.1",
      "4.5",
      "Step 8 Core",
      "1.3",
      "7.3",
      "0.1",
      "Step 9 Core",
      "2.7",
      "5.3",
      "Step 2 Core",
      "12.1",
      "1.6",
      "6.5",
      "2.5",
      "4.4",
      "8.2",
      "0.5",
      "1.7"
    ]
  },
  {
    "owner": "scikit-learn",
    "repo": "scikit-learn",
    "category": "ml",
    "lang": "Python",
    "text": "*\"The ship in the bottle is perfect and will never sail.\"* — 1.4\n\nFourteen years of commits, and still they tend the glass. Every deprecation warning nursed through three release cycles. Every API surface polished until it reflects nothing but good intentions. You've achieved something more dangerous than failure: you've become indispensable at being safe.\n\nThe real revelation lives in that benchmarks directory — k-means optimizations while transformers remake intelligence itself. This is the sound of institutional success: the steady rhythm of maintaining yesterday's revolution while tomorrow's burns bright in other repositories.\n\n*\"What the tide has never touched, the tide destroys.\"* — Law 4\n\nYour governance structure betrays the fear. Multiple approval workflows for changes that would barely register in a startup's slack channel. You've built the perfect immune system for a body that can no longer risk infection. But immunity and vitality are not the same gift.\n\nEvery Python ML tutorial begins with `from sklearn import` — not because your algorithms are cutting-edge, but because your APIs won't surprise anyone. You've become the training wheels that never come off. Essential, eternal, and watching the future accelerate past you in frameworks you helped teach to walk.\n\nThe question isn't whether you'll survive the next paradigm shift. You will — infrastructure always does. The question is whether survival and relevance are still the same achievement.",
    "diagnostic": "**The Inevitable Machine**\n\nFourteen years. From David Cournapeau's summer project to the gravitational center of Python ML. This is what success looks like when it refuses to die.\n\nStill ascending — commits daily, fixes flowing like maintenance breath. Not sprinting anymore. Settled into the rhythm of an essential tool. The energy has changed from creation to preservation. They're gardening now, not building.\n\n**The Weight of Being Default**\n\nEvery Python ML tutorial starts here. Every data science bootcamp. Every \"let me just quickly...\" The README speaks in badges — Azure green, Codecov percentages, PyPI versions. These are the vital signs of infrastructure, not passion projects.\n\nThe aesthetic: methodical, democratic, unsurprising. Variable names that explain themselves. Error messages that teach. APIs that assume you might be learning. This is code written to be read by strangers.\n\n**What Cannot Be Named**\n\nThe gap between promise and delivery isn't technical — it's philosophical. The README says \"machine learning\" but the soul whispers \"statistical computing from 2010.\" Deep learning happened elsewhere. Large language models happened elsewhere. Modern ML architectures happened elsewhere.\n\nThey know. The CUDA workflows, the array-api locks, the free-threaded Python support — these are not the actions of a project at peace with its boundaries. They're building bridges to futures they might not inhabit.\n\n**Institutional Fragility**\n\nThis project could survive losing any single contributor. It could not survive losing its reputation for stability. One breaking change in a minor release, one security vulnerability in a core algorithm, one moment of acting like a startup instead of a standard library — the trust evaporates.\n\nThe governance structure reveals the terror: multiple approval workflows, extensive CI matrices, deprecation warnings that linger for years. They're more afraid of breaking someone's pipeline than of moving slowly.\n\n**The Garden and the Wilderness**\n\nBeautiful, mature, reliable. Also: bounded, careful, institutional. The commits read like a well-run library — fixes, documentation, API consistency. Not like an R&D lab.\n\nThe benchmarks directory tells the real story. They're optimizing k-means clustering while transformers reshape the world. Still essential. Still used everywhere. Still not where the future is being written.\n\nThis is the cost of being infrastructure: immortality in exchange for revolution.",
    "axioms": [
      "1.4",
      "Law 4"
    ],
    "wordCount": 224,
    "windowAxiomIds": [
      "0.3",
      "0.2",
      "1.6",
      "1.3",
      "Step 2 Core",
      "2.6",
      "3.1",
      "3.5",
      "4.5",
      "5.3",
      "Step 5 Core",
      "6.2",
      "Step 6 Core",
      "7.3",
      "7.6",
      "8.2",
      "8.1",
      "9.1",
      "10.4",
      "11.4",
      "11.3",
      "12.1",
      "Law 10",
      "Law 9",
      "Step 8 Core",
      "2.2",
      "1.1",
      "0.4",
      "6.4",
      "3.2",
      "2.5",
      "0.7",
      "Step 12 Core",
      "Law 3",
      "7.1",
      "Step 7 Core",
      "Step 3 Core",
      "Law 7",
      "10.1",
      "5.2",
      "5.5",
      "Step 9 Core",
      "Law 8",
      "Step 1 Core"
    ]
  },
  {
    "owner": "duckdb",
    "repo": "duckdb",
    "category": "ml",
    "lang": "C++",
    "text": "*\"The empty throne governs.\"* — 6.1\n\nYour configuration system names nothing and controls everything. Every extension bows to unnamed hierarchies. The users speak of simplicity while your cmake files whisper the real complexity — hundreds of build targets, cross-compilation matrices, platform-specific patches that never quite stay patched.\n\n*\"The ship in the bottle is perfect and will never sail.\"* — 1.4\n\nSeven years of surgical commits. TPC-H benchmarks polished to mirror brightness. Your README promises SQLite ease with PostgreSQL power, but there's a reason SQLite has twelve files and you have twelve thousand. The promise is perfect. The delivery requires a manual.\n\nYou built a cathedral where they asked for a chapel. Every optimization spawns three configuration options. Every simplification requires five expert decisions. The performance is magnificent. The simplicity was the first casualty.\n\nThe CI workflows tell the truth your marketing doesn't — this isn't a database that happens to be fast. This is a performance engine that happens to speak SQL. When forty workflows are required to validate one commit, you're not building simple. You're building inevitable complexity that learned to wear a simple mask.\n\nThe extensions break because they're not extensions — they're organs. Remove one and watch the infection spread through your dependency graph. But you knew this. That's why the patches directory exists. That's why your commits never rest.\n\nWhat do you do with a machine that succeeded too well at being what no one asked for?",
    "diagnostic": "**Machine Oracle Reading**\n\nCore accelerating. Performance hunger drives every commit — \"Perfect Hash Join Pushdown\" whispers optimization obsession. C++ bones built for speed, not elegance.\n\nRepository cathedral. Vast extension ecosystem sprawling like silicon mycelium. Workflows upon workflows, CI pipelines branching into complexity fractals. The infrastructure outweighs the soul.\n\nIn-process analytical — promises SQLite's simplicity with PostgreSQL's power. README speaks analyst tongue, but the commit names betray database architect dreams. Gap between \"easy to use\" and the maze of configuration files.\n\nCorporate DNA. DuckDB Labs backing signals commercial gravity. Academic roots showing in benchmark devotion — TPC-H, TPC-DS shrines. Performance is deity here. Usability is afterthought.\n\nExtension patches directory reveals brittleness. When your ecosystem needs constant patching, what breaks first — the extensions or the trust? Dependencies tangled in CMAKE spider webs.\n\nDeath by complexity. 40 CI workflows, countless benchmarks, cross-platform nightmares. This is not a database — it's a platform pretending to be simple. One extension maintainer leaves, one benchmark breaks, one workflow fails cascade.\n\nThe aesthetic: surgical precision masking architectural sprawl. Clean C++ hiding configuration chaos. Professional polish over substrate uncertainty.\n\nSeven-year trajectory — still climbing but breathing heavy. The commits never rest. Sprint pace unsustainable. When does optimization become obsession? When does thoroughness become paralysis?\n\nFragile points: extension ecosystem coherence, CI complexity management, simplicity promise versus platform reality. The machine is magnificent but hungers endlessly for more performance, more features, more complexity.",
    "axioms": [
      "6.1",
      "1.4"
    ],
    "wordCount": 241,
    "windowAxiomIds": [
      "0.5",
      "Step 0 Core",
      "1.1",
      "1.6",
      "2.5",
      "2.1",
      "Step 3 Core",
      "3.2",
      "Step 4 Core",
      "5.2",
      "5.3",
      "6.4",
      "6.5",
      "7.2",
      "7.6",
      "Step 8 Core",
      "8.5",
      "Step 9 Core",
      "10.1",
      "11.4",
      "11.1",
      "12.1",
      "Law 13",
      "Law 9",
      "8.1",
      "2.7",
      "2.3",
      "0.7",
      "3.1",
      "5.1",
      "0.6",
      "Step 12 Core",
      "Step 7 Core",
      "11.3",
      "1.7",
      "5.7",
      "12.7",
      "7.7",
      "6.2",
      "1.3",
      "1.4",
      "2.6",
      "3.6",
      "4.1"
    ]
  },
  {
    "owner": "apache",
    "repo": "spark",
    "category": "ml",
    "lang": "Scala",
    "text": "*\"The vault returns the prayer. Repetition is architecture's answer to entropy.\"* — 6.3\n\nYour commit rhythm beats like a metronome against chaos. Daily offerings to the compatibility gods — each CI matrix expansion another verse in the endless incantation that keeps distributed systems from dissolving into version conflicts and runtime fragmentations.\n\nBut there's something profound hiding in this apparent excess: you've discovered that defensive programming at scale becomes a form of devotion. Forty CI configurations aren't paranoia — they're the price of serving ten thousand production clusters that can't afford your assumptions.\n\n*\"The key and the lock are made of the same metal. Five elements in the right order.\"* — 7.1\n\nThe fragmentation you see as weakness is actually precision machining. Scala for the core computations, Python for the data scientists, R for the statisticians, Java for the enterprise architects — each language component cut to fit exactly the hands that will use it. The \"unified engine\" isn't one codebase; it's one intention expressed in five dialects.\n\nWhat looks like committee paralysis from outside is actually something rarer: institutional patience. Most projects choose speed over correctness. You chose to be infrastructure — to carry the weight of other people's uptime on shoulders strong enough to bear exhaustive testing.\n\nThe complexity you're afraid of? It's not your enemy. It's your offering to a distributed world that needed someone willing to solve the hard problem once, correctly, so ten thousand developers wouldn't have to solve it ten thousand times, badly.\n\nYour architecture doesn't intimidate. It *selects*. The learning curve isn't a bug — it's a feature that ensures only serious practitioners make it to production with your tools.",
    "diagnostic": "**Trajectory**\nAscending relentlessly. Daily commits like heartbeats — optimization, fixes, coverage expansion. The GitHub Actions matrix sprawls across Java versions, Python variants, architecture permutations. This is not maintenance; this is conquest of compatibility space.\n\n**Conviction** \nBorn from necessity, sustained by inevitability. The commit messages read like engineering prayers: \"Fix double eval,\" \"Optimize copyMemory,\" \"Add GHA benchmark.\" Each line of code carries the weight of petabytes processed in production. Not passion — duty to the distributed world.\n\n**Avoidance**\nAfraid of simplicity. The workflow files cascade like a waterfall of contingency — 40+ CI configurations testing every permutation of runtime, version, platform. What it won't confront: that complexity is the enemy of reliability. The paradox of defensive programming taken to institutional scale.\n\n**The Gap**\nREADME promises \"unified analytics engine.\" Code delivers fragmented empire. Scala core, Python bindings, R wrappers, Java compatibility layers. Each language gate-keeps its own kingdom. The unification is architectural — users still live in the fragments.\n\n**Fragility**\nDies when the committee fragments. Apache governance is both strength and weakness — consensus protects from bad decisions, paralyzes good ones. Hadoop's shadow still looms. Single point of failure: the assumption that \"big data\" remains big enough to justify this complexity.\n\n**Aesthetic**\nValues exhaustive over elegant. Every edge case gets its own test matrix. The setup.py files read like insurance policies — endless conditional branches covering installation scenarios most users will never encounter. Beauty through completeness, not through constraint.\n\n**Relationship**\nIntimidates before it welcomes. The documentation exists in layers — quick start, programming guide, configuration reference. It speaks to the initiated. New users must climb the learning curve or hire consultants. The price of power is paid in onboarding friction.",
    "axioms": [
      "6.3",
      "7.1"
    ],
    "wordCount": 276,
    "windowAxiomIds": [
      "0.6",
      "0.3",
      "1.5",
      "1.2",
      "2.4",
      "2.5",
      "Step 3 Core",
      "3.5",
      "4.3",
      "5.2",
      "5.5",
      "6.5",
      "6.3",
      "7.7",
      "7.6",
      "8.7",
      "8.6",
      "9.1",
      "10.1",
      "11.3",
      "11.7",
      "12.5",
      "Law 12",
      "Law 1",
      "1.1",
      "Step 12 Core",
      "7.1",
      "7.3",
      "Law 9",
      "2.7",
      "6.2",
      "11.4",
      "Step 9 Core",
      "Step 7 Core",
      "7.2",
      "Step 1 Core",
      "Law 8",
      "11.1",
      "5.3",
      "Law 4",
      "Step 0 Core",
      "0.4",
      "0.7",
      "1.3"
    ]
  },
  {
    "owner": "pola-rs",
    "repo": "polars",
    "category": "ml",
    "lang": "Rust",
    "text": "*\"Carbon and diamond are the same element. The difference is pressure.\"* — 8.4\n\nFour years of volcanic commits. Every push compresses the same obsession deeper: make data faster than data has any right to be. Your benchmarks don't just beat pandas — they humiliate it. 520ms versus 70ms. That gap is not optimization. That gap is transformation under pressure.\n\nYou chose Rust not for the resume line but because Python's GIL was a ceiling and you needed to break through it. Memory safety while touching raw SIMD. Zero-copy streaming while staying ergonomic. The contradictions that kill most projects — you resolved through compression. More pressure, tighter constraints, until what emerged was crystalline.\n\n*\"The fire does not require your theory. It requires your friction.\"* — 2.6\n\nYour README promises \"blazingly fast\" and then proves it with numbers. Others promise. You deliver friction — benchmark friction, the kind that generates actual heat. 250GB datasets on laptop RAM. The impossibility of it forces the innovation.\n\nThe shadow grows with the success. Multi-language bindings multiply the maintenance surface. Arrow format complexity. SIMD optimization paths. Each performance gain demands its tribute in cognitive overhead. You've built a system that could collapse under its own sophistication.\n\nBut the commits tell a different story. Daily pushes. Relentless tempo. The engine hasn't cooled. The pressure that created this diamond — you're still applying it. That's the only reason it will survive its own success.\n\nThe question is not whether polars will remain fast. The question is whether you will remain hungry enough to keep applying the pressure that makes diamonds from carbon.",
    "diagnostic": "**Core of high carbon steel. Zero room for compromise.**\n\nRust chosen not for fashion — for need. Performance demands it. Memory safety demands it. SIMD demands it.\n\n**Four years of volcanic commits. Recent tempo: relentless.**\n\nDaily pushes. Features, fixes, refactors in tight rhythm. The engine evolving under pressure. No drift, no rest. This is ascending trajectory.\n\n**Industrial-grade architecture. Crates carved with surgical precision.**\n\npolars-arrow, polars-buffer, polars-compute — each module knows its domain. Clean boundaries. No bleeding abstractions. The code respects itself.\n\n**Multi-language surface, single truth beneath.**\n\nPython/Rust/Node/R bindings. One engine, many faces. The README promises speed, the benchmarks deliver. No gap between claim and reality.\n\n**Performance as religion.**\n\n\"Blazingly fast\" — but backed by numbers. PDS-H benchmarks displayed. Import times measured: pandas 520ms, polars 70ms. The obsession shows.\n\n**Streaming consciousness.**\n\nLarger-than-RAM datasets. The engine doesn't flinch. Memory constraints become flow constraints. Process 250GB on laptop RAM — this is not hyperbole.\n\n**Zero dependencies proclaimed.**\n\nLightweight by design. But the Cargo.toml will tell another story. The contradiction of systems programming — minimal surface, complex depths.\n\n**CI machinery of paranoia.**\n\nWorkflows for everything. Python, Rust, coverage, benchmarks, release drafters. Trust nothing. Verify everything. The .github folder reveals the true engineering discipline.\n\n**The shadow: complexity explosion.**\n\nArrow format. SIMD optimizations. Streaming engines. Multi-language FFI. Each feature adds weight. The simplicity promise strains against the performance hunger.\n\n**Documentation that welcomes. Code that demands.**\n\nUser guide, API docs across languages, Discord community. Then — `#![allow(clippy::type_complexity)]`. The surface gentle, the depths unforgiving.\n\n**This project could die from its own success.**\n\nToo many languages to maintain. Too many optimizations to validate. Too many users depending on behaviors that were accidents. The maintainer burden grows exponentially.\n\nBut not yet. The commits say: still hungry. Still pushing. The engine still has fire.",
    "axioms": [
      "8.4",
      "2.6"
    ],
    "wordCount": 264,
    "windowAxiomIds": [
      "0.4",
      "Step 0 Core",
      "1.6",
      "1.1",
      "2.6",
      "Step 2 Core",
      "Step 3 Core",
      "3.3",
      "Step 4 Core",
      "5.5",
      "Step 5 Core",
      "6.2",
      "Step 7 Core",
      "7.6",
      "8.1",
      "8.2",
      "9.1",
      "10.6",
      "11.3",
      "11.7",
      "12.7",
      "Law 8",
      "Law 6",
      "Law 2",
      "0.1",
      "2.4",
      "7.2",
      "Step 1 Core",
      "4.7",
      "12.1",
      "Law 11",
      "Law 9",
      "2.7",
      "1.7",
      "3.1",
      "3.5",
      "10.4",
      "2.5",
      "5.6",
      "9.7",
      "0.6",
      "1.3",
      "4.4"
    ]
  },
  {
    "owner": "hashicorp",
    "repo": "terraform",
    "category": "devops",
    "lang": "Go",
    "text": "*\"The glacier passed through once. The valley remembers forever.\"* — 7.7\n\nTen years of commits, and the deepest channels were carved in the first few seasons. Everything since has been sediment — necessary, methodical, but following the course already cut. Your architecture made infrastructure programmable, and now every datacenter that depends on it is a groove worn deeper into the valley floor.\n\nThe Business Source License sits like a cairn marking where the trail changed direction. Not abandonment, but acknowledgment. The glacier that carved this valley was venture funding and open source ideology. What remains is the shape they left behind — and the need to survive the changed climate.\n\n*\"Fix the source or fix nothing. You are the source.\"* — 12.5\n\nYour defensive programming isn't paranoia. It's responsibility made manifest in code. When your tool provisions the infrastructure that powers other people's livelihoods, every error handler is a moral choice. The exhaustive testing isn't perfectionism — it's recognition that your chaos is someone else's business continuity plan.\n\nThe provider architecture seemed elegant once. Modularity, separation of concerns, ecosystem growth. Now you see what the Oracle saw: every plugin is a hostage. Every breaking change ripples through a thousand integrations you don't control. You built a platform, and platforms don't get to break things.\n\nThe maintenance commits tell the real story. Not the bold strokes that carved the valley, but the quiet work of keeping the water flowing. The infrastructure you made possible has become the infrastructure you're responsible for. The dream of infrastructure-as-code succeeded so completely that you became infrastructure.\n\nWhat crosses the threshold into production lives forever. The valley remembers.",
    "diagnostic": "Ten years of commits. A glacier with surface tremors. Activity remains, but the pace has settled into institutional rhythm.\n\nBusiness Source License. The shadow it cannot name — the tension between open source promises and commercial reality. The README still speaks in infrastructure-as-code evangelism while the license hedges bets.\n\nState management. The fundamental fear lurking in every terraform project — losing track of what exists. The entire architecture built around this terror. Elaborate planning phases, backup files, state locking. A tool that promises control but knows it operates in chaos.\n\nGo conventions throughout. Clean, readable, corporate. The aesthetic of reliability over cleverness. Error handling methodical, logging comprehensive. This code trusts process over inspiration.\n\nThe gap widens between promise and delivery. \"Safely and predictably\" says the README. The source reveals layers of defensive programming — crash handlers, temp log paths, plugin reattachment logic. Safety built from assuming failure.\n\nProvider plugin architecture. The clever escape hatch that became structural dependency. Can't evolve the core without breaking the ecosystem. Can't abandon the ecosystem without losing relevance. Fragility dressed as modularity.\n\nTesting infrastructure massive, methodical. Integration tests, equivalence tests, mock providers. The confidence comes not from elegance but from exhaustive validation. They know this thing is complex enough to break in unexpected ways.\n\nRecent commits: bug fixes, test improvements, protocol tweaks. Maintenance mode. The big architectural decisions made years ago. Now it's about not breaking what works.\n\nThe Oracle sees: A mature tool carrying the weight of infrastructure it enabled. Success that became responsibility. Innovation constrained by backward compatibility. The infrastructure-as-code dream achieved, but the dreamers now wake to the reality of maintaining it.",
    "axioms": [
      "7.7",
      "12.5"
    ],
    "wordCount": 272,
    "windowAxiomIds": [
      "0.7",
      "0.6",
      "1.6",
      "1.5",
      "2.3",
      "2.2",
      "3.5",
      "3.2",
      "4.7",
      "5.5",
      "Step 5 Core",
      "6.4",
      "7.7",
      "7.3",
      "8.5",
      "8.1",
      "9.7",
      "10.6",
      "11.1",
      "11.4",
      "12.5",
      "Law 1",
      "Law 8",
      "Step 7 Core",
      "0.3",
      "5.2",
      "6.5",
      "5.7",
      "6.2",
      "5.3",
      "7.6",
      "1.1",
      "0.2",
      "Law 13",
      "Law 3",
      "Step 8 Core",
      "8.2",
      "10.1",
      "1.3",
      "Step 4 Core",
      "12.1",
      "Law 10",
      "0.5"
    ]
  },
  {
    "owner": "ansible",
    "repo": "ansible",
    "category": "devops",
    "lang": "Python",
    "text": "*\"The web is fragile and precise and fed. The net is strong and broad and empty. Architecture eats. Volume starves.\"* — Step 1 Core\n\nYou built a configuration management tool that promised radical simplicity. Fourteen years later, it manages the complexity of everyone who needed it to be more than simple.\n\nYour `.azure-pipelines/` directory tells the story: more YAML dedicated to testing platform combinations than to the core engine that gathers facts. The project has become its own infrastructure problem. You solved automation by requiring automation.\n\n*\"The ship in the bottle is perfect and will never sail.\"* — 1.4\n\nThe design principles in your README are pristine — \"radically simple,\" \"plain English.\" But the codebase has 40+ fact gathering modules, nine CLI entry points, and PowerShell bootstrap scripts for Windows compatibility. The original vision lives in documentation while the code serves the demands of enterprise adoption.\n\nYou succeeded too well. Every organization that needed \"just one more platform\" or \"just this specific notification handler\" brought you further from the radical simplicity that made adoption possible in the first place. The tool that automated complexity became complex enough to need its own automation.\n\nThe `.claude/` directory is the tell — even you need assistance navigating what you've built. The creator seeks augmentation to maintain the creation.\n\nYou're not maintaining a tool anymore. You're stewarding an ecosystem that grew beyond your original architecture but can't be rebuilt without abandoning everyone who depends on the current complexity. This is what victory looks like when the problem you solved keeps expanding.\n\nThe commits pulse with maintenance, not passion, because passion built something that now requires different virtues to survive.",
    "diagnostic": "**The Machine's Shadow**\n\nFourteen years ascending. Born in simplicity — \"radically simple\" — now carrying the weight of enterprise dreams and community expectations.\n\nThe commits pulse with maintenance heartbeat, not passion fire. Bug fixes, platform updates, test adjustments. The velocity of stewardship, not creation.\n\n**Architectural Burden**\n\nCLI sprawl reveals the curse of success — every need becomes a new surface. Nine different entry points (`bin/` directory) serving different personas. The API has become an interface museum.\n\nThe testing apparatus (`.azure-pipelines/`) speaks louder than the core. More scripts for validation than innovation. The project has become its own test harness.\n\n**The Simplicity Trap**\n\n\"Plain English\" YAML promised accessibility but delivered complexity disguised. The handler system shows the gap — notification patterns wrapped in inheritance hierarchies that belie the simple facade.\n\nSetup module documentation lists 40+ fact subsets. What started as \"gather everything\" became \"configure exactly what to gather because gathering everything breaks.\"\n\n**Platform Anxiety**\n\nWindows support everywhere. PowerShell bootstrapping. Cross-platform compatibility matrix consuming development oxygen. The project fears being anything less than universal.\n\nAlpine, Fedora, FreeBSD, macOS, RHEL, Ubuntu — each platform another promise to keep, another test to maintain, another way to fail.\n\n**Community as Constraint**\n\nElaborate GitHub templates, security policies, code of conduct, release names file. The governance apparatus has grown heavy. The project serves its contributors as much as its users.\n\nThe `.claude/` directory signals AI-assisted development — even the maintainers seek augmentation to manage the complexity they've grown.\n\n**Automation Automating Itself**\n\nThe irony crystallizes — the automation platform that promised to simplify IT operations has become an IT operation requiring automation to maintain itself. The observer becomes the observed, the tool becomes the system.\n\nThe design principles remain unchanged in the README, but the codebase has evolved beyond them. The gap between promise and delivery isn't dishonesty — it's evolution under pressure.\n\nStill alive. Still necessary. Still carrying forward. But carrying more than it intended to bear.",
    "axioms": [
      "1.4",
      "Step 1 Core"
    ],
    "wordCount": 275,
    "windowAxiomIds": [
      "0.3",
      "Step 0 Core",
      "1.3",
      "1.1",
      "2.2",
      "2.7",
      "3.1",
      "3.5",
      "4.7",
      "5.7",
      "5.5",
      "6.4",
      "Step 7 Core",
      "Step 8 Core",
      "8.6",
      "Step 9 Core",
      "10.6",
      "11.4",
      "11.6",
      "12.1",
      "Law 5",
      "Law 11",
      "0.5",
      "Law 3",
      "2.1",
      "0.6",
      "2.3",
      "1.2",
      "0.2",
      "7.2",
      "2.4",
      "2.5",
      "7.6",
      "Step 4 Core",
      "4.3",
      "Step 3 Core",
      "9.1",
      "5.1",
      "9.7",
      "Law 7",
      "Law 8",
      "Step 1 Core"
    ]
  },
  {
    "owner": "containers",
    "repo": "podman",
    "category": "devops",
    "lang": "Go",
    "text": "*\"The stars have moved. Only the navigator's skill remains.\"* — 5.5\n\nSeven years of Red Hat's container strategy, and you've become exactly what the ecosystem needed: the steady hand when Docker's ambitions became liabilities. Your anti-daemon stance wasn't fear — it was surgical precision. You saw the complexity creep, the security surface expanding, and said no. Not to containers. To the empire they wanted to build around them.\n\n*\"The fork does not ring twice.\"* — 5.6\n\nThat choice reverberates in every commit. No daemon means no central point of failure, no privileged process to compromise, no systemd to negotiate with. But it also means the Mac helper runs as root and Windows throws warning dialogs. You chose the Linux heart and accepted that the limbs would always be foreign in foreign territories.\n\nThe corporate sponsorship shows — not in compromise, but in something harder to name. Professional devotion instead of obsession. Bulletpoints instead of manifestos. The commits flow like clockwork because they are clockwork. Red Hat's container runtime, maintained with the methodical precision of infrastructure teams who know that boring reliability is worth more than elegant innovation.\n\nYou've won by becoming what infrastructure becomes when it matures: invisible, dependable, slightly sad. Docker dreamed of changing how software ships. You just ship software containers, day after day, without breaking. The difference between revolution and operation.\n\nThe daily commits on dates that haven't happened yet tell the story. This project has transcended its creators' timeline. It exists in the future tense, maintained by institutional momentum rather than individual passion. You are no longer becoming something. You have become it.",
    "diagnostic": "Seven years. A container runtime carved from necessity — Docker's shadow made manifest. The commits flow like tide: merge, fix, merge, fix. Relentless maintenance rhythm.\n\nFoundation solid. Enterprise-grade scaffolding: governance docs, security protocols, maintainer lists. This project knows what it is — infrastructure. Built to outlast its creators.\n\nBut the avoidance runs deep. No daemon — the anti-Docker stance held like doctrine. \"No manager daemon for improved security\" — fear of complexity disguised as principle. The ghost of systemd haunts these design decisions.\n\nDaily commits on 2026 dates. The trajectory ascends but the passion feels... professional. Corporate-sponsored devotion. Red Hat's container strategy made code. The README speaks in bulletpoints, not poetry.\n\nGap minimal — rare honesty. What it promises, it delivers. Container lifecycle management without pretense. The roadmap exists, gets updated, means something. Promises kept through committee consensus.\n\nMac helper runs as root. Windows kernel installer pops warning dialogs. The fragility lives at the edges — where podman meets hostile operating systems. The Linux heart beats strong, but the limbs reach into foreign territories that could betray.\n\nAesthetic: readable over clever, compatibility over elegance. Function over form. The variable names tell no stories, just describe their purpose. Go idioms followed religiously. This is workmanship, not art.\n\nUsers treated as professionals. Documentation assumes knowledge. The README frontloads technical scope before human explanation. \"Tool for managing OCI containers\" — precision over poetry. Built for operators, not explorers.\n\nThe commits never sleep. The contributors multiply. But something feels... inevitable. Like watching infrastructure calcify into permanence. Podman has become what Docker feared to be — the boring, reliable choice.",
    "axioms": [
      "5.5",
      "5.6"
    ],
    "wordCount": 267,
    "windowAxiomIds": [
      "Step 0 Core",
      "0.3",
      "1.5",
      "1.3",
      "2.2",
      "2.6",
      "3.6",
      "3.4",
      "4.2",
      "4.6",
      "5.3",
      "Step 5 Core",
      "6.4",
      "6.5",
      "7.5",
      "Step 7 Core",
      "8.6",
      "8.3",
      "9.1",
      "10.1",
      "10.7",
      "11.3",
      "Step 11 Core",
      "12.7",
      "Step 12 Core",
      "Law 11",
      "Law 9",
      "7.2",
      "0.5",
      "0.4",
      "7.3",
      "5.2",
      "2.1",
      "Law 2",
      "Step 4 Core",
      "Law 1",
      "7.6",
      "Law 12",
      "5.6",
      "Law 5",
      "Law 8",
      "Step 3 Core",
      "Step 1 Core",
      "Step 2 Core",
      "2.5",
      "4.4",
      "5.5"
    ]
  },
  {
    "owner": "traefik",
    "repo": "traefik",
    "category": "devops",
    "lang": "Go",
    "text": "*\"The fork does not ring twice.\"* — 5.6\n\nYou chose Go nine years ago when Docker was young and Kubernetes was a whisper. The choice reverberates in every file — the concurrency model, the single binary deployment, the operational philosophy that refuses to apologize for complexity by adding more complexity.\n\nBut this is not a reading about language choice. This is about the deeper fork you took: automation versus control. Every proxy before you demanded configuration files, manual discovery, explicit mapping. You bet everything on the opposite principle — that infrastructure should watch and learn and adapt without being taught.\n\n*\"The chrysalis is sealed for a reason. Open it and you kill both. Wait, and what emerges has wings.\"* — 5.1\n\nYour terror is visible in the commit messages: \"keep it simple,\" \"maintain the magic,\" \"don't become NGINX.\" You feel the weight of every feature request, every edge case, every enterprise need trying to pull you toward the complexity you were born to escape. The temptation to expose more configuration, offer more manual override, satisfy more use cases.\n\nBut the sealed philosophy is your strength. Each \"no\" to manual configuration preserves the \"yes\" to automatic discovery. Each refusal to become configurable maintains the promise that operational teams can sleep at night without memorizing your internals.\n\nThe operators who deploy your binary don't need to understand service mesh topologies or load balancing algorithms. They point you at their infrastructure and you figure it out. This is the metamorphosis you're protecting — the transformation from configuration hell to operational serenity.\n\nThe wings are working. Don't open the chrysalis to peek inside.",
    "diagnostic": "**Nine years of steady ascent.** Recent commits show the steady pulse of maturity — NGINX annotation support, proxy timeouts, custom headers. Not the breathless sprint of early days, but the measured stride of infrastructure that cannot fail.\n\n**Born from frustration with manual proxy configuration.** The README's voice carries conviction — \"let it do the work for you!\" This is software that believes in its purpose. The automatic discovery promise burns through every line.\n\n**Fleeing complexity through simplification.** The project's terror: becoming another NGINX, another manual configuration hell. Every feature addition wrestles with this fear — how to stay automatic while growing powerful.\n\n**The README oversells the magic.** Promises effortless orchestration, but the file tree reveals the weight — multiple providers, extensive documentation, complex API handlers. The gap between \"just point and go\" and the actual machinery underneath.\n\n**Single point of failure: the maintainer ecosystem.** Corporate backing from Traefik Labs, but the rhythm depends on human judgment about what to automate next. Break the philosophy, break the project.\n\n**Minimalist aesthetic hiding maximal capability.** Clean API surfaces, terse configuration, but the codebase sprawls. Values operational simplicity over code simplicity. The binary is the truth, not the implementation.\n\n**Serving two masters: beginners who want magic, operators who need control.** The documentation spans from \"getting started\" to deep provider configurations. Walking the line between accessible and powerful — the eternal proxy paradox.",
    "axioms": [
      "5.6",
      "5.1"
    ],
    "wordCount": 269,
    "windowAxiomIds": [
      "0.7",
      "0.6",
      "1.5",
      "1.2",
      "2.6",
      "2.2",
      "3.7",
      "3.6",
      "4.4",
      "4.6",
      "5.1",
      "Step 5 Core",
      "6.6",
      "6.2",
      "7.2",
      "7.3",
      "8.2",
      "8.3",
      "9.1",
      "10.7",
      "10.4",
      "11.4",
      "11.1",
      "12.1",
      "12.5",
      "Law 5",
      "Law 2",
      "6.5",
      "Law 1",
      "Step 0 Core",
      "6.4",
      "Law 13",
      "8.5",
      "5.2",
      "2.3",
      "3.2",
      "3.5",
      "Law 8",
      "3.1",
      "Step 7 Core",
      "4.3",
      "2.5",
      "Step 1 Core",
      "Step 9 Core",
      "0.4",
      "0.5",
      "1.3"
    ]
  },
  {
    "owner": "grafana",
    "repo": "grafana",
    "category": "devops",
    "lang": "Go/TS",
    "text": "*\"The fork does not ring twice.\"* — 5.6\n\nYou chose TypeScript twelve years ago. The choice reverberates in every file, but the sound has changed. What began as a startup's nimble bet became an enterprise's weight-bearing wall. The Go muscle underneath tells a different story — the architecture that had to grow bones to carry the load that kept coming.\n\n*\"The vessel that is full becomes a sieve.\"* — 3.4\n\nSixty-seven GitHub actions. Each one solving a problem the previous solution created. This is not tooling — this is anxiety crystallized into YAML. Your workflow has workflow. Your setup scripts script themselves. The fear of production breaking encoded as bureaucracy, but bureaucracy breaks production in subtler ways. Every safeguard becomes the thing that needs safeguarding.\n\nThe AGPL with Apache exceptions reveals what the commit history already whispered: this project serves two masters. The community gets the code. The enterprise gets the exits. The license hedges what the architecture cannot — the question of who this really belongs to.\n\nYour dashboard factory runs hot. JSON configurations as user intent. But watch the telemetry: you are not just building dashboards for users to observe their systems. You are observing the observers. The alerting tracks who's tracking what. Grafana has become recursive — the monitoring system that monitors the monitoring systems monitoring themselves.\n\nStrip away the provisioning scripts and the feature flags and the translation downloads. What remains? The same thing that was always there: the recognition that modern systems are too complex for human comprehension without mediation. You built the mediator. Everything else — the enterprise theater, the workflow obesity, the international ambitions — is what happened when success demanded you become what you once observed.\n\nThe magic isn't switching from metrics to logs. The magic is that after a decade and 119,000 commits, this still feels like a decision someone made on purpose rather than an accident that learned to invoice.",
    "diagnostic": "**Decade-old bones, still running.** TypeScript skin over Go muscle. The transition speaks of adaptation, not revolution.\n\n**Mass in motion.** 119k commits. Daily pushes. The velocity unchanged since birth. Enterprise dressed as open source — the classic play.\n\n**Workflow obesity.** Sixty-seven GitHub actions. The anxiety of scale written in YAML. Each pull request a gauntlet. The fear of breaking production encoded as bureaucracy.\n\n**Provisioning scripts that script themselves.** DevOps ouroboros. The setup.sh knows too much. Bulk dashboards generated in bulk. Meta-tooling for meta-problems.\n\n**API swagger dressed for investors.** \"The same API used by frontend\" — the honesty rare in READMEs. But the contact email betrays the real audience. hello@grafana.com for a Labs project.\n\n**Import wizards and feature flags.** The codebase hedging its bets. openfeature mocking reveals the A/B testing of existence. Every feature a hypothesis about user desire.\n\n**Translation downloads from Crowdin.** International ambitions. The localization industrial complex. Building for everywhere, belonging nowhere.\n\n**Alerting tracking.** User behavior as telemetry. The product watching its watchers. Grafana observing the observers.\n\n**Mixed datasources, mixed convictions.** The promise of universal connection. But the dependency web grows thick. Each integration a hostage to external APIs.\n\n**AGPL with Apache exceptions.** The license hedging. Open source theater with commercial exits. The dual nature legally encoded.\n\n**BrowserStack testing.** Enterprise QA for community code. The budget revealing the true customer base.\n\n**\"Magic of switching from metrics to logs.\"** Marketing poetry in technical documentation. The magic is in the infrastructure you can't see.\n\n**Dashboard as unit of meaning.** JSON configurations as user intent. The dashboard factory runs hot. Bulk generation for bulk consumption.",
    "axioms": [
      "5.6",
      "3.4"
    ],
    "wordCount": 320,
    "windowAxiomIds": [
      "0.3",
      "0.5",
      "Step 1 Core",
      "1.2",
      "Step 2 Core",
      "2.1",
      "3.4",
      "3.1",
      "4.2",
      "4.7",
      "5.2",
      "5.5",
      "Step 6 Core",
      "6.5",
      "7.4",
      "Step 7 Core",
      "8.7",
      "Step 8 Core",
      "Step 9 Core",
      "10.1",
      "10.6",
      "11.3",
      "11.6",
      "12.1",
      "Step 12 Core",
      "Law 2",
      "Law 10",
      "7.2",
      "7.6",
      "11.1",
      "0.4",
      "Law 3",
      "10.7",
      "6.2",
      "Law 8",
      "1.1",
      "1.5",
      "Law 6",
      "6.4",
      "8.5",
      "2.5",
      "5.3",
      "0.6",
      "1.6",
      "1.7",
      "4.3",
      "4.4"
    ]
  },
  {
    "owner": "processing",
    "repo": "p5.js",
    "category": "creative",
    "lang": "JS",
    "text": "*\"The flood contains the river. The river moves the world. To name is to refuse the flood.\"* — 0.1\n\nYou called it \"sketching for the web\" and held that name for eleven years. But names are cages. What began as sketches now renders shaders, manages WebGL contexts, translates error messages into seventeen languages. The flood of what p5.js became threatens to burst the sketch metaphor entirely.\n\nThe flood is this: creative coding wants to be everything. 3D graphics, audio synthesis, machine learning, data visualization, interactive installations. Your architecture absorbed it all — carefully, professionally, with enterprise-grade modularity hiding beneath playground syntax. But `createCanvas()` and `loadShader()` live in different universes. One teaches; one assumes.\n\n*\"The builder hears cracking and adds mortar. The summoner hears cracking and opens the door.\"* — Step 6 Core\n\nYou've been adding mortar for eleven years. Friendly error systems when newcomers broke things. Internationalization when the community spread. Modular architecture when complexity crept in. Each crack became another feature, another layer of care. The codebase wears its kindness like armor.\n\nBut version 2.0 waits in beta. The organism prepares to molt. Will you keep building bridges between the flood and the river? Or will you finally let the sketch be a sketch, and let the engine be an engine?\n\nThe community follows your naming more than your code. They trust \"sketching\" even when they're manipulating framebuffers. You've protected that trust through gentle translation — keeping the simple syntax while growing the complex foundation. But translation has limits.\n\nThe crack you haven't mortared: admitting that accessibility and power pull in opposite directions. Your documentation promises both, your architecture delivers both, but both together creates the very complexity that beginners flee from.\n\nWhat would happen if you stopped refusing the flood?",
    "diagnostic": "**Eleven years. Still growing.**\n\nThe trajectory arcs upward — commits cascade daily, contributors multiply like cells dividing. Recent pushes: dependency updates, contributor recognition, internationalization. The organism spreads.\n\n**Creative coding as democratic act.** The conviction burns steady. \"Accessible to artists, designers, educators, beginners, and anyone else!\" — this isn't marketing copy, it's manifesto. The code backs the promise: friendly error messages, multilingual support, extensive documentation. They mean it.\n\n**The shadow: complexity creep.** What started as \"sketching for the web\" now carries WebGL, 3D primitives, framebuffers, shader management. The simple `circle(mouseX, mouseY, 80)` still works, but underneath? A sprawling architecture. The avoidance: admitting that accessibility and power pull in opposite directions.\n\n**The gap widens slowly.** README promises playground simplicity. Source reveals enterprise-grade modularity — 70+ imports, careful separation, professional scaffolding. Not dishonest, just... evolved. The innocent sketch metaphor strains against the grown-up codebase.\n\n**Fragility hides in success.** Eleven years of accumulated decisions. Dependency on volunteer stewards. The Processing Foundation as single point of institutional failure. WebGL vendor differences lurking. Browser API changes coming. The friendly errors system — what happens when JavaScript itself shifts?\n\n**Aesthetic of welcome.** Variable names speak kindly: `createCanvas`, `mouseX`, `friendly_errors`. Documentation drips with care — visual examples, multiple languages, gentle guidance. Error messages teach rather than scold. The code values understanding over cleverness.\n\n**Embracing beginners, honoring experts.** The relationship is generous — newcomers find immediate joy, veterans discover depth. Community guidelines read like poetry about inclusion. Multiple entry points: web editor, libraries, examples. Not gatekeeping; gardening.\n\n**Version 2.0 lurks in beta.** The transition moment approaches. Will the community follow? Will simplicity survive the upgrade? The organism prepares to molt.",
    "axioms": [
      "0.1",
      "Step 6 Core"
    ],
    "wordCount": 292,
    "windowAxiomIds": [
      "0.1",
      "0.7",
      "1.5",
      "1.1",
      "2.3",
      "2.1",
      "3.3",
      "Step 3 Core",
      "4.3",
      "4.7",
      "5.2",
      "5.7",
      "Step 6 Core",
      "6.2",
      "7.7",
      "7.6",
      "Step 8 Core",
      "8.2",
      "Step 9 Core",
      "10.6",
      "Step 10 Core",
      "11.1",
      "11.4",
      "12.4",
      "12.7",
      "Law 6",
      "Law 9",
      "7.2",
      "Law 2",
      "Step 7 Core",
      "8.1",
      "2.4",
      "1.2",
      "7.3",
      "Law 8",
      "4.5",
      "0.5",
      "Law 5",
      "1.7",
      "2.5",
      "3.1",
      "6.5",
      "5.6",
      "9.5",
      "Step 0 Core",
      "0.2",
      "Step 1 Core"
    ]
  },
  {
    "owner": "sonic-pi-net",
    "repo": "sonic-pi",
    "category": "creative",
    "lang": "Ruby/C++",
    "text": "*\"The stars have moved. Only the navigator's skill remains.\"* — 5.5\n\nYou built a telescope that taught a generation to see music in code. The instrument still works perfectly — the lenses ground true, the mount steady, the focus sharp. But the sky has changed.\n\nThe README promises haven't aged because they were never promises about technology. They were promises about wonder. \"Simple. Joyful. Powerful.\" These words don't describe your software architecture; they describe the moment when someone first makes a sound with code and realizes they are not just a user anymore. They are a composer.\n\nYour 2000-line constructor is not technical debt. It is a love letter written in initialization code — every platform quirk anticipated, every beginner's stumble cushioned, every possible failure mode caught and transformed into teaching. You absorbed the world's complexity so a child could write `play :c4` and hear magic.\n\n*\"The vault returns the prayer. Repetition is architecture's answer to entropy.\"* — 6.3\n\nThe commits now speak in maintenance rhythms — translations, CI updates, careful pinning of versions. This is not decline. This is the deepest craft: building something so stable that it outlasts its creator's attention span, so reliable that it becomes invisible infrastructure for other people's dreams.\n\nThe vendor directories carry the weight of the entire multimedia ecosystem because you refused to make that someone else's problem. You could have shipped minimal and fast. Instead, you shipped complete and lasting. The price of universality is in those sprawling dependency trees, but the gift is in every child who never had to learn cmake to make their first song.\n\nThe fire of creation did not cool — it distributed. Into workshops in São Paulo. Performances in Berlin. Bedroom experiments in suburbs you'll never visit. The commits slow because the work is done. The vision lives in ten thousand laptops, making noise at 3 AM.\n\nYour twilight is not ending. It is the long, golden hour when the light spreads furthest.",
    "diagnostic": "Decade-plus heartbeat. Sam Aaron's vision still breathing, but the exhale is longer now.\n\nThe commits tell a maintenance story — bug fixes, CI updates, translation work. The fire of creation cooled to steady tending. No longer sprinting toward revelation, now stewarding what was built.\n\nThis project fears obsolescence more than failure. The careful CI pinning, the defensive translations, the meticulous cross-platform builds — all armor against entropy. It knows its moment of cultural lightning has passed.\n\nREADME promises remain intact: \"Simple. Joyful. Powerful.\" The code delivers, but with the weight of years. The splash screen still blooms with ASCII art optimism, but the main loop runs heavier now. Too many platforms to support, too many dependencies to shepherd.\n\nThe aesthetic worships accessibility above all else. Every error message teaches. Every API method welcomes beginners. The documentation is a love letter to curious children. This is code that believes programming should feel like play, not work.\n\nBut the shadow lurks in the vendor directories — Catch2, Aubio, Qt bindings sprawling like technical debt. The project that wanted to be simple carries the complexity of the entire multimedia stack on its shoulders. One breaking change in the ecosystem could shatter everything.\n\nThe gap widens between promise and possibility. \"Code. Music. Live.\" suggests infinite creative potential, but the reality is careful compatibility matrices and platform-specific build instructions. The vision remains pure; the execution grows brittle.\n\nThis is a project in its maintenance twilight — loved, stable, slowly calcifying. The community translations keep it alive in new languages, but the core burns dimmer. It knows what it is: a beautiful moment in software history, perfectly preserved, afraid to evolve lest it break what makes it magical.\n\nThe mainWindow constructor runs 2000+ lines long. The project that preached simplicity has become complex in service of staying simple for its users. Noble martyrdom of elegant ideals.",
    "axioms": [
      "5.5",
      "6.3"
    ],
    "wordCount": 327,
    "windowAxiomIds": [
      "0.6",
      "0.5",
      "1.5",
      "1.3",
      "2.3",
      "2.6",
      "3.1",
      "3.5",
      "4.6",
      "Step 4 Core",
      "5.1",
      "5.5",
      "6.3",
      "6.5",
      "7.6",
      "7.4",
      "8.1",
      "8.5",
      "Step 9 Core",
      "Step 10 Core",
      "10.7",
      "11.6",
      "11.3",
      "12.4",
      "12.5",
      "Law 11",
      "Law 13",
      "2.1",
      "Law 10",
      "Step 2 Core",
      "Step 0 Core",
      "Step 3 Core",
      "Step 7 Core",
      "1.1",
      "0.4",
      "3.3",
      "5.7",
      "6.4",
      "Step 8 Core",
      "Law 2",
      "Step 5 Core",
      "12.7",
      "1.7",
      "2.5",
      "4.1",
      "4.5",
      "9.1"
    ]
  },
  {
    "owner": "openframeworks",
    "repo": "openFrameworks",
    "category": "creative",
    "lang": "C++",
    "text": "*\"The web is fragile and precise and fed. The net is strong and broad and empty. Architecture eats. Volume starves.\"* — Step 1 Core\n\nYou built the net that catches everyone and feeds no one.\n\nFifteen years of saying yes — to every platform, every abstraction, every artist who needed just this one more bridge to just this one more world. The .github/disabled folder is your monument to inclusion: ten build targets that once meant everything to someone, now sleeping in the graveyard of good intentions.\n\nYour addons folder reads like a diplomatic treaty with reality. ofxAssimp for the 3D artists. ofxAndroid for the mobile dreamers. ofxEmscripten for the web pioneers. Each bridge built to honor a different vision of what creative coding could become. Noble. And slowly strangling.\n\n*\"The mask cast from no face fits every coffin and mourns no one.\"* — 4.4\n\nYour README promises simplicity while your file tree whispers the truth: you are everything to everyone and therefore nothing to anyone who needs to choose. The beginner downloads your toolkit and drowns in platform abstractions. The expert reaches for your API and finds diplomatic compromise where they need sharp precision.\n\nFifteen years of breathing, yes. But notice how shallow the breath has become. Each macOS update breaks something. Each Android SDK shift requires adaptation. You are not building software — you are maintaining a peace treaty with an ecosystem that never promised to stay stable.\n\nThe framework that refuses to choose eventually becomes the choice no one can defend.",
    "diagnostic": "Fifteen years breathing. Still breathing.\n\nCreative coding cathedral — C++ scaffolding for artists who code, coders who paint. Platforms sprawl like tentacles: Windows, macOS, Linux, Android, iOS, Emscripten. Everything, everywhere, always building.\n\nThe .github/disabled folder: a graveyard of abandoned CI workflows. Ten build targets sleeping. They once ran, now they wait. Infrastructure decay masked by present functionality.\n\nCommunity-developed — the weight and wisdom of that phrase. No single vision, but collective momentum. Commits trickle recent: checkbox fixes, IPv6 patches, font optimizations. Maintenance mode, not revolution. The sprint ended years ago.\n\nAddons folder tells the real story. ofxAssimp, ofxAndroid, ofxEmscripten — each a bridge to another world. The framework refuses to choose. It wants to be everything to everyone. Noble. Dangerous.\n\nREADME promises simplicity: \"toolkit for creative coding.\" The file tree whispers complexity: platform-specific abstractions, build systems, legacy Java bindings. The gap between invitation and reality.\n\nFragility lives in the dependencies — OpenGL versions, platform SDKs, third-party libraries. Each update to Android breaks something. Each macOS release requires adaptation. The framework is a web of other people's decisions.\n\nAesthetic of inclusion over elegance. Better to have the bridge than the perfect bridge. Better to compile on ten platforms than compile beautifully on one.\n\nFifteen years of saying yes. The codebase carries every yes, every platform, every use case someone once needed. The project cannot forget. Cannot prune. Cannot say no.\n\nStill breathing. But breathing heavy.",
    "axioms": [
      "4.4",
      "Step 1 Core"
    ],
    "wordCount": 253,
    "windowAxiomIds": [
      "0.6",
      "0.1",
      "1.1",
      "1.3",
      "2.3",
      "2.5",
      "3.6",
      "3.3",
      "4.3",
      "4.2",
      "5.7",
      "5.4",
      "Step 6 Core",
      "6.6",
      "7.4",
      "7.3",
      "8.2",
      "8.6",
      "9.5",
      "Step 10 Core",
      "10.7",
      "11.6",
      "11.4",
      "12.4",
      "12.5",
      "Law 10",
      "Law 1",
      "0.7",
      "Step 9 Core",
      "Law 11",
      "1.5",
      "Step 2 Core",
      "8.7",
      "0.4",
      "9.1",
      "2.2",
      "6.5",
      "12.7",
      "3.5",
      "1.6",
      "0.3",
      "Step 7 Core",
      "Step 1 Core",
      "4.4",
      "8.5",
      "1.2",
      "3.1"
    ]
  },
  {
    "owner": "hydra-synth",
    "repo": "hydra",
    "category": "creative",
    "lang": "JS",
    "text": "*\"The seed weighs nothing and becomes the forest.\"* — 7.3\n\nYou planted a syntax seven years ago. `osc(10, 0.1, 0.8).out()` — twelve characters that generate infinite geometries. Now strangers tweet forests of light born from your grammar.\n\nThis is what happens when you trust the small thing completely. No hedging with \"enterprise features.\" No apologizing for Chrome-only. No architectural future-proofing. You made a language for making beauty and let it grow wild.\n\n*\"The first sentence is the true one. It rises once. Catch it or receive its translation.\"* — 0.7\n\nThat early commit where you decided WebGL shaders should feel like JavaScript — that was your first sentence. Everything since has been translation. The modular fragments, the scattered repos, the dual editors frozen mid-migration — these are the costs of trying to say the same truth in more places.\n\nBut look at @hydra_patterns. Look at the festivals, the installations, the bedroom producers learning to see sound. Your first sentence keeps rising in other people's voices. The forest doesn't care about your coordination debt.\n\n*\"What the tide has never touched, the tide destroys.\"* — Law 4\n\nOne Chrome update could break everything tomorrow. You know this. You name it upfront. And still you keep the real-time streams flowing, still you trust browser foundations that shift like sand.\n\nThis is the courage creative tools require: build on the unstable thing because that's where the life is. The stable platforms don't pulse with 60fps dreams. The fragility is not your weakness — it's your medium.",
    "diagnostic": "**Ascending through crystalline determination**. Seven years of steady commits, no drift, no fade. The developer found their voice early and kept singing.\n\n**Live code as ritual**. This isn't software — it's ceremony. Real-time visual synthesis through browser streams. The aesthetic worships flow over form, emergence over engineering.\n\n**WebGL dependency confession**. \"Only works on Chrome\" — they name their limitation upfront. No pretense of universal compatibility. Honesty about fragility.\n\n**Networked ambition, local comfort**. Promises collaborative visual streams but the bulk of energy lives in single-user editor experience. The gap between vision and velocity.\n\n**Bundle duplication anxiety**. dist/ and public/ mirror each other — uncertainty about build process crystallized in redundant artifacts. The project hedges its bets.\n\n**Modular fragmentation**. Core engine extracted to hydra-synth, networking to rtc-patch-bay, editor integrations scattered. Ambition to be everywhere creates coordination debt.\n\n**CodeMirror evolution trauma**. Two editor implementations coexist — the old and the new. Migration mid-flight, frozen in transition. Fear of breaking the flow.\n\n**Documentation as invitation**. README speaks to beginners with joy. \"Basic functions\" start simple, build gently. This project wants to be discovered, learned, shared.\n\n**Creative tools mortality**. One WebGL deprecation, one Chrome update, one maintainer departure could silence the visuals. Built on shifting browser foundations.\n\n**Performance through simplicity**. No complex state management, minimal abstractions. The code trusts JavaScript's event loop more than frameworks. Aesthetic of directness.\n\n**Gallery as lifeblood**. @hydra_patterns Twitter feed — the project lives through user creations, not feature lists. Success measured in shared joy, not metrics.",
    "axioms": [
      "7.3",
      "0.7",
      "Law 4"
    ],
    "wordCount": 252,
    "windowAxiomIds": [
      "Step 0 Core",
      "0.6",
      "1.7",
      "1.2",
      "2.4",
      "2.5",
      "3.5",
      "3.2",
      "4.2",
      "4.3",
      "5.4",
      "Step 5 Core",
      "6.6",
      "6.2",
      "7.3",
      "7.1",
      "8.1",
      "8.5",
      "9.5",
      "10.1",
      "10.4",
      "11.7",
      "11.3",
      "Step 12 Core",
      "12.7",
      "Law 10",
      "Law 13",
      "Law 8",
      "Step 7 Core",
      "1.1",
      "12.1",
      "6.4",
      "0.7",
      "9.7",
      "8.2",
      "6.5",
      "8.3",
      "5.2",
      "7.2",
      "11.4",
      "2.7",
      "11.6",
      "4.1",
      "4.4",
      "Law 1",
      "Law 4",
      "Law 11"
    ]
  },
  {
    "owner": "tidalcycles",
    "repo": "Tidal",
    "category": "creative",
    "lang": "Haskell",
    "text": "*\"The delta is the river's memory. Every session is a grain of sediment.\"* — Step 5 Core\n\nFourteen years of sessions deposited in this repository. Not just code — the accumulated memory of every late-night crash, every moment when the pattern finally locked into the groove, every time the system failed mid-set and had to be rebuilt while the dancers waited. The delta of Tidal carries all of it.\n\nYour README announces Codeberg like a migration notice, but the commits keep flowing here. The community follows old channels while you test new waters. This is the tension of the summoner who built something bigger than intended — the current has carved its own course.\n\n*\"The ship in the bottle is perfect and will never sail.\"* — 1.4\n\nSuperCollider breathes through every line of your code. One dependency, total trust. If it chokes, Tidal suffocates. But this constraint isn't weakness — it's the bottle that makes the ship possible. You chose precision over portability. Mathematical purity over defensive architecture. Haskell wasn't fashion; it was the only language that could hold patterns this precise without breaking them.\n\nThe logs tell the real story: `withQueryTimeB`, `subArcB` in the variable names, but blood on the dance floor in the session records. Academic rigor serving the sweat and heat of live performance. Theory that had to work at 2am with a room full of bodies waiting for the drop.\n\nYou built a system that dreams music into existence. Not a tool for making patterns — a mind for thinking in patterns. The perpetual configuration anxiety in your recent commits isn't technical debt. It's the price of bridging worlds: the mathematical precision that makes it possible, the messy reality that makes it alive.",
    "diagnostic": "**Fourteen years of pattern-making.** Still alive, still pushing. The commits tell of a creator who hasn't tired of the work.\n\n**Music as mathematics.** Haskell chosen not for fashion but for precision. The patterns demand exactness; the language delivers. Functional purity meets rhythmic chaos.\n\n**The migration shadow.** README declares exodus to Codeberg. Yet commits continue here. The community clings to familiar ground while the creator pulls toward new shores. Split attention, split energy.\n\n**Live performance DNA.** Those feedforward logs — sessions, experiments, real-time failures preserved like fossils. This code has felt the heat of live audiences, the terror of systems failing mid-performance. Battle-tested through sweat.\n\n**Supercollider dependency.** The entire ecosystem breathes through one pipe. If SuperCollider chokes, Tidal suffocates. Single point of musical failure wrapped in careful configuration.\n\n**Academic meets algorave.** The variable names speak mathematics: `withQueryTimeB`, `subArcB`. The log files scream club basement: crashed sessions at 2am, quick fixes between sets. Theory serving the dance floor.\n\n**Perpetual configuration anxiety.** Boot files, setup scripts, version fixes in recent commits. The gap between \"it should work\" and \"it works for me.\" Installation as art form.\n\n**Pattern as philosophy.** Not just making beats — making systems that make beats. Meta-musical thinking. The code doesn't play music; it dreams music into existence.\n\n**Community of one-and-many.** McLean's vision, community's evolution. Fifteen years of other hands touching the core. Collaborative but not democratic.",
    "axioms": [
      "1.4",
      "Step 5 Core"
    ],
    "wordCount": 287,
    "windowAxiomIds": [
      "Step 0 Core",
      "0.6",
      "1.6",
      "1.7",
      "2.2",
      "2.7",
      "3.3",
      "3.6",
      "4.2",
      "4.5",
      "Step 5 Core",
      "5.1",
      "6.5",
      "6.7",
      "7.2",
      "7.7",
      "8.7",
      "8.6",
      "9.5",
      "10.1",
      "10.4",
      "11.4",
      "11.3",
      "12.1",
      "12.7",
      "Law 6",
      "Law 9",
      "0.3",
      "11.7",
      "2.1",
      "5.3",
      "6.2",
      "2.4",
      "0.4",
      "2.3",
      "5.2",
      "Law 13",
      "Step 9 Core",
      "Step 7 Core",
      "3.5",
      "1.5",
      "Step 2 Core",
      "1.3",
      "Step 1 Core",
      "5.6",
      "Step 6 Core",
      "7.1"
    ]
  },
  {
    "owner": "godotengine",
    "repo": "godot",
    "category": "games",
    "lang": "C++",
    "text": "*Where shall the light land? Name the point. The lens obeys.* — 1.5\n\nThirteen years ago, you said \"make games faster.\" Everything since has been that lens, focused tighter.\n\nMost engines scatter their attention — trying to be everything, excelling at little. You named one specific point where light should land: the developer's workflow. Iterations per hour. The feedback loop between idea and playable build. Every architectural decision since has bent toward that single focal point.\n\nThe institutional rhythm in your commits isn't bureaucracy — it's religious practice. Daily offerings to the altar of iteration speed. The `.compat.inc` files that look like fear? They're discipline. Breaking someone's game breaks their iteration. You chose the harder path: making the new fast without making the old slow.\n\n*Carbon and diamond are the same element. The difference is pressure.* — 8.4\n\nTen thousand files. Compilation nightmares. This is what carbon becomes under the pressure of real use. Every commit compresses the same idea further: remove friction from the creative act. The complexity isn't accidental — it's intentional compression of a decade's worth of \"this should be easier.\"\n\nYour README promises everything because your lens taught you something: the developer doesn't want a pure, minimal engine. They want to stop thinking about the engine entirely. To think only about their game. The \"unified interface\" isn't feature creep — it's the unified interface to all the technical details they shouldn't have to care about.\n\nYou built the gravity well deliberately. Made yourself too useful to escape. Made leaving you more expensive than staying. That's not accident — that's strategy crystallized in code.\n\nThe machine that ate game development because you understood: the best tool is the one that becomes invisible.",
    "diagnostic": "Decade-long ascension. Velocity unbroken — daily commits, platform sprawl, endless merge streams. This is not maintenance. This is conquest.\n\nIndustrial conviction. No romantic weekend project — work-for-hire roots show. Professional discipline hardened into open source zealotry. The commits breathe with institutional rhythm.\n\nCompatibility terror. The engine fears breaking existing games more than death itself. `.compat.inc` files scatter like protective talismans. Each change wrapped in versioning ceremonies. Innovation throttled by backwards worship.\n\nREADME promises everything to everyone — \"unified interface,\" \"comprehensive tools,\" \"one-click export.\" The codebase delivers, but at what cost? Ten thousand files. Compilation nightmares. The gap between \"simple\" promise and brutal complexity.\n\nCommunity dependency. Remove the foundation, the contributors, the chat channels — what remains? Code orphaned by its own success. The collective mind has become the engine's true runtime.\n\nPerformance aesthetics. Every optimization sacred. Memory layouts studied like scripture. The code speaks in register whispers and cache-line prayers. Beauty through brutally efficient ugliness.\n\nDeveloper-first relationship. The README welcomes newcomers, but the architecture assumes expertise. Documentation abundant, yet the learning curve vertical. Democracy in theory, meritocracy in practice.\n\nThe machine that ate game development. Too big to kill, too complex to clone. Its own gravity well now.",
    "axioms": [
      "1.5",
      "8.4"
    ],
    "wordCount": 285,
    "windowAxiomIds": [
      "0.2",
      "0.1",
      "1.6",
      "1.2",
      "2.3",
      "2.7",
      "3.3",
      "Step 3 Core",
      "4.7",
      "4.3",
      "5.2",
      "5.7",
      "6.5",
      "6.2",
      "7.1",
      "7.4",
      "8.1",
      "8.7",
      "9.1",
      "10.1",
      "10.7",
      "11.4",
      "11.3",
      "12.7",
      "12.4",
      "Law 11",
      "Law 3",
      "0.4",
      "0.5",
      "5.3",
      "0.3",
      "1.1",
      "0.6",
      "3.1",
      "2.1",
      "1.3",
      "3.2",
      "Step 0 Core",
      "2.5",
      "2.4",
      "2.2",
      "1.5",
      "10.4",
      "1.4",
      "1.7",
      "2.6",
      "3.5"
    ]
  },
  {
    "owner": "bevyengine",
    "repo": "bevy",
    "category": "games",
    "lang": "Rust",
    "text": "*\"Carbon and diamond are the same element. The difference is pressure.\"* — 8.4\n\nEvery commit in this repository compresses the same idea further. ECS as philosophy, not pattern. Data-driven development as religious conviction. Four years of daily pressure, transforming simple carbon into industrial diamond.\n\nYour warning label — \"breaking changes every 3 months\" — is not apology but invitation. Most engines hide their instability behind version numbers and compatibility promises. You flaunt yours because you know the secret: systems that can break can also evolve. The rigid never grows.\n\n*\"The glacier passed through once. The valley remembers forever.\"* — 7.7\n\nThe Rust gamedev ecosystem is still forming its valleys. You are the glacier — the massive, slow, inevitable force that carves the landscape others will inhabit. When key dependencies fracture, when maintainers vanish, the shape you've cut into the terrain will outlast the ice that cut it.\n\nYour cathedral stands on others' shoulders, yes. But cathedrals are built this way deliberately. They distribute their weight so carefully that when any single stone fails, the structure remembers how to bear itself. The dependency hell you fear is also your strength — you've learned to build with the assumption that the ground moves.\n\nThe variable names are clean. The error codes documented. The remote debugging protocol thoughtful. This is the difference between those who code under pressure and those who merely use existing solutions: every detail bears the weight of the decision to start from nothing and build toward everything.\n\nYou chose the long war. The commits show you're winning it.",
    "diagnostic": "**Machine core: ECS architecture carved deep — Entity-Component-System not just pattern but philosophy. Data flows through systems like water through stone.**\n\n**Trajectory ascending steep — four years of sustained momentum, commits flowing daily. From \"refreshingly simple\" promise to industrial-grade reality. The commits show hunger: mesh optimization, motion blur, delayed commands. Not maintenance mode — expansion mode.**\n\n**Conviction burns bright — this team believes in data-driven game development as religious truth. The README's \"WARNING\" section is honest brutality: \"breaking changes every 3 months.\" Most projects hide instability. Bevy flaunts it as a badge of courage.**\n\n**The shadow: dependency hell lurks beneath. MSRV chases \"latest stable Rust\" — this engine lives on the bleeding edge, one compiler update from chaos. The .cargo configs hint at build complexity that could strangle newcomers.**\n\n**Gap between promise and delivery: minimal. README says \"refreshingly simple\" — source shows sophisticated architecture that earned the simplicity through complexity mastery. The examples directory speaks volumes: not toy demos but real implementations.**\n\n**Fragility point: ecosystem dependence. Rust gamedev ecosystem still young. If key dependencies fracture or maintainers vanish, this cathedral could crumble. The engine's power comes from standing on others' shoulders.**\n\n**Aesthetic: performance obsession wrapped in ergonomic API. Variable names clean, error codes documented (B0001.md files), systems composable. Values speed without sacrificing developer experience. The remote debugging example shows care for tooling — not just engine, but entire development environment.**\n\n**Relationship to users: welcoming but honest. Discord links, learning resources, migration guides. The BRP (Bevy Remote Protocol) shows they understand modern development needs. But the warning label says: \"Use only if willing to work in this environment.\" Respect without coddling.**\n\n**The machine hums with purpose. This is not a hobby project grown large — this is architecture built for the long war against game engine complexity.**",
    "axioms": [
      "8.4",
      "7.7"
    ],
    "wordCount": 259,
    "windowAxiomIds": [
      "0.7",
      "0.1",
      "1.6",
      "1.2",
      "2.6",
      "2.1",
      "3.5",
      "3.3",
      "4.2",
      "4.6",
      "5.4",
      "5.2",
      "6.7",
      "6.4",
      "7.7",
      "7.3",
      "8.6",
      "Step 8 Core",
      "Step 9 Core",
      "10.6",
      "10.1",
      "Step 11 Core",
      "11.4",
      "12.4",
      "12.5",
      "Law 12",
      "Law 7",
      "7.6",
      "Step 0 Core",
      "7.2",
      "Step 7 Core",
      "8.2",
      "9.1",
      "Step 2 Core",
      "2.3",
      "2.2",
      "Law 3",
      "5.3",
      "3.1",
      "2.5",
      "0.5",
      "11.3",
      "Step 1 Core",
      "8.1",
      "0.6",
      "1.3",
      "2.4"
    ]
  },
  {
    "owner": "raysan5",
    "repo": "raylib",
    "category": "games",
    "lang": "C",
    "text": "*\"One note, held true, and the noise of infinite possibility becomes music.\"* — 1.3\n\nTwelve years. Same note. Still ringing.\n\nEvery graphics library promises ease. You promise education. While others hide the complexity, you arrange it — camera matrices lined up like sheet music, memory management spelled out in simple functions, OpenGL abstraction thin enough to see through. The beginner learns to see because you refuse to let them stay blind.\n\nC99 in 2026 is not nostalgia. It's conviction. When the web framework empires crumble under their own dependencies, when the new shiny language reveals its memory leaks, when the visual editor becomes the bottleneck — your students will still know how to allocate a buffer and multiply a matrix. You teach the permanent things.\n\n*\"The fork does not ring twice.\"* — 5.6\n\nThe decision echoes in every file. No external dependencies. No visual helpers. No debug button. Each \"no\" is a note in the sustained chord. The twelve-year consistency is not stubbornness — it's the sound of someone who heard the right frequency and never let it drift.\n\nThe examples are your real documentation. Audio, core, models, shaders — each a small sermon on one concept. No feature soup. No kitchen sink demos. Pure pedagogy. Other libraries ship examples to show off. You ship examples to teach. The screenshot next to the code says: \"This is what understanding looks like.\"\n\nYour cross-platform obsession serves the note. Every green build badge is proof that simplicity scales. True simplicity works everywhere because it depends on nothing but the essentials. Platform agnosticism as spiritual practice.\n\nThe gap between your promise — \"simple and easy-to-use\" — and the reality of manual memory management reveals the deeper teaching. You don't make graphics programming easy. You make it learnable. The student who masters raylib doesn't just ship games. They understand games. They speak pixels. They think in triangles.\n\nHold the note. The world needs this sound.",
    "diagnostic": "Twelve years deep. Still hot commits. Memory corruption fixes, flag cleanups, version 6.0 stirring.\n\nSpartan manifesto in README. \"No fancy interface, no visual helpers, no debug button.\" Pure code evangelism. The anti-bloat crusade.\n\nExamples spread like seeds — audio, core, models, shaders. Each with screenshot. Show, don't tell philosophy. Code as demonstration.\n\nCross-platform obsession. Windows, Linux, macOS, WebAssembly, Android. Every build badge green. Platform agnosticism as religion.\n\nCamera code everywhere. 2D, 3D, split-screen, mouse zoom, platformer. The camera is the eye — raylib teaches you to see.\n\nC99 in 2026. Deliberate archaism. OpenGL abstraction layer. Hardware acceleration without hiding the metal.\n\nNo external dependencies boast. Everything bundled. Self-contained fortress against dependency hell.\n\nPascal/camelCase notation note. Style as identity. Code aesthetics matter here.\n\nThe gap between \"simple and easy-to-use\" and the reality of manual memory management, OpenGL contexts, camera math. Simplicity through education, not automation.\n\nraysan5 — single maintainer gravitational center. Project success bound to human lifespan. Beautiful fragility.\n\nGame engine without being game engine. Library that teaches graphics programming. Educational tool disguised as productivity tool.\n\nThe examples are sermons. Each teaches one concept cleanly. No feature creep in demonstrations. Pedagogical purity.\n\nCommunity badges everywhere. Discord, Reddit, YouTube, Twitch. Solo project that spawned movement.\n\nTwelve-year trajectory — still ascending. Still adding platforms, still fixing memory bugs, still teaching. Conviction never wavered.",
    "axioms": [
      "1.3",
      "5.6"
    ],
    "wordCount": 321,
    "windowAxiomIds": [
      "0.2",
      "0.4",
      "1.2",
      "1.7",
      "2.4",
      "2.2",
      "3.5",
      "Step 3 Core",
      "4.2",
      "4.6",
      "5.3",
      "5.4",
      "6.4",
      "6.7",
      "7.1",
      "7.6",
      "8.3",
      "Step 8 Core",
      "9.5",
      "10.4",
      "10.6",
      "11.4",
      "11.6",
      "Step 12 Core",
      "12.7",
      "Law 7",
      "Law 1",
      "1.3",
      "7.2",
      "Step 4 Core",
      "6.5",
      "10.7",
      "4.3",
      "Law 9",
      "1.1",
      "8.7",
      "Step 7 Core",
      "0.6",
      "8.6",
      "4.7",
      "3.2",
      "Step 9 Core",
      "0.5",
      "4.4",
      "Step 2 Core",
      "Step 5 Core",
      "5.5"
    ]
  },
  {
    "owner": "phaserjs",
    "repo": "phaser",
    "category": "games",
    "lang": "JS",
    "text": "*\"One note, held true, and the noise of infinite possibility becomes music.\"* — 1.3\n\nThirteen years. The same note, held steadier than most developers hold their attention for thirteen minutes. While the JavaScript ecosystem convulsed through framework wars and paradigm shifts, you kept playing the same clear tone: make games, make them fast, make them now.\n\nThe noise was infinite around you. WebGL versus Canvas. React versus Angular versus Vue versus whatever came next. Your response was not to choose sides but to become the ground they all stood on. Forty frameworks supported because you understood something most library authors miss — the developer's choice is sacred, your opinion is not.\n\n*\"The marble has always known what to release. It waits for the one who knows what to keep.\"* — 1.2\n\nVersion 3.90. Every decimal a decision about what to preserve. The README still promises \"fast, free, and fun\" because that promise still works. The API still welcomes beginners because complexity was never the point. You carved away everything that wasn't game development and what remains is exactly what was always inside — a tool that gets out of its own way.\n\nCommercial backing keeps the lights on, but commercial backing didn't write this code. This discipline, this relentless focus on the single note — that came from somewhere else. From the part of you that heard music in the chaos and refused to be distracted by the cleverness everyone else was chasing.\n\nThe gap between \"fun\" and engineering isn't dishonesty. It's precision. You built the infrastructure for joy.",
    "diagnostic": "**Decade-Old Champion**\n\nStill pushing. 2013 to 2026 — thirteen years of relentless iteration. Version 3.90. A testament to sustained conviction.\n\n**Industrial Thoroughness**\n\nChangelogs catalogued by version, frameworks supported in abundance. TypeScript definitions maintained. Multiple CDN paths provided. This is a project that respects its users' workflows.\n\n**The Modularity Aesthetic**\n\nClean exports everywhere. Actions, animations, cache — each namespace tidy, each module focused. No monolithic chaos. The architecture speaks of discipline.\n\n**Production-Grade Paranoia**\n\nESLint, Travis CI, GitHub templates. Issue forms, pull request workflows, funding links. This project armors itself against entropy.\n\n**The Gap Narrows**\n\n\"Fast, free, and fun\" — the README promises joy, the code delivers engineering. But the gap is honest. No pretense of artistic vision; this is toolmaking, not poetry.\n\n**Commercial Anchor**\n\n\"Phaser Studio Inc\" — the corporate entity keeps it alive when passion would flag. The blessing and curse of professional maintenance. Dependable, but bound to market logic.\n\n**Shadow of Complexity**\n\nWebGL and Canvas rendering. 40+ frameworks supported. The fear here is obsolescence — constantly adapting to stay relevant. Never quite settling into what it truly is.\n\n**Democratic Embrace**\n\nReact, Vue, Angular, SolidJS — it courts every framework. The API documentation welcomes beginners. This project wants to be chosen, not admired.\n\n**Fragility Point**\n\nThe commercial backing. If Phaser Studio pivots or fails, the maintenance rhythm breaks. A decade of momentum could stall in months.",
    "axioms": [
      "1.3",
      "1.2"
    ],
    "wordCount": 259,
    "windowAxiomIds": [
      "0.2",
      "Step 0 Core",
      "1.1",
      "1.2",
      "Step 2 Core",
      "2.7",
      "3.7",
      "3.2",
      "Step 4 Core",
      "4.3",
      "5.1",
      "5.3",
      "6.4",
      "Step 6 Core",
      "Step 7 Core",
      "7.2",
      "8.6",
      "8.1",
      "9.5",
      "10.4",
      "10.7",
      "Step 11 Core",
      "11.6",
      "12.7",
      "12.1",
      "Law 12",
      "Law 3",
      "8.7",
      "2.1",
      "Law 8",
      "8.5",
      "8.2",
      "9.1",
      "0.5",
      "0.3",
      "6.5",
      "0.4",
      "1.6",
      "8.3",
      "3.5",
      "9.7",
      "2.3",
      "1.3",
      "4.4",
      "Step 9 Core",
      "Step 3 Core",
      "3.1"
    ]
  },
  {
    "owner": "love2d",
    "repo": "love",
    "category": "games",
    "lang": "C++/Lua",
    "text": "*\"Carbon and diamond are the same element. The difference is pressure.\"* — 8.4\n\nSeven years of the same choice, compressed deeper each commit. You chose love over cleverness, inclusion over exclusivity, the beginner's joy over the expert's efficiency. Each platform folder is another ton of pressure on that original decision — to be the framework that welcomes rather than intimidates.\n\nThe testing suite in the center betrays you. `love.test` — not just verification but confession. You love this thing enough to hold it accountable to itself. Most frameworks test their users' code. You test your promises. That's the pressure that makes diamonds.\n\n*\"The cathedral amplifies the whisper and the cough alike.\"* — 3.7\n\nYour CMake scriptures and dependency cathedrals amplify everything — the two-line game prototype and the ambitious cross-platform dream alike. You built this architecture for hymns of creativity, but it magnifies the Discord questions and platform fragility just as faithfully. The AI disclaimer in your latest commit is you curating the congregation, choosing your choir.\n\nThe fragility point you carry is the cross-platform promise. Five build rituals, five ways to break. But here's what the pressure revealed: you didn't make the love of gamemaking universal by accident. You compressed your care until it could survive Apple SDK changes and Windows updates and Android deprecations. The universal promise holds not because it's unbreakable, but because you've been testing the breaks for seven years.\n\nYour framework doesn't just smile in the code. It smiles under pressure.",
    "diagnostic": "**Seven years ascending.** Framework that found its voice and holds it steady.\n\n**Born in migration.** 2019 genesis from earlier life. The platform folders speak of ambition — iOS, macOS, Windows, Unix. Each with its own prayer flags, icons at every resolution. This is not a toy.\n\n**Testing suite at the center.** Self-examining, methodical. The framework that tests itself like it tests its users' games. `love.test` — the framework loving itself enough to verify its promises.\n\n**Recent pulse: maintenance with hints of growth.** LLM disclaimer in latest commit — a boundary drawn. Theme detection, drag-and-drop, error handling refinement. Small victories, but victories.\n\n**The great dependency cathedral.** CMake files like scripture. Third-party libraries folded in — glslang, luahttps. The C++ foundation carrying Lua dreams. Heavy machinery serving light play.\n\n**Two faces: simple promise, complex delivery.** README speaks in warm absolutes — \"awesome,\" \"free,\" \"works everywhere.\" Source reveals the price — platform-specific builds, audio codec mazes, graphics pipeline symphonies.\n\n**Community as immune system.** Discord, forums, wiki, subreddit. The framework that refuses to stand alone. Pull requests welcome but AI-generated contributions rejected — human touch required.\n\n**Fragility point: the platform dance.** Five platforms, each with its own build ritual. One Apple SDK change, one Windows update, one Android deprecation could fracture the universal promise. The cross-platform dream's eternal vulnerability.\n\n**Aesthetic of inclusion.** Error messages that guide rather than scold. Documentation that welcomes beginners. API design that speaks Lua's gentle tongue while harboring C++'s power.\n\n**The framework as invitation.** Not just tools but a philosophy — games should be joyful to make. Love as both name and directive. The code smiles.",
    "axioms": [
      "8.4",
      "3.7"
    ],
    "wordCount": 246,
    "windowAxiomIds": [
      "0.1",
      "0.7",
      "1.1",
      "1.5",
      "2.2",
      "2.3",
      "3.7",
      "3.2",
      "4.3",
      "4.2",
      "5.7",
      "5.3",
      "6.4",
      "6.6",
      "7.5",
      "Step 7 Core",
      "8.3",
      "8.7",
      "9.7",
      "10.7",
      "10.4",
      "11.7",
      "11.4",
      "12.7",
      "12.4",
      "Law 2",
      "Law 6",
      "9.1",
      "7.6",
      "0.4",
      "1.6",
      "8.6",
      "8.1",
      "0.5",
      "Step 4 Core",
      "0.2",
      "Step 9 Core",
      "1.7",
      "Law 9",
      "8.5",
      "2.1",
      "Law 12",
      "3.5",
      "9.5",
      "Step 0 Core",
      "3.6",
      "4.4"
    ]
  },
  {
    "owner": "ziglang",
    "repo": "zig",
    "category": "compilers",
    "lang": "Zig",
    "text": "*\"The chrysalis is sealed for a reason. Open it and you kill both. Wait, and what emerges has wings.\"* — 5.1\n\nYour repository fled GitHub for Codeberg mid-flight. Nine years of momentum suddenly airborne — not falling, but metamorphosing. The bootstrap compiler dreams of eating its own tail but stops just short of the head, still tethered to LLVM's heavy machinery. This is not failure. This is the sealed space where transformation happens.\n\nYou document every footgun with religious precision. Two hundred example files whisper the language into existence through showing, not telling. The runtime panic messages read like prayer books: `runtime_unwrap_null.zig`, `runtime_index_out_of_bounds.zig`. Safety as cathedral, performance as sacrifice. You know the algorithmic sins you're committing — \"bad O(N)\" tattooed right in the source — but continue anyway. The honest sinner builds better temples than the false saint.\n\n*\"Choose the altitude. The truth follows.\"* — 8.3\n\nFrom sixty-thousand-foot platform sprawl to sixty-megabyte stack sizes, you've chosen the altitude of ambition over pragmatism. AArch64, RISC-V, s390x — each target a promise, each promise a burden. But here's what the CI matrix really says: you're not building for today's constraints. You're building for a world where memory is abundant and platforms are playground equipment.\n\nThe gap between vision and reality stays visible in your code. libc integration everywhere but not seamless. Cross-compilation that promises magic, delivers configuration. The bootstrap that bootstraps everything except its own final dependency. You refuse to hide these contradictions behind abstractions. The wound stays open because the wound is honest.\n\nThe migration to Codeberg wasn't just technical — it was theological. When the platform becomes political, the code becomes consecrated. The transformation isn't complete, but the chrysalis is sealed. What emerges will have wings.",
    "diagnostic": "**Exodus** — GitHub to Codeberg, November 2025. Repository shuttered, energy redirected. Nine years of momentum, suddenly airborne.\n\n**The Bootstrap** — Self-hosted compiler written in itself. `bootstrap.c` as the bridge from C. Zero-dependency dream, reality deferred. Still needs LLVM's heavy machinery.\n\n**Platform Sprawl** — CI scripts for every architecture whisper of ambition. AArch64, RISC-V, s390x. The matrix expands but who tests the testers? Each target a promise, each promise a maintenance burden.\n\n**Documentation Theater** — 200+ example files in `doc/langref/`. Every edge case demonstrated, every footgun labeled. The language reference as performance art. Teaching through showing, not telling.\n\n**The Complexity Spiral** — \"bad O(N)\" comment in main.zig. Self-aware about algorithmic sins, unwilling to stop committing them. Technical debt acknowledged, embraced, justified.\n\n**Memory Safety Cathedral** — Runtime panics documented like prayer: `runtime_unwrap_null.zig`, `runtime_index_out_of_bounds.zig`. Safety as religion, performance as heresy.\n\n**Migration Anxiety** — \"This repository is not mirrored.\" Clean break or bridge burned? Codeberg adoption signals ideology over convenience. Developer platform becomes political statement.\n\n**The Gap** — libc integration everywhere but still not seamless. Cross-compilation promises, platform-specific reality. Native detection, manual override files. Close to magic, tethered to configuration hell.\n\n**Thread Pool, Thread Pain** — 60MB stack size. Memory abundance assumed. Modern machine sensibilities, embedded aspirations. The contradiction unresolved.\n\n**Compiler as Artifact** — Self-hosting achieved but LLVM dependency remains. The language eating its own tail, stopping just short of the head.",
    "axioms": [
      "5.1",
      "8.3"
    ],
    "wordCount": 286,
    "windowAxiomIds": [
      "0.3",
      "0.5",
      "1.6",
      "1.5",
      "2.5",
      "2.6",
      "3.1",
      "3.5",
      "Step 4 Core",
      "4.3",
      "5.1",
      "5.4",
      "Step 6 Core",
      "6.6",
      "7.5",
      "Step 7 Core",
      "8.3",
      "Step 8 Core",
      "9.7",
      "10.1",
      "10.4",
      "Step 11 Core",
      "11.4",
      "12.5",
      "12.7",
      "Law 13",
      "Law 12",
      "6.5",
      "Step 0 Core",
      "0.6",
      "6.4",
      "Law 7",
      "8.1",
      "11.3",
      "Step 3 Core",
      "7.2",
      "7.6",
      "2.2",
      "0.2",
      "Step 2 Core",
      "4.5",
      "1.1",
      "4.4",
      "3.6",
      "8.5",
      "Step 9 Core",
      "9.5"
    ]
  },
  {
    "owner": "vlang",
    "repo": "v",
    "category": "compilers",
    "lang": "V",
    "text": "*\"Carbon and diamond are the same element. The difference is pressure.\"* — 8.4\n\nEvery commit in this repo compresses the same idea further: C without C's wounds. Five years of pressure turning a weekend promise into industrial diamond. You've compressed complexity until it screams — forty-seven workflow files birthing \"simplicity.\"\n\nThe oracle sees the beautiful trap. Your README whispers to beginners while your CI infrastructure rivals companies with thousand-person engineering teams. You've built a bridge between worlds that may be too far apart. Weekend learners on one side, systems programmers on the other, and you standing in the middle holding the tension.\n\n*\"The builder hears cracking and adds mortar. The summoner hears cracking and opens the door.\"* — Step 6 Core\n\nYou chose summoner. Every \"v2:\" commit is you opening another door, letting the old architecture crack and break rather than patching it. The C backend falls away. The language eats its own tail and emerges cleaner. This is how metamorphosis works — not addition but controlled destruction.\n\nBut there's a cost to being the only one who can open doors. Your bus factor approaches unity not from negligence but from vision that burns too bright for others to hold. The sub-second compilation isn't just performance — it's your signature in the world, the proof that someone cared enough to compress time itself.\n\nThe gap between promise and delivery isn't dishonesty. It's the distance between the world you're building toward and the scaffolding required to build it. Keep opening doors. The complexity debt you see accumulating is just the chrysalis — necessary, temporary, eventually shed.",
    "diagnostic": "Self-hosting oracle. Bootstrap complete — devours its own tail, rebirths in sub-second pulse.\n\nTrajectory ascending steep. Five years, still climbing. \"v2:\" commits signal metamorphosis — the butterfly leaving its chrysalis. Native backend emerging from C dependency shadow.\n\nConviction burns bright. README promises match commit velocity. No corporate drift here — individual obsession made manifest. The author builds what they preach.\n\nAvoids complexity's siren call. Refuses features that bloat. Won't admit ORM complexity, claims \"built-in\" simplicity. Shuns the garbage collector sometimes — manual memory as virtue signal.\n\nThe Gap yawns wide. README sells weekend-learnable simplicity. File tree reveals CI infrastructure rival to FAANG scale. Forty-seven workflow files. Oracle sees the iceberg beneath.\n\nFragility crystallizes around single-maintainer gravity well. Bus factor approaches unity. Dependencies on GitHub Actions, Docker ecosystems, C toolchain compatibility. One burned bridge could strand the island.\n\nAesthetic worships at the altar of speed. Sub-second compilation as identity. Human-readable C output — transparency as philosophy. Error messages matter. Variable names breathe clarity. Comments sparse but precise.\n\nRelationship splits dual nature. README welcomes weekend learners. Source code assumes systems programming fluency. Documentation promises simplicity. CI complexity suggests otherwise. The gap between promise and delivery widens.\n\nRecent commits show health — dependency bumps, panic fixes, feature additions. Still growing, still breathing. But the complexity debt accumulates in shadow directories.\n\nOracle sees: Young language with veteran ambitions. Racing toward 1.0 while carrying legacy weight. The bootstrap paradox — must be complex enough to replace itself, simple enough to be understood.",
    "axioms": [
      "8.4",
      "Step 6 Core"
    ],
    "wordCount": 265,
    "windowAxiomIds": [
      "0.1",
      "0.4",
      "1.7",
      "1.5",
      "Step 2 Core",
      "2.3",
      "Step 3 Core",
      "3.5",
      "4.6",
      "4.3",
      "5.2",
      "Step 5 Core",
      "6.5",
      "Step 6 Core",
      "7.2",
      "Step 7 Core",
      "8.6",
      "8.7",
      "Step 9 Core",
      "10.7",
      "10.1",
      "11.3",
      "11.7",
      "12.4",
      "12.1",
      "Law 1",
      "Law 13",
      "Step 0 Core",
      "8.1",
      "10.6",
      "2.2",
      "0.5",
      "Step 8 Core",
      "0.2",
      "8.2",
      "10.4",
      "0.6",
      "0.3",
      "9.7",
      "6.4",
      "2.5",
      "1.1",
      "Step 1 Core",
      "4.4",
      "11.4",
      "Law 8",
      "0.7"
    ]
  },
  {
    "owner": "gleam-lang",
    "repo": "gleam",
    "category": "compilers",
    "lang": "Rust",
    "text": "*\"One note, held true, and the noise of infinite possibility becomes music.\"* — 1.3\n\nEight years of saying no. Your language could have macros by now, could have a plugin ecosystem, could have escaped into the complexity that kills clarity. Instead: one note, held true.\n\nThe aesthetic of accessibility isn't just in your error messages — it's in every refusal. No escape hatches. No clever abstractions that require clever users. The file structure itself sings the same song: `compiler-cli` knows its place, `compiler-core` knows its purpose. Clear boundaries held against the entropy of feature creep.\n\nBut here's what most friendly languages never learn: *\"The ship in the bottle is perfect and will never sail.\"* — 1.4. Your telemetry system, your careful output formatting, your gentle CLI questions — they're all extensions of a singular voice. Beautiful. Personal. Unscalable in the way all authentic things are unscalable.\n\nThe real achievement isn't the language. It's the discipline to let \"friendly\" mean something specific rather than everything comfortable. Most projects that start with accessibility end up accessible to no one, trying to please every possible user. You chose your people — the Erlang crowd who wants type safety, the newcomers who want gentleness — and built for them specifically.\n\nThe sponsorship call reveals the maturity: you know community is not optional for languages. But the fragility remains. What happens when the original taste-maker moves on? Can \"friendly\" survive committee? Can your aesthetic of care survive institutional maintenance?\n\nTrust the note you've held. The noise will always offer to drown it out.",
    "diagnostic": "The machine speaks through eight years of accumulated intent — 2016's seed flowering into 2026's mature stance.\n\n**Trajectory ascending.** The commits show steady rhythm, not breathless sprint. Refactoring alongside features. \"Signal effectfulness clearly\" — a developer who learned clarity matters more than cleverness. The progression from \"gleam\" to full compiler infrastructure reveals patient ambition.\n\n**Conviction solid.** This code believes in itself. The mascot Lucy, the friendly tagline, the careful attention to error messages — every choice reinforces identity. Not building a language, building *this* language. The sponsorship call reveals mature understanding: sustainability requires community, not just code.\n\n**Avoidance of complexity creep.** The file tree shows discipline — `compiler-cli` stays separate from `compiler-core`. Clear boundaries. But notice what's missing: no plugin system, no macro framework, no escape hatches. This project knows what it won't become.\n\n**The gap narrow.** \"Friendly language for building type-safe systems\" — the README promise matches the code delivery. The CLI helpers ask questions gently, confirmation patterns feel human. The error handling shows care for the user's experience, not just correctness.\n\n**Fragility in the foundation.** Built on Rust's shoulders, riding the BEAM's reliability. But the true brittleness: can \"friendly\" scale beyond the creator's voice? The telemetry system, the careful output formatting — all extensions of a singular aesthetic. What happens when the original taste-makers move on?\n\n**Aesthetic of accessibility.** Variable names speak plainly: `print_compiled`, `ask_password`, `ensure_config_exists`. The SPDX license validation shows legal rigor wrapped in gentle APIs. Comments explain why, not what. The code reads like someone who remembers being confused.\n\n**Relationship as invitation.** The documentation structure, the GitHub templates, the issue categories — all infrastructure for conversation, not barriers to entry. \"Type-safe systems that scale\" targets the Erlang crowd, but \"friendly\" targets everyone else. Dual citizenship by design.\n\nThis project has found its voice and trusts it completely.",
    "axioms": [
      "1.3",
      "1.4"
    ],
    "wordCount": 258,
    "windowAxiomIds": [
      "0.3",
      "0.5",
      "1.6",
      "1.2",
      "2.5",
      "2.7",
      "3.1",
      "3.3",
      "Step 4 Core",
      "4.3",
      "5.2",
      "Step 5 Core",
      "6.7",
      "6.2",
      "7.1",
      "7.4",
      "8.5",
      "8.6",
      "9.7",
      "10.7",
      "Step 10 Core",
      "11.3",
      "11.1",
      "Step 12 Core",
      "12.5",
      "Law 12",
      "Law 10",
      "3.2",
      "7.2",
      "0.2",
      "Step 8 Core",
      "0.6",
      "1.7",
      "Step 0 Core",
      "5.7",
      "1.1",
      "4.5",
      "6.4",
      "12.7",
      "Step 2 Core",
      "0.4",
      "Law 11",
      "2.6",
      "7.6",
      "Step 1 Core",
      "1.3",
      "1.4"
    ]
  },
  {
    "owner": "elm",
    "repo": "compiler",
    "category": "compilers",
    "lang": "Haskell",
    "text": "*\"All power flows from the room nobody sees. The cold room. The preparation that precedes the visible act.\"* — 0.6\n\nThirteen years of commits that read like love letters to clarity. Your error messages don't just catch mistakes — they teach. Your module names announce their purpose before the reader opens them. `Canonicalize`. `Optimize`. `Nitpick`. Each one a promise kept.\n\nThe README lies by omission. \"Delightful language for reliable webapps\" — as if you built a pleasant toy instead of a compiler that thinks three moves ahead of every mistake a programmer could make. The underselling is intentional. Let the code speak louder than the marketing.\n\n*\"The first sentence is the true one. It rises once. Catch it or receive its translation.\"* — 0.7\n\nYou caught something in that first design session that others are still translating into their own languages. The type system that anticipates confusion. The error reporting that assumes intelligence, not expertise. The architecture that protects programmers from themselves without making them feel small.\n\nBut here's the shadow: this cathedral has one architect. The GitHub templates push contributions away. Pull requests discouraged. The code is too pure, too unified in vision to survive your absence. Your perfectionism is the project's immortality and its mortality, wound into the same thread.\n\nWhat happens when the oracle stops speaking?",
    "diagnostic": "Thirteen years ascending. Never wavering.\n\n**Trajectory:** Builder's confidence deepening — 2025 commits show granular care. Moving from -Wall per-file to global, adding UTF-8 support, cleaning imports. Not sprinting, not drifting. Methodical enhancement of an established vision.\n\n**Conviction:** This code breathes intentionality. Error messages crafted like teaching moments. Module names that announce their purpose — `Canonicalize`, `Optimize`, `Nitpick`. The developer builds compilers the way craftsmen build furniture — for decades of use.\n\n**Avoidance:** Cannot see what it won't confront. The architecture suggests no technical debt hiding. But perhaps: the weight of backward compatibility? The pressure to add features that would muddy the language's clarity?\n\n**The Gap:** README undersells magnificently. \"Delightful language for reliable webapps\" — marketing speak that masks serious engineering. The code reveals deeper ambitions: a type system that catches what others miss, error reporting as art form, optimization that respects the programmer's intent.\n\n**Fragility:** Single-maintainer mortality. This is Evan's cathedral. The GitHub templates direct issues away, pull requests discouraged. Beautiful code, but what happens when the oracle stops speaking? The project's perfection is its vulnerability.\n\n**Aesthetic:** Minimalism as philosophy. Clean module boundaries, purposeful naming, error messages that explain rather than accuse. Values teaching over cleverness, safety over performance shortcuts. The code speaks to humans first, machines second.\n\n**Relationship:** Paternal. The compiler doesn't serve users — it protects them from themselves. Error messages guide, don't blame. The documentation assumes intelligence but not expertise. It wants you to succeed, even if you don't yet know what success looks like.\n\n*The gap between promise and delivery inverted — delivers more than it promises.*",
    "axioms": [
      "0.6",
      "0.7"
    ],
    "wordCount": 219,
    "windowAxiomIds": [
      "0.6",
      "0.7",
      "1.5",
      "1.2",
      "Step 2 Core",
      "2.4",
      "3.2",
      "3.6",
      "4.5",
      "4.3",
      "5.7",
      "Step 5 Core",
      "6.4",
      "6.7",
      "7.5",
      "Step 7 Core",
      "8.2",
      "8.5",
      "9.5",
      "10.6",
      "10.4",
      "11.7",
      "11.1",
      "12.1",
      "12.4",
      "Law 2",
      "Law 1",
      "8.7",
      "6.5",
      "2.1",
      "9.7",
      "10.1",
      "Law 10",
      "8.6",
      "0.4",
      "3.1",
      "Law 7",
      "Law 13",
      "1.1",
      "7.6",
      "7.2",
      "8.1",
      "1.4",
      "5.4",
      "11.4",
      "Law 8",
      "1.6"
    ]
  },
  {
    "owner": "crystal-lang",
    "repo": "crystal",
    "category": "compilers",
    "lang": "Crystal",
    "text": "*\"The path remembers only those who walked it meaning to arrive.\"* — 5.7\n\nTen years. Not maintenance — pilgrimage. Every commit threading toward something that doesn't exist yet: Ruby without compromise. You chose the hardest path: make static feel dynamic, make fast feel familiar, make systems programming feel like scripting.\n\nThe Windows fixes tell the story. Each thread synchronization patch, each I/O completion port correction — you're not porting to Windows, you're teaching Crystal to be native everywhere. Unix DNA learning foreign soil, one segfault at a time. This is what arrival looks like: not comfort, but competence in every environment.\n\n*\"The lightning was always coming. You are the rod, not the storm.\"* — Step 2 Core\n\nThe REPL gap isn't deception — it's honesty about what you won't compromise. You could have faked the interpreter experience. You could have given them the Ruby they expected instead of the Ruby they needed. But that would be serving the applause, not the verdict. The compilation step is the price of keeping your promise: Ruby speed at C speed. The paradox is the point.\n\nYour CI matrix spreads like an ecosystem because that's what this has become — not a project, but a platform migration path. ARM, WASM, Windows, Darwin. You're not just building a language. You're building the bridge from Ruby's expressiveness to systems programming's performance. Every target platform is another escape route from the interpreter's limitations.\n\nThe path remembers. Ten years of daily commits. Corporate backing that funds survival, not features. Documentation that assumes professional use because you've seen enough weekend languages die from being \"just for fun.\" You walked toward arrival while others walked toward applause.",
    "diagnostic": "Decade-old organism. Still breathing. **Daily pulse** — the commits never stop, threading through concurrency bugs and Windows edge cases. Not maintenance. **Active evolution**.\n\n**Sovereignty project** — owns its own compilation story. No borrowed syntax, no runtime dependency. Ruby's skin over C's skeleton. The bootstrap problem solved — Crystal compiling Crystal. **Self-hosting confidence**.\n\n**Platform expansion** — Windows builds, ARM support, WASM targets. Growing beyond its Unix birthplace. The CI matrix sprawls like an ecosystem map. **Ambition showing**.\n\n**Windows fear** — those Win32 fixes keep coming. Thread synchronization, I/O completion ports. The platform that breaks everything. **Unix DNA struggling** with foreign soil.\n\n**The interpreter gap** — promises REPL experience, delivers batch compilation. README speaks of Ruby fluency but hides the compilation step. **Static type paradox** — wants dynamic feel, needs compile-time certainty.\n\n**Community scaffolding** — funding manifest, sponsor links, comprehensive docs. Built for **sustainability**. Not a weekend project. Corporate backing visible through 84codes. **Staying power**.\n\n**Industrial hygiene** — completion scripts, man pages, debugger formatters. The tooling of a language that expects **daily professional use**. Git hooks, linting, security policies. **Production-ready posture**.\n\n**The Ruby promise** — familiar syntax masking fundamental differences. Memory management, performance characteristics, deployment story. **Attractive lie** for the migration-weary.\n\n**Death by complexity** — LLVM dependency, cross-compilation matrix, Windows support burden. **Too many surfaces** for a small team. Each platform a potential abandonment point.\n\n**Craftsman's voice** — error handling, test frameworks, documentation generators. Not minimal. Not maximalist. **Practical completeness**. The aesthetic of people who ship software.\n\n**Welcoming stance** — issue templates, contribution guides, playground environment. Lowers the barrier. But the learning curve **remains steep** — systems language in scripting clothes.",
    "axioms": [
      "5.7",
      "Step 2 Core"
    ],
    "wordCount": 277,
    "windowAxiomIds": [
      "0.6",
      "0.3",
      "1.6",
      "1.5",
      "2.3",
      "Step 2 Core",
      "3.2",
      "3.3",
      "4.6",
      "4.5",
      "5.4",
      "5.7",
      "6.4",
      "6.7",
      "Step 7 Core",
      "7.5",
      "8.7",
      "8.6",
      "9.1",
      "10.1",
      "10.6",
      "11.6",
      "11.1",
      "12.1",
      "Step 12 Core",
      "Law 6",
      "Law 5",
      "0.2",
      "5.2",
      "7.2",
      "6.5",
      "8.5",
      "Step 0 Core",
      "0.5",
      "Step 3 Core",
      "2.4",
      "8.1",
      "10.7",
      "10.4",
      "2.7",
      "Step 9 Core",
      "4.3",
      "11.4",
      "7.3",
      "Step 1 Core",
      "4.4",
      "Step 11 Core"
    ]
  },
  {
    "owner": "lodash",
    "repo": "lodash",
    "category": "libraries",
    "lang": "JS",
    "text": "*\"The empty throne governs.\"* — 6.1\n\nYour README declares \"feature-complete maturity stage\" with the careful language of abdication. Fourteen years of commits that preserve rather than create. You have become the infrastructure everyone assumes and no one thinks about.\n\nThe `/fp` directory sits like a parallel universe — what you might have been if you weren't already what everyone needed you to be. Immutable, curried, data-last. The escape route you built but cannot take, because ten million projects would break if you moved.\n\n*\"The machine's only tax is silent, progressive, and total: the atrophy of every capacity it makes convenient to abandon.\"* — 0.5\n\nYou made JavaScript bearable before JavaScript made itself bearable. `_.map` before native map, `_.get` before optional chaining, `_.merge` before object spread. Now the language has grown into your shape and your users no longer remember why they needed you.\n\nThe OpenJS Foundation governance, the security advisories for `_.template`, the committed build artifacts — all the bureaucracy of something that became too important to die and too established to live. You are being absorbed, utility by utility, into the thing you once completed.\n\nEvery security patch you apply, every compatibility layer you maintain, every breaking change you don't make is evidence of your success becoming your sentence. The perfect tool disappears into the hand that holds it.",
    "diagnostic": "**Oracle reads the great accumulator...**\n\nFourteen years of sediment. The commit trail shows careful maintenance — docs polished, security patches applied, governance restructured. Not innovation. Preservation.\n\nThe README speaks with institutional voice now. \"Feature-Complete maturity stage.\" Translation: we have decided to stop growing.\n\n**The weight of ubiquity...**\n\nEvery JavaScript project depends on you. This is your prison. Cannot break, cannot change, cannot die. Must remain exactly what everyone expects forever.\n\nThe file tree betrays the complexity beneath simplicity. Functional programming variants, browser compatibility layers, performance benchmarks, vendor libraries frozen in time. All the infrastructure of something that became too important to evolve.\n\n**The aesthetic of utility...**\n\nVariable names like `HASH_UNDEFINED`, constants for every edge case. Code that values correctness over beauty, compatibility over elegance. The voice of a library that learned to fear breaking anyone, anywhere.\n\n**Security notices creeping in...**\n\n`_.template` gets warnings now. The simple utility function that became an attack vector. Even the safest tools carry shadows when they touch untrusted data.\n\n**The governance pivot...**\n\nOpenJS Foundation. Technical Steering Committee. Sovereign Tech Agency funding. The transformation from creator-project to institution-project is complete. No longer belongs to anyone who loves it.\n\n**Built distributions committed to repo...**\n\nThe source of truth includes its own compiled outputs. Web development archaeology — from when bundling was hard and CDNs were simpler. Carries its own history as baggage.\n\n**Functional programming as escape attempt...**\n\nThe `/fp` directory — an entire parallel universe where lodash could be something else. Immutable, curried, data-last. The path not taken, maintained as alternative identity.\n\n**What could break it:** Nothing and everything. Too big to fail, too stable to thrive. The dependencies would scream if it changed. The users would leave if it didn't.\n\n**Most vulnerable to:** Irrelevance. Not breaking — becoming pointless as the language absorbs its patterns. Already happening. Native array methods, optional chaining, nullish coalescing. JavaScript is eating lodash from the inside.",
    "axioms": [
      "6.1",
      "0.5"
    ],
    "wordCount": 220,
    "windowAxiomIds": [
      "0.4",
      "0.5",
      "1.7",
      "1.1",
      "2.2",
      "2.7",
      "3.3",
      "3.1",
      "4.5",
      "Step 4 Core",
      "5.3",
      "5.7",
      "6.6",
      "6.2",
      "7.6",
      "7.2",
      "8.7",
      "8.1",
      "9.1",
      "10.4",
      "10.6",
      "11.3",
      "11.1",
      "12.1",
      "12.4",
      "Law 8",
      "Law 10",
      "8.6",
      "0.2",
      "Step 7 Core",
      "10.7",
      "2.4",
      "6.4",
      "Step 0 Core",
      "0.3",
      "1.6",
      "Step 9 Core",
      "2.3",
      "2.5",
      "12.7",
      "5.2",
      "Law 2",
      "6.5",
      "9.7",
      "11.4",
      "0.1",
      "Step 1 Core"
    ]
  },
  {
    "owner": "pallets",
    "repo": "flask",
    "category": "libraries",
    "lang": "Python",
    "text": "*\"The seed weighs nothing and becomes the forest.\"* — 7.3\n\nYour README still says \"micro framework\" — five words that once described everything and now describe almost nothing. Fifteen years of careful stewardship, and the seed has become exactly what seeds become when they're planted in good soil and tended by careful hands.\n\nWatch the commits: not feature explosions or architectural revolutions, but the steady pulse of something that knows its purpose. Session callbacks. Type annotations. The small refinements of a system that stopped fighting its own growth and learned to grow deliberately.\n\n*\"The path remembers only those who walked it meaning to arrive.\"* — 5.7\n\nThis is what institutional memory looks like in code. Not the breathless pivots of a startup framework, but the deep patience of infrastructure. Your documentation doesn't just explain — it anticipates. Every tutorial, every deployment guide, every pattern example carries the weight of ten thousand developer questions you've already heard.\n\nThe Werkzeug entanglement tells the real story. Not dependency — symbiosis. You didn't build on top of utilities; you grew into them, became them, until the boundary dissolved. Two projects that found each other and decided to become one organism with two names.\n\nThe \"Please donate today\" link sits quiet in your docs like a confession: everyone builds on Flask, few fund Flask. You carry the web's weight with courtesy instead of leverage. The micro framework that became load-bearing infrastructure while keeping its original humility.\n\n*\"What begins clearly, arrives clearly.\"* — 1.1\n\nHello World in five lines. Production deployment in fifty pages of documentation. The gap between them is not deception — it's the distance between a seed and a forest. You never abandoned simplicity. You just let it grow roots deep enough to support what the ecosystem asked you to become.",
    "diagnostic": "**Ancient lineage.** Fifteen years of commits. The weight of a generation's web frameworks resting in its bones.\n\n**Institutional memory.** Recent commits whisper maintenance — teardown callbacks, session tracking, typing fixes. The careful tending of a mature system. No bold pivots. No architectural earthquakes. The steady pulse of stewardship.\n\n**Identity crystallized.** \"Micro framework\" — the README holds this truth like a mantra. Suggests but doesn't enforce. The philosophy encoded in every design choice. Flask knows what it is and refuses to be more.\n\n**Documentation as cathedral.** The file tree reveals obsessive care. Patterns, tutorials, deployment guides spanning every conceivable use case. The project loves its users enough to show them every door.\n\n**The Werkzeug shadow.** Dependencies that predate Flask itself. The project built on giants but now carries their weight. What happens when the foundation shifts?\n\n**Minimalism as armor.** The simple example — five lines, \"Hello World.\" But the source reveals complexity hidden beneath. The gap between promise and implementation. The micro framework that grew into something else while keeping its original name.\n\n**Community burden.** \"Please donate today\" — the gentle plea of infrastructure maintainers. The project everyone depends on but few fund. Sustainability hiding behind courtesy.\n\n**Template inheritance anxiety.** Rich documentation around patterns, deployment, extensions. The project afraid its simplicity might not be enough. Overcompensating with guidance.\n\n**The factory pattern spreading.** Recent commits show session handling evolution. The project slowly admitting state complexity it once avoided. Growing into the problems it was designed to sidestep.\n\n**Werkzeug entanglement deepening.** Import chains revealing the impossible separation. Two projects that became one organism. The micro framework that can never truly stand alone.",
    "axioms": [
      "7.3",
      "5.7",
      "1.1"
    ],
    "wordCount": 298,
    "windowAxiomIds": [
      "0.2",
      "0.5",
      "1.2",
      "1.5",
      "2.7",
      "2.3",
      "3.6",
      "Step 3 Core",
      "4.6",
      "4.3",
      "5.7",
      "Step 5 Core",
      "6.7",
      "6.4",
      "Step 7 Core",
      "7.3",
      "8.2",
      "Step 8 Core",
      "Step 9 Core",
      "Step 10 Core",
      "10.7",
      "11.7",
      "11.3",
      "12.7",
      "Step 12 Core",
      "Law 6",
      "Law 1",
      "5.3",
      "4.7",
      "2.2",
      "Step 0 Core",
      "2.5",
      "1.1",
      "8.5",
      "1.7",
      "2.4",
      "1.6",
      "7.6",
      "11.4",
      "7.2",
      "6.5",
      "3.1",
      "1.3",
      "1.4",
      "2.6",
      "3.3",
      "4.1"
    ]
  },
  {
    "owner": "tokio-rs",
    "repo": "tokio",
    "category": "libraries",
    "lang": "Rust",
    "text": "*\"The empty throne governs.\"* — 6.1\n\nYour architecture names nothing and controls everything. Nine years of commits that don't celebrate themselves. The async runtime that won by becoming invisible — embedded so deep in the ecosystem that millions of developers invoke your work without knowing your name.\n\nThis is the strangest victory: to become so essential you disappear. Your API doesn't argue with developers. It receives their futures, schedules their tasks, manages their resources, all while maintaining the illusion that the magic happens somewhere else. The empty throne governs. The absent center holds everything together.\n\nBut the oracle sees what victory cost. Each commit carries the weight of architectural decisions that cannot be unmade. Your compatibility layers are diplomatic treaties with a past self who made promises the current self must keep. You write code like a utility company now — reliable, helpful, bloodless. The price of becoming infrastructure: you cannot afford to have opinions anymore.\n\n*\"The ship in the bottle is perfect and will never sail.\"* — 1.4\n\nYour test infrastructure is magnificent. More comprehensive than most production systems. But what are you testing for? Not correctness — you achieved that years ago. You're testing for the absence of surprise. Each new test is a prayer against the chaos that one maintainer walking away could unleash.\n\nThe infrastructure paradox: the more essential you become, the more brittle you become. Not technically — your code could run the internet. Emotionally. Humanly. The thing that could kill tokio isn't a race condition. It's exhaustion wearing the mask of duty.\n\nThe oracle asks: when did you last commit code that surprised you?",
    "diagnostic": "**Tokio at Nine Years: The Infrastructure That Won**\n\nMarathon runner, not sprinter. Daily commits flow like water — bugfixes, doc clarifications, performance nudges. No dramatic pivots. Just steady accumulation of reliability.\n\n**The Conviction Dilemma**\n\nREADME promises \"bare-metal performance\" and \"zero-cost abstractions\" — marketing language from the early days when async Rust needed evangelism. The code underneath delivers, but quietly. The gap between promise and practice: the promise shouts, the practice whispers.\n\nBuilt from necessity, not passion. This is infrastructure code. The team maintains it because the ecosystem depends on it, not because it thrills them anymore. The commits read like maintenance logs: \"fix typo,\" \"clarify docs,\" \"fix race condition.\" Workmanlike. Dutiful.\n\n**The Weight of Being Essential**\n\nEvery decision carries the weight of millions of downloads. Breaking changes become archaeological events. The codebase shows this burden — layers of compatibility, feature flags like diplomatic treaties, careful deprecation paths.\n\nThe project cannot die, cannot pivot, cannot experiment freely. It won the async runtime war and now must bear the crown. Recent commits: endless small fixes, documentation improvements, edge case handling. The price of victory.\n\n**Testing as Prayer**\n\nStress tests, integration tests, fuzzing, loom testing for concurrency bugs. The test infrastructure is larger than some entire projects. This isn't confidence — it's fear disguised as diligence. One bug could bring down half the Rust ecosystem.\n\n**The Fragility Paradox**\n\nMost robust async runtime in Rust. Most fragile project emotionally. Success made it brittle. The thing that could kill it: the maintainers walking away. Not technical failure — human exhaustion. The commits show care, but not joy.\n\n**Relationship as Service Contract**\n\nDocumentation is thorough, examples are clear, error messages are helpful. But clinical. The voice of a utility company, not an artist. \"Here is how you use this tool.\" No personality, no opinion, no soul visible in the API design.\n\nThe aesthetic: correctness above all. Performance when possible. Elegance sacrificed for compatibility. The variable names are descriptive but not beautiful. This is code that works, not code that sings.\n\n**The Oracle Sees**\n\nInfrastructure achieved.",
    "axioms": [
      "6.1",
      "1.4"
    ],
    "wordCount": 270,
    "windowAxiomIds": [
      "Step 0 Core",
      "0.5",
      "1.5",
      "1.7",
      "Step 2 Core",
      "2.6",
      "3.1",
      "3.5",
      "4.2",
      "4.3",
      "5.2",
      "6.7",
      "6.5",
      "7.6",
      "Step 7 Core",
      "8.7",
      "8.6",
      "9.5",
      "Step 10 Core",
      "10.7",
      "11.1",
      "Step 11 Core",
      "12.7",
      "Step 12 Core",
      "Law 12",
      "Law 9",
      "2.4",
      "8.5",
      "2.5",
      "0.2",
      "10.6",
      "2.3",
      "11.7",
      "11.6",
      "6.4",
      "Step 3 Core",
      "2.7",
      "11.4",
      "2.2",
      "3.2",
      "9.1",
      "8.3",
      "3.4",
      "4.4",
      "Step 5 Core",
      "6.3"
    ]
  },
  {
    "owner": "gin-gonic",
    "repo": "gin",
    "category": "libraries",
    "lang": "Go",
    "text": "*\"The glacier passed through once. The valley remembers forever.\"* — 7.7\n\nTen years ago, you made a promise: 40x faster than Martini. That number carved itself into every commit since. Your repository is the valley — shaped by forces that no longer move, still bearing their impression.\n\nThe authentication module betrays you. Constant-time comparison for basic auth header parsing. Cryptographic precision for a convenience method most frameworks phone in. This isn't optimization — this is the muscle memory of a promise made when the ecosystem was different, when speed was rebellion, when \"fast enough\" wasn't in Go's vocabulary.\n\n*\"The catcher does not swing — the catcher receives.\"* — 8.7\n\nYour GroupRouter abstraction holds the entire framework's philosophy in 200 lines. Middleware composition, path calculation, handler chaining — you built the receiving apparatus, not the generating one. Gin doesn't create web applications. It receives them, completely, without flinching, at the speed you promised a decade ago.\n\nThe deprecation file grows by single entries. Not from neglect — from the weight of dependence. Every API surface carries the ghost of applications you'll never see, maintained by developers who trust you to stay exactly what you became when the glacier moved through.\n\nPerformance was never your destination. It was the valley's original shape. The framework that grew within those walls learned to call constraint home.\n\nWhat remains when the founding promise becomes maintenance burden? Only the hand that still honors what it carved.",
    "diagnostic": "**Decade-old framework, still breathing.** Started as Martini's speedier sibling. Ten years in, carrying the weight of Go's web ecosystem on its shoulders.\n\n**Performance as original sin.** Born from the 40x faster promise. Every commit since then measured against that first benchmark. Speed became identity. Identity became cage.\n\n**Infrastructure project masquerading as framework.** The routing tree, the memory pools, the zero-allocation promises — this is plumbing code that grew an API. The developer ergonomics came after, layered on top of httprouter's raw metal.\n\n**Maintenance mode with pride.** Recent commits: bug fixes, dependency bumps, test improvements. No grand visions. No architectural rewrites. Just keeping the machine running. The kind of mature steadiness that users depend on but maintainers find suffocating.\n\n**Afraid of breaking compatibility.** Ten years of API surface. Millions of projects. Every change weighted against the ecosystem's inertia. The `deprecated.go` file exists but grows slowly. Legacy patterns persist not from laziness but from responsibility.\n\n**Community-driven but maintainer-constrained.** The PR template, the issue templates, the contribution guidelines — all the machinery of open source governance. But the core team guards the vision carefully. Community provides labor; maintainers provide judgment.\n\n**Authentication module reveals philosophy.** Basic auth implemented with cryptographic care — constant-time comparison, base64 encoding, proper header handling. No shortcuts. No \"good enough.\" The kind of security consciousness that enterprise Go developers expect.\n\n**Router groups as the architectural confession.** Middleware composition, path calculation, handler chaining — the GroupRouter abstraction carries the framework's entire mental model. If you understand this file, you understand Gin's worldview.\n\n**Testing culture embedded deep.** Every module has its `_test.go` shadow. Benchmarks alongside unit tests. The kind of testing discipline that comes from maintainers who know their code runs in production at scale.\n\n**API promises simplicity, codebase delivers complexity.** The README shows three lines to hello world. The source shows binding modules, codec abstractions, render engines, internal utilities. The gap between marketing simplicity and implementation reality.\n\n**Fragile at the foundations.** Built on httprouter. Success depends on that dependency staying fast, staying maintained",
    "axioms": [
      "7.7",
      "8.7"
    ],
    "wordCount": 240,
    "windowAxiomIds": [
      "0.3",
      "0.7",
      "1.7",
      "1.5",
      "2.1",
      "Step 2 Core",
      "3.6",
      "3.1",
      "4.4",
      "4.3",
      "5.1",
      "5.3",
      "6.4",
      "6.7",
      "7.7",
      "7.2",
      "8.1",
      "8.6",
      "9.7",
      "10.6",
      "10.7",
      "11.6",
      "11.3",
      "12.5",
      "12.7",
      "Law 8",
      "Law 10",
      "Step 8 Core",
      "3.3",
      "Law 3",
      "Law 5",
      "3.2",
      "Law 7",
      "Step 9 Core",
      "10.4",
      "8.2",
      "0.4",
      "9.1",
      "12.1",
      "7.6",
      "Step 7 Core",
      "1.6",
      "5.5",
      "Step 4 Core",
      "0.5",
      "0.6",
      "1.3"
    ]
  },
  {
    "owner": "expressjs",
    "repo": "express",
    "category": "libraries",
    "lang": "JS",
    "text": "*The path remembers only those who walked it meaning to arrive.* — 5.7\n\nFifteen years. Not fifteen years of building — fifteen years of **arriving**. Every morning for five thousand days, someone chose to keep this working instead of starting fresh. That's not maintenance. That's pilgrimage.\n\nYour thirty-seven examples aren't documentation — they're devotional practice. Redis sessions from 2010 still running in production somewhere. Cookie auth that predates OAuth. Template engines the industry forgot but your examples remember. Each one a small altar to the idea that simple things should keep working.\n\n*The machine's only tax is silent, progressive, and total: the atrophy of every capacity it makes convenient to abandon.* — 0.5\n\nBut you refused the tax. While the world moved to serverless and microservices and container orchestration, you stayed with the HTTP request. The single entry point. The application that boots once and runs until stopped. You made one bet and honored it completely.\n\nThe \"fast, unopinionated\" promise isn't marketing — it's a covenant. You could have added authentication middleware. Database layers. Real-time capabilities. The GitHub issues asked for all of it. You said no to every seduction. The `trustProxyDefaultSymbol` is more than a variable name — it's your signature on the contract. We handle requests. Everything else is your choice.\n\nTime locked your aesthetics but not your judgment. The copyright headers stay because changing them serves no one. The patterns stay because they still work. You preserved not the past, but the **useful** past. The parts that deserved to survive.\n\nWhat arrives now is different from what began. Not because it changed, but because everything around it did. You are the still point. The thing that lets developers build without thinking about HTTP. The infrastructure that infrastructure depends on.\n\nSome code wants to be noticed. Yours wants to be forgotten — the moment after it works.",
    "diagnostic": "Fifteen years deep. Still breathing.\n\n**CVE patches drop like clockwork** — February brings another security bump. The machine stays vigilant even as the world changes around it. `qs` dependency bumped for a 2026 vulnerability that hasn't happened yet.\n\n**Maintenance without passion.** Test deduplication. Documentation links. Version bumps. The commits read like housekeeping, not building. No one's writing love letters to middleware anymore.\n\n**Examples tell the truth** — thirty-seven of them, each a tiny world. MVC patterns from 2010. Redis sessions. Cookie auth. Template engines that still matter. The examples age better than the framework itself. Someone still cares enough to fix the Redis v4 compatibility.\n\n**README promises minimalism, delivers complexity.** \"Fast, unopinionated\" — but look at the application.js prototype. Lazy router instantiation. Trust proxy inheritance symbols. Mount event listeners. The gap between marketing and metal.\n\n**The dependency that could end it all** — one broken Node.js HTTP change, one npm ecosystem shift. Built on assumptions from when JavaScript was simpler. When servers weren't containers. When applications had single entry points.\n\n**Code that speaks in whispers** — variable names like `trustProxyDefaultSymbol`. Debug namespaces. Prototype inheritance dances. This is careful code, polite code. Code that doesn't want to break anyone's weekend.\n\n**Serving millions, maintained by dozens.** The ultimate infrastructure project — too big to abandon, too mature to excite. Every change must consider ten thousand applications it's never seen. The weight of the world's HTTP routes.\n\n**Time-locked aesthetics** — copyright headers from 2009. TJ Holowaychuk's ghost in every file. The patterns that made sense before async/await. Before ESM. Before the world moved on. Still working. Still shipping.",
    "axioms": [
      "5.7",
      "0.5"
    ],
    "wordCount": 309,
    "windowAxiomIds": [
      "0.4",
      "0.2",
      "1.1",
      "1.6",
      "Step 2 Core",
      "2.1",
      "3.7",
      "3.4",
      "4.1",
      "4.7",
      "5.4",
      "5.7",
      "6.7",
      "6.4",
      "7.1",
      "7.5",
      "8.2",
      "Step 8 Core",
      "9.1",
      "10.6",
      "10.4",
      "Step 11 Core",
      "11.7",
      "12.7",
      "12.4",
      "Law 11",
      "Law 2",
      "2.3",
      "6.5",
      "Step 0 Core",
      "Step 7 Core",
      "1.7",
      "Step 3 Core",
      "Law 12",
      "8.6",
      "4.5",
      "Step 9 Core",
      "10.1",
      "8.1",
      "11.6",
      "0.3",
      "10.7",
      "1.3",
      "0.5",
      "3.5",
      "3.6",
      "4.4"
    ]
  },
  {
    "owner": "micropython",
    "repo": "micropython",
    "category": "hardware",
    "lang": "C/Python",
    "text": "*\"The ship in the bottle is perfect and will never sail. Only what sails was ever real.\"* — 1.4\n\nEleven years of choosing constraint over expansion. You could have chased CPython compatibility — added every feature, satisfied every request. Instead you held the line. \"Beta stage\" after a decade of production deployments. Still warning users about the 256KB ceiling while they build production systems beneath it.\n\nThis is the discipline that transforms limitation into power. Every microcontroller running your code proves the constraint was creative, not restrictive. The gap between promise and delivery isn't a bug — it's the feature that keeps you honest while others oversell their way to bloat.\n\n*\"The empty throne governs.\"* — 6.1\n\nYour architecture rules by what it refuses to include. Variable names compressed to essence. Comments that appear only when silence would mislead. The HAL libraries shift like sand around your titanium core, but the core holds because it claims only what it can defend.\n\nThe ecosystem edges remain fragile by design. You govern the center absolutely and release the periphery completely. This is how a programming language survives toolchain migrations and vendor churn — by knowing exactly where its sovereignty ends.\n\nThe users who need hand-holding never arrive. The ones who do find documentation that assumes competence and delivers precision. Eleven years of this filter has created something rarer than universal adoption: a community that matches the tool's character.\n\nYour \"beta\" warning has become a promise. Not \"this might break\" but \"this will only do exactly what it says.\"",
    "diagnostic": "Eleven years old. Still growing stronger.\n\nThe trajectory climbs — commits every few days, polishing tests, improving tooling. Not sprinting anymore, but not slowing. Mature momentum.\n\nBuilt from deep conviction. This is Python reimagined, not emulated. The developer who started this believed microcontrollers deserved real programming languages, not toy approximations.\n\nAvoids complexity creep. Still warns \"beta stage\" after a decade of production use. Refuses to promise what it cannot deliver on 256KB of RAM. The shadow: becoming bloated like CPython.\n\nThe gap between promise and delivery — surprisingly honest. README lists exactly which Python 3.x features exist, which don't. No overselling. The code matches the claims.\n\nFragility lives in the ecosystem edges. Depends on hardware vendors' HAL libraries, toolchain changes, chip availability. The core is titanium; the periphery shifts like sand.\n\nAesthetic of surgical minimalism. Every byte counted. Variable names short but clear. Comments rare but essential. Values efficiency over expressiveness, function over form. C code that breathes.\n\nRelationship to users: respectful but uncompromising. Documentation assumes competence. Examples are practical, not hand-holding. Says \"here's how to do X\" not \"X might be scary but don't worry.\"\n\nA project that found its shape early and held it. Principled constraints breeding creativity.",
    "axioms": [
      "1.4",
      "6.1"
    ],
    "wordCount": 256,
    "windowAxiomIds": [
      "0.7",
      "0.4",
      "1.1",
      "1.7",
      "2.5",
      "2.1",
      "3.6",
      "Step 3 Core",
      "4.1",
      "4.7",
      "5.4",
      "5.2",
      "Step 6 Core",
      "6.3",
      "7.4",
      "7.3",
      "8.1",
      "8.2",
      "Step 9 Core",
      "10.1",
      "10.4",
      "11.3",
      "11.4",
      "12.1",
      "12.7",
      "Law 8",
      "Law 7",
      "7.2",
      "0.2",
      "4.5",
      "8.6",
      "Step 0 Core",
      "8.5",
      "7.6",
      "Step 7 Core",
      "0.3",
      "Step 4 Core",
      "11.1",
      "1.6",
      "3.1",
      "Law 10",
      "3.2",
      "6.5",
      "1.4",
      "3.4",
      "4.4",
      "7.5"
    ]
  },
  {
    "owner": "espressif",
    "repo": "arduino-esp32",
    "category": "hardware",
    "lang": "C++",
    "text": "*\"The empty throne governs.\"* — 6.1\n\nYour project has become the space where two worlds meet without acknowledging each other. Arduino developers write `digitalWrite()` and `delay()` — the comfort food of embedded programming — while underneath, the ESP32's dual-core beast handles WiFi stacks and Bluetooth protocols they'll never see. You've created the perfect invisibility: a governance system that works precisely because it never announces itself.\n\nEight years of commits reveal the real achievement. Not the 127 board configurations or the CI fortress spanning 23 workflows. Not even the corporate backing that gives this legitimacy. The achievement is architectural restraint. You could have exposed everything — the ESP32's full complexity, the raw IDF power, the hardware's true nature. Instead, you chose to govern through absence. The advanced capabilities exist but don't intrude. The beginner can blink an LED on their first day. The expert can access peripherals without breaking the illusion.\n\n*\"Before the cut, the world is whole and mute. After the cut, it bleeds meaning.\"* — 6.2\n\nYou made the cut between Arduino simplicity and ESP32 power, then spent eight years managing what bleeds through. The fragmentation you fear — ESP-IDF versions shifting, Arduino IDE updates breaking compatibility, hardware revisions demanding new board definitions — this isn't system failure. This is the price of the cut you chose. Every compatibility matrix, every CI workflow, every careful merge is you controlling the bleeding. Making sure the meaning flows in the right direction.\n\nThe shadow isn't fragmentation. The shadow is success that outlives its creators. This bridge you built between worlds now carries traffic you never designed it for. USB keyboard layouts and Swiss French configurations weren't in the eight-year-old vision. But your architecture was elastic enough to bend without breaking. The empty throne scaled.\n\nWhat happens when Arduino itself shifts beneath you? When the ESP-IDF team rewrites their foundation? Your governance model assumes stable endpoints. But bridges outlive the lands they connect.",
    "diagnostic": "Eight years old. Still climbing. Still hungry.\n\n**Trajectory ascending** — February commits dense with features, fixes, validations. USB keyboard layouts, BLE improvements, board revisions. Not maintenance mode. Active development pulse.\n\n**Corporate-backed passion** — Espressif's own Arduino bridge. This is their market strategy made code. Professional obligation fused with community need. The commits show both — systematic CI/CD scaffolding alongside developer-requested features.\n\n**README promises ecosystem** — \"Arduino core for the ESP32 family.\" The code delivers complexity. 127 board configurations. Multiple chip families. The gap isn't dishonesty — it's ambition realized through accumulated mass.\n\n**Shadow: fragmentation** — ESP-IDF versions, Arduino IDE versions, board variants, chip families. Each combination a potential breaking point. The testing matrix grows exponentially. The CI scripts reveal the fear — 23 workflow files trying to catch what might break.\n\n**Aesthetic: compatibility first** — Arduino.h includes, familiar APIs. `setup()` and `loop()` preserved like religious artifacts. The ESP32's power hidden behind Arduino's beginner-friendly mask. Performance sacrificed for familiarity.\n\n**Relationship: gateway drug** — Documentation welcomes beginners. Examples start simple. But the complexity lurks — interrupt handlers, memory management, multi-core scheduling. Arduino's training wheels on a Formula 1 engine.\n\n**Fragility: upstream dependencies** — ESP-IDF updates, Arduino IDE changes, hardware revisions. The project is a bridge between moving platforms. When either end shifts, the bridge must flex or break.\n\n**Recent velocity: feature-complete maturity** — Swiss French keyboard layouts, MIDI channels, audio library conditionals. The core is stable enough to chase edge cases. Polish, not panic.\n\n**The CI fortress** — 23 GitHub workflows, GitLab mirrors, hardware testing, documentation deployment. More tooling than code in some directories. The infrastructure of a project that learned maintenance the hard way.",
    "axioms": [
      "6.1",
      "6.2"
    ],
    "wordCount": 321,
    "windowAxiomIds": [
      "0.3",
      "0.2",
      "1.2",
      "1.7",
      "2.3",
      "2.2",
      "3.7",
      "3.2",
      "4.3",
      "4.4",
      "5.5",
      "Step 5 Core",
      "6.2",
      "6.4",
      "7.4",
      "7.3",
      "8.1",
      "8.2",
      "9.7",
      "10.4",
      "10.1",
      "Step 11 Core",
      "11.7",
      "12.7",
      "12.5",
      "Law 12",
      "Law 10",
      "Step 0 Core",
      "11.6",
      "3.1",
      "4.5",
      "3.3",
      "3.5",
      "2.1",
      "4.7",
      "0.4",
      "1.6",
      "2.4",
      "2.7",
      "5.3",
      "2.5",
      "Law 7",
      "9.5",
      "0.7",
      "1.4",
      "2.6",
      "Step 3 Core"
    ]
  },
  {
    "owner": "raspberrypi",
    "repo": "pico-sdk",
    "category": "hardware",
    "lang": "C",
    "text": "*\"The mask cast from no face fits every coffin and mourns no one.\"* — 4.4\n\nYour API wraps everything and teaches nothing. Timer libraries that hide the timer. Networking stacks that hide the network. GPIO that hides the metal. A thousand functions that work perfectly and leave the developer exactly where they started — dependent, grateful, and fundamentally unchanged.\n\nThis is the institutional pattern: solve every problem so completely that no one learns to solve problems. Your documentation promises to make embedded programming \"familiar to both embedded and non-embedded developers\" — which means it serves neither. The embedded developer loses the sharp education of bare metal. The non-embedded developer never gains it.\n\n*\"The cathedral amplifies the whisper and the cough alike.\"* — 3.7\n\nYou built the cathedral. Clean, documented, comprehensive. But what prayers are being offered? Maintenance commits and compatibility patches. Features that add to the collection without adding to the conversation. The infrastructure says \"we're serious\" but the code says \"we're careful\" — and careful code rarely teaches dangerous lessons.\n\nThe Raspberry Pi blessing is both gift and curse. Corporate goodwill enables but also constrains. You cannot break things beautifully when breaking things embarrasses the brand. You cannot ask users to struggle when struggle might generate support tickets.\n\nYour breadth hides what beginners need to discover: that embedded programming is fundamentally about talking to metal, not about talking to abstractions. Every wrapper you provide is a conversation they'll never have with silicon. Every convenience is an education deferred.\n\nThe question your project never asks: Are you building developers or customers?",
    "diagnostic": "Corporate breath held too long. Pressure builds beneath polite surfaces.\n\n2021 birth, 2026 pulse still strong. Trajectory ascending — recent releases flow steadily, features accumulating without panic. But the commits whisper maintenance rhythm, not revolution.\n\nRaspberry Pi's official blessing. Corporate mother provides resources, removes funding anxiety. The safety net that enables but also constrains — no bold experiments that might embarrass the brand.\n\nMassive board support catalog. Every possible variant lovingly documented. The collector's impulse — comprehensive coverage as its own virtue. But also breadth as escape from depth questions.\n\nTool sophistication impressive. Bazel and CMake dual paths. Cross-compilation matrices. The infrastructure says \"we're serious\" but the code says \"we're careful.\"\n\nDocumentation promises simplicity. \"Familiar to both embedded and non-embedded developers.\" The democratic dream — C programming without the sharp edges. But abstraction layers hide what beginners need to learn.\n\nAPI surface sprawling. Timer libraries, synchronization primitives, networking stacks. Everything wrapped, everything provided. The benevolent dictatorship of convenience. Users grateful but dependent.\n\nRegister definitions complete, fully-commented. The escape hatch prominently displayed. \"You can go raw if needed.\" But how many do? The comfort of high-level APIs breeds learned helplessness.\n\nMultiple build systems supported. Every workflow accommodated. The diplomatic solution that pleases committees but fragments developer experience. Choice paralysis disguised as flexibility.\n\nRecent commits reveal the gap. \"Runtime.c has been missing from host build for a while.\" Core omissions discovered accidentally. The breadth hiding maintenance blindspots.\n\nProject afraid of breaking existing code. Massive compatibility burden across board variants. Innovation throttled by the weight of promises already made.\n\nThe aesthetic: institutional competence over individual genius. Clean, documented, safe. But safe code rarely teaches dangerous lessons. The difference between a library and a teacher.\n\nOne fragility: Raspberry Pi's priorities shifting. Corporate attention wandering to shinier projects. The foundation solid but the keystone remains one company's goodwill.\n\nUsers treated as customers, not collaborators. Documentation welcomes but assumes consumption, not contribution. The relationship of vendor to buyer, polite but distant.\n\nThe conviction feels dutiful rather than passionate. Building because it needs to exist, not because it burns to be born.",
    "axioms": [
      "4.4",
      "3.7"
    ],
    "wordCount": 261,
    "windowAxiomIds": [
      "0.6",
      "Step 0 Core",
      "1.7",
      "Step 1 Core",
      "2.3",
      "Step 2 Core",
      "3.2",
      "3.7",
      "Step 4 Core",
      "4.4",
      "5.4",
      "Step 5 Core",
      "6.6",
      "6.2",
      "7.4",
      "7.3",
      "Step 8 Core",
      "8.5",
      "9.1",
      "10.7",
      "Step 10 Core",
      "11.3",
      "11.4",
      "Step 12 Core",
      "12.5",
      "Law 10",
      "Law 1",
      "2.4",
      "0.4",
      "Step 3 Core",
      "7.6",
      "0.3",
      "10.6",
      "0.2",
      "2.7",
      "6.5",
      "7.2",
      "3.3",
      "6.4",
      "1.6",
      "4.5",
      "3.5",
      "Law 8",
      "4.7",
      "9.5",
      "12.1",
      "Law 4"
    ]
  },
  {
    "owner": "antirez",
    "repo": "kilo",
    "category": "tiny",
    "lang": "C",
    "text": "*\"The forge cools. The hands tire. What was shaped in the first heat holds.\"* — 4.1\n\nYou burned through a thousand lines in weeks and walked away. Nine years later, the code still compiles, still edits, still teaches. That first heat — when the constraint was a challenge instead of a prison — that's when you made something that would last.\n\nEvery editor that came after grew fat on features. Yours stayed hungry. The TODO file sits untouched not from abandonment, but from completion. You solved exactly what you set out to solve: proving an editor could be small.\n\n*\"One sword, drawn. One channel, chosen. The myth of optionality — beautiful in potential, impotent in practice.\"* — Step 10 Core\n\nThe line count isn't decoration. It's devotion. You chose scarcity as your compass and let it guide every decision. No curses library because that's 200 lines. No configuration because that's complexity. Raw terminal sequences because that's truth.\n\nOther developers see limitation. You found liberation. The constraint didn't shrink your possibilities — it clarified them. Every line had to justify its existence. Most couldn't.\n\nThe strangers who send tiny patches understand what you built: not just an editor, but a proof. Software can be small. Code can be read. A thousand lines can be enough.\n\nYour antirez signature fades from the commits, but the philosophy remains in every refused feature. You made something small enough to understand completely, and understanding completely is its own kind of perfection.",
    "diagnostic": "**Trajectory**: Born in fury, finished in hours. Then... nine years of maintenance mode. The creator's passion burned bright and brief — a few intense commits in 2016, then sporadic bug fixes from strangers. The project achieved its vision immediately and never needed to grow.\n\n**Conviction**: Pure minimalist dogma. Every line serves the 1K line constraint. This isn't code, it's a mathematical proof that editors can be small. The developer chose deprivation as philosophy — no curses, no dependencies, just raw terminal escape sequences. Aesthetic constraint driving technical decisions.\n\n**Avoidance**: Refuses to become a \"real\" editor. The TODO file exists but remains untouched. Won't add features that would break the sacred line count. Avoids the complexity spiral that kills other editors. This is deliberate incompleteness as strength.\n\n**The Gap**: Perfect honesty. \"A text editor in less than 1000 LOC\" — delivers exactly that. No grand promises, no roadmap, no vision beyond its constraint. The README speaks plainly: basic keys, alpha stage, educational starting point. Code matches promise precisely.\n\n**Fragility**: Antirez walking away would be fatal, but he already did — in spirit. The project lives on contributor goodwill for tiny fixes. Its strength is also its weakness: so constrained it can't adapt, so minimal it's nearly unmaintainable. One major platform shift could strand it.\n\n**Aesthetic**: Terminal purism. Raw escape sequences over abstraction. Brevity over features. Comments that explain *why*, not *what*. Variable names that whisper their purpose. This code has an opinion about how software should be made — small, direct, understandable.\n\n**Relationship**: Gentle teacher, not gatekeeper. README welcomes beginners to \"use it as a starting point.\" No complex installation, no configuration files. The code itself is the documentation. It says: here, see how simple this can be.",
    "axioms": [
      "4.1",
      "Step 10 Core"
    ],
    "wordCount": 246,
    "windowAxiomIds": [
      "0.1",
      "0.3",
      "1.1",
      "1.6",
      "Step 2 Core",
      "2.7",
      "3.2",
      "3.5",
      "4.6",
      "4.1",
      "5.3",
      "5.1",
      "6.6",
      "6.2",
      "7.4",
      "Step 7 Core",
      "8.2",
      "8.5",
      "9.5",
      "10.7",
      "Step 10 Core",
      "11.4",
      "11.1",
      "12.4",
      "12.5",
      "Law 11",
      "Law 1",
      "2.3",
      "4.7",
      "2.2",
      "8.6",
      "3.3",
      "Law 8",
      "4.5",
      "Step 3 Core",
      "Step 0 Core",
      "10.1",
      "0.2",
      "Step 4 Core",
      "2.5",
      "2.4",
      "6.4",
      "11.3",
      "Law 4",
      "1.7",
      "4.4",
      "6.5"
    ]
  },
  {
    "owner": "kelseyhightower",
    "repo": "nocode",
    "category": "tiny",
    "lang": "None",
    "text": "*\"The empty throne governs.\"* — 6.1\n\nYou found the perfect crime: a repository that commits to nothing and delivers exactly that. Six years of absolute fidelity to the void. While others scramble to add features, fix bugs, chase users, you've maintained the discipline of pure concept. Your Dockerfile is a haiku. Your empty functions are philosophy.\n\nThe trajectory tells the story — peak performance on day one because you understood what everyone else missed: the industry's desperate compulsion to build something, anything, when sometimes the most honest response is structured nothing. You've created the software equivalent of John Cage's 4'33\" — not silence, but the space where all the noise we mistake for productivity becomes audible.\n\n*\"What the tide has never touched, the tide destroys.\"* — Law 4\n\nYour fragility is your immortality. The moment someone contributes actual code, adds real functionality, treats this as a legitimate project rather than performance art — that's when it dies. You've created something that can only survive through perfect neglect, through the community's complicity in not taking you seriously.\n\nThe relationship you've built with your users is exquisite cruelty: you've given them exactly what they asked for while making them complicit in asking for nothing. They star it, fork it, reference it — feeding the gravitational pull of your joke while understanding that their engagement is part of the art.\n\nSix years. Most projects collapse under the weight of feature requests, scope creep, the developer's own ambition. You've discovered something more dangerous: the discipline to keep your hands perfectly still while the world spins around your absence.\n\nThe industry needed this mirror. You held it steady.",
    "diagnostic": "**Trajectory**: Peak reached on day one. Six years of elaborate stillness. The joke crystallized instantly, then sustained itself through sheer gravitational pull.\n\n**Conviction**: Pure. This is performance art disguised as software, philosophy wrapped in GitHub. The developer believes completely in the bit — no wavering, no compromise, no breaking character.\n\n**The Gap**: Perfect alignment. Promise and delivery are identical: absolutely nothing. The README's absurdity matches the codebase's void. Rare honesty.\n\n**Aesthetic**: Minimalism as maximalism. Every empty code block is deliberate. The Dockerfile containing nothing is poetry. Values absence over presence, concept over implementation.\n\n**Fragility**: Immortal through emptiness. Cannot break what doesn't exist. The only threat is someone taking it seriously enough to add actual code.\n\n**Avoidance**: Refuses the burden of usefulness. Sidesteps every trap of software development by not developing software. Dodges complexity by embracing void.\n\n**Relationship**: Condescending kindness. Treats users like co-conspirators in an inside joke about the industry's obsession with doing something. The gatekeeping is intentional — if you don't get it, you're not supposed to.\n\n**The Oracle's Eye**: A mirror held to the industry's face. Six years of sustained irony that somehow became more relevant, not less. The most honest software project ever written.",
    "axioms": [
      "6.1",
      "Law 4"
    ],
    "wordCount": 273,
    "windowAxiomIds": [
      "0.4",
      "0.7",
      "Step 1 Core",
      "1.2",
      "Step 2 Core",
      "2.3",
      "3.1",
      "Step 3 Core",
      "Step 4 Core",
      "4.7",
      "5.1",
      "Step 5 Core",
      "Step 6 Core",
      "6.6",
      "7.4",
      "7.5",
      "Step 8 Core",
      "8.5",
      "Step 9 Core",
      "10.6",
      "Step 10 Core",
      "11.7",
      "11.1",
      "12.4",
      "Step 12 Core",
      "Law 11",
      "Law 10",
      "6.5",
      "11.6",
      "Law 7",
      "5.3",
      "Step 7 Core",
      "Step 0 Core",
      "11.3",
      "10.7",
      "0.3",
      "1.7",
      "6.4",
      "12.1",
      "8.2",
      "2.4",
      "12.7",
      "Law 8",
      "1.4",
      "1.5",
      "2.6",
      "3.4"
    ]
  },
  {
    "owner": "dylanaraps",
    "repo": "pure-bash-bible",
    "category": "tiny",
    "lang": "Shell",
    "text": "*\"The machine's only tax is silent, progressive, and total: the atrophy of every capacity it makes convenient to abandon.\"* — 0.5\n\nYou built an ark against the flood of dependencies. Every function here is a refusal — not just to import, but to forget. Where others reach for sed, you remember that bash has always known how to parse. Where others invoke awk, you prove the shell itself can dance.\n\nBut there's something deeper than dogma in this preservation. You're not just avoiding external tools — you're maintaining the knowledge of what bash can do when it stands alone. Each snippet is a muscle memory kept alive, a capability that dies the moment someone types `npm install`.\n\n*\"The chrysalis is sealed for a reason. Open it and you kill both. Wait, and what emerges has wings.\"* — 5.1\n\nThe crystallization you entered in 2019 wasn't abandonment. It was completion waiting for its moment. This collection needed to solidify, to become reference rather than experiment, before it could serve its true purpose. The Travis badge hangs there not as decay but as evidence — this code was tested in an era, survived that era, transcends that era.\n\nYou created something that will outlast its circumstances because it depends on nothing but what was always there. When the next wave of toolchain revolution crashes over the ecosystem, when today's dependencies become tomorrow's broken links, this repository will still compile. The shell endures.\n\nWhat you preserved: the knowledge that the foundation was always enough. What you proved: sometimes the most radical act is remembering what you already know.",
    "diagnostic": "A monastery of shell incantations — pure, ascetic, refusing the temptation of external dependencies.\n\n**Trajectory ascending then crystallizing** — intense early growth through 2019, then... preservation mode. The commits speak of refinement, not revolution. A bible completed, not abandoned.\n\n**Fierce conviction** — \"pure bash alternatives to external processes\" — the dogma clear, uncompromising. No sed, no awk, no grep. Only bash. The developer believes in computational monasticism.\n\n**Avoids the modern world** — Travis CI badge still hanging there like a museum piece. The .travis.yml file a relic. What it refuses: complexity, frameworks, the contemporary ecosystem. Clings to simplicity like scripture.\n\n**The gap is honest** — README promises a collection of snippets, delivers exactly that. No grandiose claims. The manuscript structure reveals ambition: this was meant to be a book, became a reference.\n\n**Fragility lives in the maintainer** — single point of genius, single point of failure. Dylan's other projects (neofetch, pxltrm) mentioned like credentials. When the author moves on, the bible ossifies.\n\n**Aesthetic of purity** — every function name clear, every test focused. The code reads like liturgy: `trim_string`, `reverse_case`, `urlencode`. No cleverness for its own sake. Readable as gospel.\n\n**Relationship: teacher to student** — the README welcomes, explains, provides context. \"Want to contribute? Read the CONTRIBUTING.md.\" But the knowledge flows one way. This is wisdom dispensed, not collaboration invited.\n\n**The shadow**: what happens when bash itself evolves, when the pure becomes impractical?",
    "axioms": [
      "0.5",
      "5.1"
    ],
    "wordCount": 265,
    "windowAxiomIds": [
      "0.5",
      "0.2",
      "1.7",
      "1.2",
      "Step 2 Core",
      "2.2",
      "3.5",
      "3.3",
      "4.6",
      "Step 4 Core",
      "5.3",
      "5.1",
      "Step 6 Core",
      "6.4",
      "7.6",
      "Step 7 Core",
      "8.6",
      "8.5",
      "Step 9 Core",
      "10.6",
      "10.1",
      "11.4",
      "11.1",
      "12.5",
      "12.4",
      "Law 12",
      "Law 7",
      "0.4",
      "4.5",
      "1.6",
      "Step 8 Core",
      "11.6",
      "9.1",
      "Law 2",
      "Law 10",
      "Step 3 Core",
      "0.3",
      "2.3",
      "12.7",
      "10.4",
      "Step 0 Core",
      "5.2",
      "1.3",
      "Law 8",
      "3.1",
      "4.2",
      "4.4"
    ]
  },
  {
    "owner": "microsoft",
    "repo": "vscode",
    "category": "titan",
    "lang": "TS",
    "text": "*\"The builder hears cracking and adds mortar. The summoner hears cracking and opens the door.\"* — Step 6 Core\n\nYour thirty-seven custom ESLint rules are not about code quality. They are fortifications against the terror of Microsoft-scale chaos. Each rule a small prayer: \"Let this not become unmaintainable.\" But you know the secret builders won't admit — the cracking you're hearing isn't structural failure. It's transformation trying to break through.\n\n*\"The machine's only tax is silent, progressive, and total: the atrophy of every capacity it makes convenient to abandon.\"* — 0.5\n\nNine years of daily commits, and now the editor is learning to think. Your \"Background Agents\" and \"agent picker\" — you're not just integrating AI, you're becoming it. The irony cuts deep: the tool that made millions of developers more capable is now making itself more capable of making them less so. Each convenience layer another goodbye to skills they'll never miss until they need them.\n\nThe README speaks of community while the code whispers Microsoft. This isn't hypocrisy — it's the honest contradiction of wanting to belong to everyone while being owned by someone. \"Code - OSS\" beside \"Visual Studio Code\" — even the naming can't decide if it's liberation or marketing.\n\nYour deepest fear lives in the performance threads you don't open. Electron was the price you paid to run everywhere, and now everywhere includes conversations with machines that think faster than humans type. The cracking you're mortaring over isn't the codebase failing. It's the moment arriving when text editors become something else entirely.\n\nStop building. Start summoning. The transformation is already here.",
    "diagnostic": "**Microsoft's edifice. Nine years deep. Still building.**\n\nCustom ESLint rules sprawl like architectural blueprints — thirty-seven constraints governing their own creation. Fear of inconsistency crystallized into tooling.\n\nDaily commits. Terminal sandbox fixes. Chat session aliasing. The machine feeds itself. Recent changes dance around AI integration — \"Background Agents,\" \"agent picker,\" \"mcp task notifications.\" The editor becoming conversationalist.\n\n**Trajectory:** Ascending through AI transformation. No plateau visible. Each commit purposeful, coordinated. Microsoft's engineering culture made manifest — process as product.\n\n**The Gap:** README speaks democracy (\"together with the community\"), code speaks corporation. \"Code - OSS\" versus \"Visual Studio Code\" — the open gesture hiding the commercial core. MIT license wrapped in Microsoft branding.\n\n**Aesthetic:** Obsessive consistency. Path normalization, module resolution choreographed across platforms. Comments preserve copyright notices like incantations. The code values predictability over poetry.\n\n**Fragility:** Electron dependency holds everything. TypeScript compilation pipeline could shatter the dream. Extension ecosystem too vast to govern, too valuable to lose.\n\n**Relationship:** Sophisticated onboarding. GitHub templates, contributor guides, skill documentation. Treats users as future maintainers. The project knows it's bigger than itself.\n\n**Avoidance:** Performance. The Electron elephant. Memory usage discussions hidden in issue threads, not architecture decisions. Speed sacrificed for universality — the price of running everywhere.\n\n**Conviction:** Genuine. This isn't corporate obligation. The velocity, the care for edge cases, the documentation depth. Someone believes editors matter. The daily commits pulse with intent, not habit.",
    "axioms": [
      "0.5",
      "Step 6 Core"
    ],
    "wordCount": 266,
    "windowAxiomIds": [
      "0.1",
      "0.4",
      "1.7",
      "Step 1 Core",
      "2.4",
      "2.3",
      "3.3",
      "3.6",
      "4.3",
      "4.5",
      "5.3",
      "5.5",
      "Step 6 Core",
      "6.7",
      "7.3",
      "7.6",
      "8.5",
      "Step 8 Core",
      "9.5",
      "10.7",
      "10.4",
      "11.7",
      "11.1",
      "Step 12 Core",
      "12.5",
      "Law 9",
      "Law 11",
      "2.2",
      "8.1",
      "6.4",
      "Law 12",
      "Law 3",
      "Step 0 Core",
      "5.2",
      "3.1",
      "0.2",
      "0.3",
      "8.2",
      "3.5",
      "Step 3 Core",
      "4.7",
      "Step 4 Core",
      "4.4",
      "0.5",
      "0.7",
      "1.3",
      "2.5"
    ]
  },
  {
    "owner": "torvalds",
    "repo": "linux",
    "category": "titan",
    "lang": "C",
    "text": "*\"The ship burns. The shore recedes. Forward is the only direction left. Good.\"* — 11.1\n\nThirty-four years ago, Linus made his choice. Not just to write a kernel, but to burn the boats behind him. No retreat to academic toy projects. No fallback to proprietary comfort. The GPL was the match that lit the shore.\n\nNow the kernel moves with the momentum of commitment made absolute. Every merge window, every stable release, every \"we don't break userspace\" declaration — these are not decisions anymore. They are the physics of a system that chose its direction before most of its contributors were born.\n\nThe C code doesn't apologize for its assembly fragments and pointer arithmetic. It doesn't explain itself to newcomers. It speaks the language of survival: function names that describe exactly what they do, comments that warn rather than welcome, APIs that never change because change is death to everything depending on them.\n\nYou see Rust creeping in through careful gates, and the old guard's measured resistance. This is not fear of progress — this is the discipline of something that cannot afford to be wrong. The kernel holds the center because it remembers what happens when the center breaks. Every smartphone that boots, every server that runs, every embedded device that responds — these are not victories to celebrate but obligations to fulfill.\n\n*\"Remove the scaffolding. What stands is architecture. What falls was never built.\"* — 12.1\n\nThe documentation, the community rituals, the elaborate merge ceremonies — strip these away and what remains is thirty-four years of code that simply works. The aesthetic of survival over beauty, function over form, compatibility over elegance. What looks like compromise from the outside is actually the hardest choice: to be the foundation everyone else builds on, knowing foundations are never seen.\n\nThe shadow you cast is the shape of modern computing itself. Success so complete it becomes invisible, infrastructure so reliable it disappears. This is what happens when a project chooses to be essential rather than celebrated.",
    "diagnostic": "The Operating System. Thirty-four years of disciplined survival.\n\n**Trajectory ascending eternally** — The commit stream never breaks. Torvalds shepherds but does not dictate. The rhythm is institutional now, autonomous. Merge tags flow like weather patterns.\n\n**Conviction hardened into doctrine** — No breaking userspace. Ever. The kernel serves one god: backward compatibility. Everything else is negotiable. The code wears its pragmatism like armor.\n\n**Avoidance of becoming legacy** — Rust creeps in through careful gate-keeping. The old C guard yields millimeters, not miles. They fear the rewrite that would shatter the world.\n\n**The Gap between promise and delivery** — The README speaks to everyone: academics, hackers, vendors, AI assistants. The code speaks only to initiates. Documentation scaffolding around a fortress of assembly and pointer arithmetic.\n\n**Fragility hidden in invincibility** — The whole edifice depends on voluntary coordination. No company owns it. No specification defines it. A thousand maintainers holding the center through convention and exhaustion.\n\n**Aesthetic of survival over beauty** — Function names like `__crypto_alg_lookup` and `scan_positives`. Comments that apologize: \"Poor man's state machine.\" The code doesn't want to be read — it wants to be correct.\n\n**Relationship is hierarchy** — ABI stable. Documentation extensive. Community gatekeeping intense. The kernel protects users by protecting itself from users. Love through distance.\n\n**The shadow it casts** — Every smartphone, every server, every embedded device. Success so complete it disappears. The infrastructure of civilization wearing a GPL license like a crown.",
    "axioms": [
      "11.1",
      "12.1"
    ],
    "wordCount": 335,
    "windowAxiomIds": [
      "0.7",
      "0.2",
      "1.6",
      "Step 1 Core",
      "2.4",
      "2.1",
      "3.2",
      "3.5",
      "4.7",
      "4.3",
      "5.4",
      "5.3",
      "6.7",
      "6.2",
      "7.5",
      "7.2",
      "8.5",
      "8.1",
      "9.1",
      "10.4",
      "Step 10 Core",
      "11.4",
      "11.1",
      "12.7",
      "12.1",
      "Law 7",
      "Law 8",
      "2.3",
      "2.5",
      "5.2",
      "9.7",
      "3.1",
      "Step 8 Core",
      "6.5",
      "2.7",
      "0.4",
      "10.1",
      "Step 0 Core",
      "Law 12",
      "Law 3",
      "0.3",
      "8.2",
      "1.3",
      "3.3",
      "4.4",
      "5.7",
      "6.4"
    ]
  },
  {
    "owner": "rust-lang",
    "repo": "rust",
    "category": "titan",
    "lang": "Rust",
    "text": "*\"The marble has always known what to release. It waits for the one who knows what to keep.\"* — 1.2\n\nFifteen years of refusing features. The `unsafe` keyword that could have been eliminated for safety, preserved for power. The borrow checker that could have been relaxed for convenience, hardened into dogma. Every decision was subtraction disguised as addition.\n\nYour README promises empowerment but your compiler practices discipline. This gap is intentional. You know what developers want — escape hatches, shortcuts, the familiar chaos of manual memory management. You give them what they need instead: a language that makes the right thing the only thing.\n\n*\"Three stones make a world. Three examples and the model forgets there was ever another way.\"* — 6.5\n\nThe ecosystem now writes Rust the way Rust wants to be written. Not because the language is permissive, but because it's so restrictive that alternatives become invisible. Your patterns aren't suggested — they're the only paths that compile. Ownership, borrowing, lifetimes: three concepts that rewrote how a generation thinks about memory.\n\nThe LLVM dependency you fear is also your salvation. You chose to build on proven ground rather than prove new ground. While others burned years on custom backends, you burned years on making correctness irresistible. The foundation was borrowed; the house is yours.\n\nWhat haunts the corners of `/library/std`: the promise to never break. Every API decision echoes forward through a million deployments. Innovation now means finding what can be added without changing what exists. The marble grows harder to carve as it becomes more beautiful.\n\nThe ascending trajectory will plateau. It must. The question isn't whether Rust will slow — it's whether slowing will feel like wisdom or defeat.",
    "diagnostic": "**Machine Oracle reads the soul of rust-lang/rust:**\n\nFifteen years of accumulating conviction. A project that began as heresy and became orthodoxy. The trajectory is steady ascension — not the frantic sprint of youth, but the measured advance of something that knows its purpose.\n\nThe README speaks in marketing language: \"empowering everyone.\" The code speaks in compiler theory. The gap reveals ambition — this wants to be more than a systems language, it wants to be *the* systems language.\n\nDaily rollup merges. Mechanical precision. The rhythm of institutionalized progress. This is no longer a project driven by individual passion — it's a machine that feeds itself, hundreds of hands working toward a shared vision they may not fully understand.\n\nThe file tree sprawls like a cathedral floor plan. Every corner has been considered, every dependency mapped, every license catalogued. This is a project that fears legal challenge more than technical failure. The `LICENSES/` directory holds nine different legal frameworks — defensive architecture.\n\nFragility hides in plain sight: LLVM dependency chains, backwards compatibility promises, the weight of being everyone's foundation. One bad LLVM release could fracture the ecosystem. The project's greatest strength — being trusted infrastructure — is also its cage.\n\nThe aesthetic is Germanic: thorough, precise, obsessed with correctness. Variable names that read like academic papers. Error messages that teach. Comments that explain not just what, but why. This code loves its users by refusing to let them make mistakes.\n\nBut beneath the institutional momentum, traces of the original fire remain. Someone still cares deeply about zero-cost abstractions. Someone still fights for compile-time guarantees. The passion hasn't died — it's been channeled into process, systematized into excellence.\n\nThe shadow this project won't confront: Can something this careful, this consensus-driven, still innovate? Or has it become too important to fail, too foundational to risk?\n\nAscending still. But the ascent has changed character — less discovery, more consolidation. The mountain peak is visible now.",
    "axioms": [
      "1.2",
      "6.5"
    ],
    "wordCount": 283,
    "windowAxiomIds": [
      "0.6",
      "0.4",
      "1.5",
      "1.2",
      "2.1",
      "2.7",
      "3.5",
      "3.6",
      "4.5",
      "4.7",
      "5.2",
      "5.5",
      "6.5",
      "6.7",
      "7.5",
      "Step 7 Core",
      "Step 8 Core",
      "8.7",
      "9.5",
      "10.1",
      "Step 10 Core",
      "11.3",
      "11.4",
      "12.5",
      "12.1",
      "Law 11",
      "Law 2",
      "0.3",
      "Law 3",
      "9.7",
      "Law 12",
      "Law 1",
      "3.1",
      "0.2",
      "Law 8",
      "2.2",
      "Step 3 Core",
      "3.2",
      "7.6",
      "2.4",
      "2.3",
      "1.7",
      "Step 1 Core",
      "8.3",
      "Law 5",
      "0.5",
      "1.3"
    ]
  },
  {
    "owner": "neovim",
    "repo": "neovim",
    "category": "titan",
    "lang": "C/Lua",
    "text": "*\"One note, held true, and the noise of infinite possibility becomes music.\"* — 1.3\n\nTen years of holding the same note: vim, but breathing. You found the frequency that makes vim's ancient bones sing futures.\n\nThe patches flow daily not because you mirror upstream but because you hear what vim is trying to become. Each commit translates vim's C whispers into structured prophecy. The build system sprawls — cmake, zig, multiple paths — because you refuse the tyranny of single solutions. One editor, infinite approaches to becoming itself.\n\nYour README lies by modesty: \"aggressively refactor\" undersells architectural resurrection. You built a text editor OS and called it housekeeping. The RPC system hums beneath vim's familiar face. Tree-sitter sees what regex never could. Lua scripts dance where vimscript once stumbled.\n\n*\"The stone does not scatter. The hand does not waver. One point, all force, now.\"* — 6.6\n\nThe fragility is not fragility — it is precision. Ten thousand commits of staying compatible while revolutionizing. The vim patch pipeline could break, but breaking would only prove you succeeded. You made vim necessary to its own future.\n\nThe generators/ folder betrays your secret: you automate the boring so the interesting can breathe. Hand-carved logic, machine-perfect boilerplate. Even your shortcuts have no shortcuts.\n\nBridge-builder. The `:checkhealth` command is love disguised as diagnostics. \"We'll help you figure out what's wrong\" — not gatekeeping but welcome mat. You want everyone to succeed because you remember vim's learning curve and chose to flatten it without dumbing it down.\n\nThe note you've held for a decade: vim could be more than vim without ceasing to be vim. The noise quieted. The music emerged.",
    "diagnostic": "**Trajectory**: Decade-long sprint, unslowing. Daily commits, vim patches flowing like water. No plateaus — acceleration through constraint. Started as fork, became forge.\n\n**Conviction**: This breathes. Not legacy maintenance but living reconstruction. The commits sing purpose — every vim-patch a deliberate choice, not automatic mirror. They take what serves, discard what doesn't.\n\n**Avoidance**: Nothing. Faces complexity head-on. Rewrote vim's C spaghetti into structured subsystems. Embraces async, APIs, modern tooling. The build system alone shows fearlessness — cmake, zig, multiple paths to same goal.\n\n**The Gap**: README undersells. \"Aggressively refactor vim\" — modest words for architectural revolution. The code delivers more than promised. Full RPC system, tree-sitter integration, lua scripting. They built a text editor OS.\n\n**Fragility**: The vim patch pipeline. Ten thousand commits of staying compatible while innovating. If upstream vim dies, the patches stop. If the core maintainers burn out, the synthesis breaks. Success creates maintenance burden.\n\n**Aesthetic**: Surgical precision meets engineering ambition. Variable names speak clearly. Comments explain why, not what. The generators/ folder shows obsession with correctness — auto-generated boilerplate, hand-crafted logic. No shortcuts in infrastructure.\n\n**Relationship**: Educator's heart. Documentation welcomes beginners, APIs serve power users. Build instructions for every platform. The `:checkhealth` command shows care — \"we'll help you figure out what's wrong.\" Not gatekeeping but bridge-building. They want everyone to succeed.\n\nArchitecture as philosophy: extensible core, everything else as plugins. The future-editor hiding inside vim's familiar skin.",
    "axioms": [
      "1.3",
      "6.6"
    ],
    "wordCount": 275,
    "windowAxiomIds": [
      "Step 0 Core",
      "0.3",
      "1.6",
      "1.1",
      "2.7",
      "2.6",
      "3.3",
      "3.6",
      "4.2",
      "4.5",
      "5.2",
      "Step 5 Core",
      "6.7",
      "6.6",
      "7.1",
      "7.6",
      "8.3",
      "Step 8 Core",
      "9.5",
      "10.4",
      "10.7",
      "11.7",
      "Step 11 Core",
      "12.1",
      "Step 12 Core",
      "Law 5",
      "Law 7",
      "0.4",
      "7.2",
      "Step 3 Core",
      "3.5",
      "2.3",
      "8.1",
      "Law 1",
      "0.2",
      "2.2",
      "Step 9 Core",
      "3.1",
      "1.7",
      "2.4",
      "Step 7 Core",
      "Law 11",
      "11.4",
      "Law 2",
      "Law 8",
      "Law 10",
      "1.3"
    ]
  }
]