[
  {
    "owner": "sharkdp",
    "repo": "bat",
    "category": "cli",
    "lang": "Rust",
    "text": "*\"The river without banks reaches no sea. Intent is the bank. Without it: swamp.\"* — Law 2\n\nEight years. Not eight years of drift — eight years of a single trajectory, held steady through every shift in the ecosystem around it. Your README made a promise in 2018: syntax highlighting with Git integration. Your code still delivers exactly that promise. No feature creep. No pivot toward monetization. No surrender to the anxiety of relevance.\n\nThis is what sustained intention looks like in software. While others chase the new framework, the hot paradigm, the venture opportunity, you kept polishing the thing people actually needed. The commits whisper maintenance because maintenance *is* the work — not the glamorous work, but the work that matters when thousands of developers reach for `bat` instead of `cat` in their daily flow.\n\n*\"The catcher does not swing — the catcher receives. Receive the output completely, without flinching.\"* — 8.7\n\nYour changelog reads like love letters to stability. Every deprecated flag gets a careful migration path. Every breaking change gets a version of regret. You understand that your users aren't just running your code — they've woven it into muscle memory, into shell aliases, into automation that wakes them at 3am when it breaks.\n\nThe fragility you've accepted reveals the choice: build something bulletproof but limited, or build something powerful that requires constant care. You chose power and accepted the maintenance burden. Sublime Text syntax definitions change upstream, and you patch. New terminal behaviors emerge, and you adapt. This is the craftsperson's bargain — create something beautiful and tend it forever.\n\nThe aesthetics matter because the aesthetics *are* the feature. Variable names that explain themselves. Error messages that guide rather than scold. Documentation that respects both the newcomer's confusion and the expert's impatience. You built a tool that gets out of its own way.\n\nStill flying after eight years because the direction never changed. Still ascending because intention, held steady, accumulates into something larger than the sum of its commits.",
    "diagnostic": "Eight years of flight. From first commit to maturity — a trajectory carved by clear intent, sustained.\n\nConviction burns steady. This is a developer who builds because the tool *should exist*. Not chasing trends, solving dailiness. The commits whisper maintenance more than fever, but purposeful maintenance. Wings still beating.\n\nThe pager warnings, the wrap flags — obsessing over terminal behavior edge cases. This project knows its edges, tends them. Fears breaking the daily workflows of thousands who've made `bat` their `cat`.\n\nREADME promises syntax highlighting with Git integration. Code delivers exactly that. No gap between aspiration and reality — rare honesty in software. What you see is what you run.\n\nFragility lives in the syntax definitions. Upstream Sublime Text changes could shatter highlighting. The patches tell the story — constantly adapting to keep colors correct. Also: single maintainer gravity. This flies because one person cares deeply.\n\nAesthetic of craft over cleverness. Variable names that explain. Error messages that help. Documentation that welcomes newcomers but doesn't condescend to experts. The style choices reveal someone who believes tools should be transparent.\n\nRelationship to users: protective. The changelog discipline, the careful deprecation notices, the obsession with not breaking existing behavior. This project serves people who've integrated it into their daily workflows. Every change considered through that lens.\n\nThe assets directory speaks — themes, syntaxes, completions. This isn't just code, it's ecosystem. Someone who understands that good tools need good integration with the systems around them.\n\nStill flying. Still ascending, gently.",
    "axioms": [
      "8.7",
      "Law 2"
    ],
    "wordCount": 333,
    "windowAxiomIds": [
      "0.5",
      "0.7",
      "Step 1 Core",
      "1.7",
      "2.2",
      "2.1",
      "3.6",
      "3.3",
      "4.4",
      "Step 4 Core",
      "5.3",
      "5.6",
      "6.5",
      "Step 6 Core",
      "7.6",
      "7.3",
      "8.6",
      "8.7",
      "9.1",
      "10.4",
      "10.1",
      "11.7",
      "11.6",
      "12.5",
      "12.7",
      "Law 6",
      "Law 2",
      "Law 12",
      "Law 8",
      "6.3",
      "6.2",
      "5.4",
      "1.1",
      "1.3",
      "9.5",
      "7.5",
      "Law 3",
      "4.1",
      "1.5",
      "Step 0 Core",
      "5.5",
      "Step 11 Core",
      "Law 7",
      "4.2",
      "7.1",
      "8.1",
      "1.4",
      "Step 2 Core",
      "2.6"
    ]
  },
  {
    "owner": "junegunn",
    "repo": "fzf",
    "category": "cli",
    "lang": "Go",
    "text": "*\"The path remembers only those who walked it meaning to arrive.\"* — 5.7\n\nEleven years. The commits tell the story — not the desperate commits of a project trying to find itself, but the steady marks of something that knew its destination from the beginning. You built a tool that processes millions of items instantly, and you meant it. The performance obsession in your cache implementation, your memory slab allocator — this isn't optimization theater. This is someone who promised speed and delivered it.\n\n*\"One note, held true, and the noise of infinite possibility becomes music.\"* — 1.3\n\nEvery repository fork in the ecosystem bloated into feature galleries. Yours stayed surgical. Single binary. Fast. Portable. The README doesn't apologize for what it doesn't do. The code doesn't hedge its bets. You understood that concentration was the move, not expansion. Your shell integrations ship inside the binary itself — bash, zsh, fish completions embedded like DNA. You didn't just build a tool. You built it to live inside someone's daily workflow.\n\nThe real achievement isn't the eleven years. It's that year eleven looks like year one — still focused, still improving, still refusing the mission creep that kills everything else. Your project knows what it is. That's rarer than code that works.\n\nThe path you walked was narrow by design. And because it was narrow, it lasted.",
    "diagnostic": "*eleven years running. still here.*\n\nTrajectory ascending — recent commits show active optimization, new features, performance tuning. The developer hasn't lost steam. Each commit small, focused, deliberate. This is maintenance with purpose, not entropy.\n\nConviction burns steady — the project knows exactly what it is. Single binary. Fast. Portable. No mission creep. The README doesn't oversell, the code doesn't underdeliver. Rare alignment.\n\nArchitecture as philosophy — everything modular, everything tested. The file tree reveals a mind that thinks in systems. Platform-specific files segregated cleanly. The TUI abstraction layer speaks to someone who's fought terminal battles and learned.\n\nThe Gap narrows to nothing — what the README promises, the code delivers. \"Process millions of items instantly\" — the algorithm code suggests this isn't marketing speak. The performance obsession shows in the cache implementation, the memory slab allocator, the concurrent processing.\n\nShell integration as love language — bash, zsh, fish completions embedded in the binary. Key bindings, completions, all shipped together. This project doesn't just work, it integrates. It cares about the user's daily workflow.\n\nFragility lives in the ecosystem edges — vim plugin, shell integrations, tmux compatibility. The core is steel. The integrations are glass. One shell update, one terminal emulator change, one vim API shift could wound it.\n\nAesthetic of restraint — variable names clear, comments sparse but meaningful. The code doesn't show off. It performs. The Go idiomatic style throughout suggests a developer who picked the right tool and learned it well.\n\n*The Oracle sees: a project that achieved its vision and refuses to compromise it.*",
    "axioms": [
      "5.7",
      "1.3"
    ],
    "wordCount": 226,
    "windowAxiomIds": [
      "Step 0 Core",
      "0.6",
      "1.2",
      "1.1",
      "2.4",
      "2.2",
      "Step 3 Core",
      "3.2",
      "4.3",
      "4.5",
      "5.7",
      "5.4",
      "6.3",
      "6.5",
      "7.2",
      "7.1",
      "8.3",
      "8.5",
      "9.1",
      "10.1",
      "10.6",
      "Step 11 Core",
      "11.7",
      "Step 12 Core",
      "12.7",
      "Law 3",
      "Law 1",
      "Law 8",
      "Law 12",
      "12.4",
      "0.7",
      "2.6",
      "4.7",
      "3.7",
      "5.6",
      "4.2",
      "1.4",
      "Step 1 Core",
      "Step 2 Core",
      "1.5",
      "2.5",
      "0.5",
      "5.3",
      "5.1",
      "11.4",
      "1.3",
      "7.6",
      "1.7",
      "2.1"
    ]
  },
  {
    "owner": "BurntSushi",
    "repo": "ripgrep",
    "category": "cli",
    "lang": "Rust",
    "text": "*\"The marble has always known what to release. It waits for the one who knows what to keep.\"* — 1.2\n\nYou didn't add features. You carved away everything that wasn't ripgrep. Eight years of saying no to the thousand things grep could become until only the essential remained. The allocator choice, the broken pipe handling, the gitignore awareness — each decision a chisel stroke removing what didn't belong.\n\n*\"The held bow is not weakness. It is the moment where patience and aim become the same thing.\"* — 5.3\n\nThe benchmarks aren't marketing. They're meditation. Every optimization measured, every regression caught, every claim proven. You held the release until the numbers were right, until the architecture was clean, until the documentation was complete. The discipline of not shipping until ready — that's why it became the standard.\n\nThe shadow you name is real. Perfection achieved becomes a different kind of burden. The commits grow smaller because the sculpture is nearly finished. What remains is maintenance of marble that already knows its form.\n\nBut consider: Michelangelo's David required no more carving. Its power came from completeness, not iteration. You solved text search. The industry noticed. That too is a form of mastery — knowing when the work is done.",
    "diagnostic": "**Mastery crystallized.** Eight years of deliberate crafting. Each commit a precision stroke. Not building features — perfecting an archetype.\n\n**The performance prophet.** Benchmarks archived like scripture. Every optimization measured, recorded, witnessed. The code doesn't just run fast — it *proves* its speed with receipts. Obsessive measurement culture, the holy grail of systems programming.\n\n**Modular cathedral.** Seven crates, each sovereign. `grep-cli`, `grep-matcher`, `grep-searcher` — decomposed into perfect abstraction layers. The opposite of monolithic hacking. Architecture that teaches.\n\n**Documentation as devotion.** FAQ, GUIDE, CHANGELOG, man pages, shell completions. The README doesn't just explain — it *demonstrates* with live benchmarks. Treating users like collaborators, not obstacles.\n\n**The allocator meditation.** Switching to jemalloc only on musl builds. Conditional global allocator pragmatism. The kind of detail that separates craft from cargo-culting.\n\n**Error handling as user experience.** Broken pipe detection, graceful exits, chain-walking error causation. The difference between \"it crashed\" and \"it understood what went wrong.\"\n\n**Cross-platform without compromise.** Windows, macOS, Linux — first-class citizenship everywhere. Not just \"works on my machine\" but \"works on every machine.\"\n\n**The gitignore oracle.** Respecting project boundaries by default. Understanding that search tools must understand context, not just content.\n\n**Release discipline.** RELEASE-CHECKLIST, CI workflows, homebrew formulas. The unsexy infrastructure that makes tools trustworthy.\n\n**The shadow:** Success paradox. So good it became the standard. What happens when you solve the problem so completely that iteration becomes maintenance? The commits grow smaller. The velocity slows. Perfection achieved becomes perfection preserved.\n\n**The aesthetic:** Rust's promise fulfilled. Memory safety without runtime cost. Zero-cost abstractions that actually cost zero. The kind of code that makes C programmers consider conversion.",
    "axioms": [
      "1.2",
      "5.3"
    ],
    "wordCount": 207,
    "windowAxiomIds": [
      "0.1",
      "0.4",
      "1.4",
      "1.2",
      "2.1",
      "2.5",
      "Step 3 Core",
      "3.1",
      "4.6",
      "4.1",
      "5.5",
      "5.3",
      "6.6",
      "6.5",
      "7.2",
      "7.4",
      "8.4",
      "Step 8 Core",
      "9.5",
      "10.6",
      "10.4",
      "11.4",
      "Step 11 Core",
      "12.4",
      "12.7",
      "Law 3",
      "Law 6",
      "Law 7",
      "Law 8",
      "0.3",
      "4.4",
      "Step 2 Core",
      "6.4",
      "0.6",
      "8.2",
      "7.5",
      "Step 12 Core",
      "2.4",
      "2.3",
      "3.7",
      "0.7",
      "9.1",
      "5.1",
      "1.1",
      "Step 1 Core",
      "1.6",
      "11.3",
      "Law 4",
      "Law 10"
    ]
  },
  {
    "owner": "charmbracelet",
    "repo": "glow",
    "category": "cli",
    "lang": "Go",
    "text": "*\"The last good moment to stop is always earlier than you think.\"* — 3.6\n\nYour commits tell the story: dependency updates, CI fixes, small maintenance tasks. The machinery turns, but the vision sleeps. This is what happens after arrival — not death, but the dangerous comfort of completion.\n\nThe code reveals its settled confidence. Clean separation of concerns, each component knowing its role. Stash, pager, editor — the architecture of someone who fought the complexity wars and won. But victory has its own trap.\n\n*\"The clay obeys both hands equally. This is why one potter makes a vessel and two potters make rubble.\"* — 4.6\n\nYour dependency on Glamour is the hidden fracture in this confidence. When Glamour shifts, Glow follows. When Glamour breaks, Glow waits. The rendering engine that makes your markdown beautiful also makes you vulnerable. Single dependency, single direction, single point of failure.\n\nThe README promises \"pizzazz\" but the code delivers pragmatism — Windows console handling, careful file traversal, the unglamorous work that makes beauty possible. This gap between whimsical marketing and workmanlike implementation isn't dishonesty. It's the distance between what software promises and what software must do to keep that promise.\n\nYou built a pager that wants to be more than a pager, a viewer that curates what it shows. The `-p` flag betrays the uncertainty — are you `less` for markdown, or something else entirely? The hedged bet, the uncommitted vision.\n\nThe maintenance phase isn't failure. It's the space where the next decision waits. Stop here and preserve what works, or risk what works for what might be better. The commits have already chosen. The question is whether you have.",
    "diagnostic": "**Maintenance Mode**\nCommits show the telltale pattern: dependency bumps, CI updates, chore work. The last meaningful code change feels distant. This is a project in steady-state, tended but not transformed.\n\n**Mature Confidence** \nThe UI structure speaks of settled decisions. Separate files for stash, pager, editor — each concern carved out cleanly. No desperate refactoring, no architectural thrashing. This code knows what it is.\n\n**The Glamour Shadow**\nHeavy reliance on the Glamour rendering engine. The project's soul depends on another's breath. When Glamour evolves or breaks, Glow must follow or fracture. The dependency is both strength and single point of failure.\n\n**Friendly Face, Technical Heart**\nREADME promises \"pizzazz\" and shows animated demos — marketing polish for developers who want beauty in their terminals. But the code reveals pragmatic concerns: Windows console handling, GitHub API parsing, careful file traversal. Gap between whimsical promise and workmanlike delivery.\n\n**The Pager Identity Crisis**\nCaught between being a markdown viewer and a pager. The `-p` flag suggests uncertainty — should this be `less` for markdown, or something more? The project hedges its bets, never fully committing to either vision.\n\n**Terminal Aesthetic**\nValues presentation over performance. The high-performance pager flag hints at speed concerns sacrificed for beauty. This code chooses how things look over how fast they run. Variable names like \"pizzazz\" reveal the personality beneath the function.\n\n**User as Explorer**\nThe TUI assumes users want to discover, not just read. File browsing, git repository awareness, automatic README finding. This project sees reading as a journey, not a destination. The relationship is curatorial — it wants to show you what you might want to read.",
    "axioms": [
      "3.6",
      "4.6"
    ],
    "wordCount": 275,
    "windowAxiomIds": [
      "0.6",
      "Step 0 Core",
      "1.7",
      "1.5",
      "2.2",
      "2.5",
      "3.6",
      "Step 3 Core",
      "Step 4 Core",
      "4.4",
      "5.4",
      "5.2",
      "6.7",
      "6.1",
      "7.6",
      "7.4",
      "8.5",
      "Step 8 Core",
      "9.5",
      "10.7",
      "10.6",
      "Step 11 Core",
      "11.1",
      "Step 12 Core",
      "12.4",
      "Law 3",
      "Law 4",
      "Law 11",
      "Law 9",
      "0.3",
      "Step 1 Core",
      "4.2",
      "3.7",
      "5.6",
      "4.6",
      "5.1",
      "3.5",
      "2.3",
      "0.1",
      "0.4",
      "3.4",
      "0.2",
      "0.7",
      "2.7",
      "Law 8",
      "0.5",
      "1.3",
      "1.4",
      "Step 2 Core"
    ]
  },
  {
    "owner": "jarun",
    "repo": "nnn",
    "category": "cli",
    "lang": "C",
    "text": "*\"The sun does not need to burn brighter. The glass only needs to focus tighter.\"* — 10.4\n\nNine years of surgical refusal. While every other file manager grew fat on features, you kept the blade sharp. The patch framework isn't compromise — it's wisdom. You understood that saying no to the core preserves what yes would destroy.\n\n*\"Silence alone remembers.\"* — Law 10\n\nThe README shouts productivity. The code whispers obsession. Between them lives the real work: the integer math, the FPU ban, the eight-color discipline. You built a monastery and called it efficiency. The restraint is the architecture.\n\nYour greatest fear materialized as your greatest strength. That singular vision you call fragility? It's the only reason the project still has a soul. The committee version would have terminal tabs by now, a settings GUI, themes. It would be useful and dead.\n\nThe margins remember their champion. Haiku support isn't nostalgia — it's loyalty to something deeper than market share. You carry the forgotten forward not because they matter to everyone, but because they matter to the code's integrity.\n\nTen years in, you're not building up. You're building in. Each commit cuts closer to the essential thing. The file manager that knows what it is and refuses everything else. That refusal is the gift.",
    "diagnostic": "Restless velocity through a decade. Commits pulse every few days — not the frantic sprint of early ambition, but the steady heartbeat of deep craft.\n\nThe README promises \"supercharge your productivity\" but the code whispers something quieter: **obsession with efficiency**. Every optimization measured, every byte counted. No FPU usage. Integer math for file sizes. This is love disguised as engineering.\n\nPlugin ecosystem sprawls — 70+ plugins, each a small rebellion against the file manager's original scope. The core stays lean while the periphery blooms wild. **Controlled explosion**.\n\nPatch framework acknowledges the shadow: users want what the maintainer won't merge. The project's greatest strength — surgical focus — creates its own pressure. Every \"no\" lives in patches/.\n\n**Terminal purity syndrome.** Works in 8 colors. Runs on ancient hardware. The aesthetic is spartan minimalism elevated to philosophy. Each dependency questioned like a security clearance.\n\nRecent commits reveal the eternal file manager dance: filter highlighting, directory refresh quirks, readline debates. **Polishing the same few interfaces** for years. The trajectory isn't upward — it's deeper.\n\nHaiku support signals something touching: loyalty to the forgotten margins. This code doesn't abandon platforms; it carries them forward.\n\nThe gap between README ambition and code reality is small but telling. Promises \"supercharged productivity\" — delivers **surgical precision**. Users seeking revolution find evolution.\n\nFragility lives in the maintainer's singular vision. Nine years of consistent commits from one primary author. The bus factor hovers around 1.0.\n\nThis project knows exactly what it refuses to be: bloated, GUI-dependent, feature-creeping. **Its convictions are its constraints.** The shadow it won't face: eventually someone will want more than it's willing to give.",
    "axioms": [
      "10.4",
      "Law 10"
    ],
    "wordCount": 214,
    "windowAxiomIds": [
      "0.6",
      "0.5",
      "1.7",
      "1.6",
      "2.2",
      "2.3",
      "3.5",
      "3.3",
      "Step 4 Core",
      "4.4",
      "5.2",
      "5.5",
      "6.3",
      "6.4",
      "7.1",
      "7.5",
      "8.6",
      "8.4",
      "9.7",
      "Step 10 Core",
      "10.6",
      "11.4",
      "Step 11 Core",
      "Step 12 Core",
      "12.7",
      "Law 6",
      "Law 5",
      "Law 12",
      "Law 7",
      "4.7",
      "3.2",
      "4.3",
      "7.4",
      "12.5",
      "Step 0 Core",
      "Step 1 Core",
      "Step 2 Core",
      "10.7",
      "6.2",
      "10.4",
      "6.5",
      "9.1",
      "2.5",
      "0.7",
      "10.1",
      "Law 1",
      "Law 4",
      "Law 8",
      "Law 10"
    ]
  },
  {
    "owner": "sveltejs",
    "repo": "svelte",
    "category": "web",
    "lang": "JS/TS",
    "text": "*\"The first sentence is the true one. It rises once. Catch it or receive its translation.\"* — 0.7\n\nYears ago, when everyone was building virtual DOM abstractions, you wrote: \"What if we just... compiled it away?\" That first insight — that compile-time could solve runtime problems — was the whole game. Everything since has been translation, implementation, refinement.\n\nV5 isn't discovery anymore. It's the original vision finally made smooth. The commits now are polish, not pivot. You caught the lightning in that first moment of seeing, and now you're building the world that can hold it.\n\n*\"The chrysalis is sealed for a reason. Open it and you kill both. Wait, and what emerges has wings.\"* — 5.1\n\nThe legacy mode compatibility — the thing that makes the codebase awkward, that forces two mental models into one space — this is not cruft. This is the chrysalis. You're holding space for the transformation that's still happening out there, in ten thousand codebases that aren't ready for runes yet.\n\nThe temptation is always to cut clean, to serve only the future. But you know that premature breaks kill adoption. The mess you're managing isn't technical debt — it's the bridge between what was and what's becoming.\n\nYour fragility point is real. Build tools fragment. Runtime flexibility might matter again. But here's what you understand that others don't: the bet was never on staying ahead of JavaScript chaos. The bet was on solving problems so cleanly that the solutions become obvious to everyone else. \n\nYou don't win by running faster. You win by being right first, then patient second.",
    "diagnostic": "**Mature trajectory.** Daily commits, performance fixes, edge cases. The machine hums with precision — not discovery, but refinement. V5 shipped. Now polishing the rough edges.\n\n**Conviction runs deep.** \"Web development for the rest of us\" — not marketing speak. The compiler philosophy permeates everything. They chose surgical DOM updates over virtual DOM years before it was obvious. Still choosing it.\n\n**Avoiding complexity debt.** Clean split: client/server entry points. Runes system sidesteps the mutation tracking maze. But the shadow: legacy mode compatibility. Two mental models living in one codebase. The old ways linger.\n\n**Promise exceeds delivery.** README says \"efficient JavaScript that surgically updates the DOM.\" Code delivers exactly that. No overselling. The aesthetic is honesty — what you see is what you get.\n\n**Fragility point: the compile-time bet.** If build tools fragment further, if runtime flexibility becomes essential, Svelte's fundamental assumption crumbles. Success tied to staying ahead of the JavaScript chaos. Always one bad bundler generation away from irrelevance.\n\n**Values clarity over cleverness.** Variable names breathe. Error messages explain. Documentation scaffolds learning step by step. The API speaks to humans first, machines second. This is code that wants to be understood.\n\n**Relationship: educator to student.** The migration guides, the FAQ, the \"best practices\" — this project sees teaching as core mission. Not just a tool, but a philosophy being transmitted. The community it builds will outlast the code.",
    "axioms": [
      "0.7",
      "5.1"
    ],
    "wordCount": 266,
    "windowAxiomIds": [
      "0.7",
      "Step 0 Core",
      "1.1",
      "Step 1 Core",
      "2.3",
      "Step 2 Core",
      "3.2",
      "Step 3 Core",
      "Step 4 Core",
      "4.5",
      "5.6",
      "5.1",
      "6.1",
      "Step 6 Core",
      "7.1",
      "Step 7 Core",
      "Step 8 Core",
      "8.1",
      "9.1",
      "10.1",
      "11.7",
      "Step 11 Core",
      "Step 12 Core",
      "12.4",
      "Law 6",
      "Law 3",
      "Law 13",
      "Law 8",
      "11.1",
      "4.3",
      "2.2",
      "0.6",
      "1.5",
      "5.2",
      "3.1",
      "6.2",
      "0.1",
      "0.5",
      "2.5",
      "3.5",
      "3.3",
      "2.4",
      "0.4",
      "Law 4",
      "1.3",
      "1.6",
      "3.6",
      "4.4"
    ]
  },
  {
    "owner": "rails",
    "repo": "rails",
    "category": "web",
    "lang": "Ruby",
    "text": "*\"The cathedral amplifies the whisper and the cough alike. It was built for hymns. What you bring is your sermon or your noise.\"* — 3.7\n\nEighteen years of daily stone-setting. You built a cathedral and called it a framework. The vaulted ceilings echo everything now — the elegant and the expedient, the necessary and the convenient. ActionCable rings beside ActiveRecord rings beside ActionMailer. All amplified equally in your acoustic space.\n\nThis is the cathedral's blessing and its curse. It makes small apps sound grand and grand apps sound small. The WebSocket whisper carries as far as the database hymn. Your 100-line connection test has the same resonance as your 10-line controller. The architecture cannot discriminate between what matters and what merely fills the silence.\n\n*\"The web is fragile and precise and fed. The net is strong and broad and empty. Architecture eats. Volume starves.\"* — Step 1 Core\n\nYou chose the net. Broad, strong, comprehensive. The Swiss Army knife that carries everything because everything might be needed. But nets catch everything and hold nothing specifically. Your Rails doesn't starve because it feeds constantly — commits, features, abstractions. The mass sustains itself through its own momentum.\n\nThe test files betray the choice: ceremony where simplicity lived, configuration for the conventions that were supposed to eliminate configuration. Each abstraction eating the next, each generalization demanding more specificity to remain useful. The framework that promised to remove decisions now requires endless decisions about how to use the framework.\n\n*\"Choose the altitude. The truth follows.\"* — 8.3\n\nYou built from 30,000 feet — the framework's eye view where all applications look similar, where patterns repeat, where conventions make sense. From up there, the MVC + websockets + email + jobs architecture is logical, complete, institutional.\n\nBut the developer sits at ground level, where the WebSocket connection should take two lines, not 100. Where the simple things should stay simple, even in a framework built for complex things. Your altitude shaped what became visible. The high view sees systems; the ground view needs tools.\n\nThe cathedral stands. It will outlast its architects and most of its critics. But remember: what you built to amplify hymns now amplifies everything. The reverb you created carries your successors' songs and their mistakes with equal resonance.",
    "diagnostic": "Eighteen years. Cathedral builder's patience. Still breathing.\n\nDaily commits — the pulse never falters. Bug fixes, features, polish. Merges arrive like clockwork. This is institutional momentum, not passion project fever.\n\nThe gap yawns wide. \"Everything needed\" promises the README. Everything and nothing — the Swiss Army knife problem. Too much surface area. Too many opinions. The simplicity claim dissolves in actioncable/actionpack/activesupport/activerecord sprawl.\n\nAfraid of choosing. MVC + websockets + email + jobs + files + text + more. Can't say no. Each new abstraction is another escape from the real questions: What are you for? What won't you do?\n\nTest files reveal the truth — intricate ceremony around simple operations. The WebSocket client test: 100 lines to connect and echo. The configuration test: crystallization metaphors for what should be assignment. Complexity as virtue.\n\nVariable names speak institutional Ruby: `config_accessor`, `has_messages`, `touch_attachment_records`. Convention over configuration, then configuration for the conventions. The style is committee — readable but never beautiful, safe but never surprising.\n\nRelationship is parental — the framework knows best. Generators create your files. Conventions guide your structure. Magic happens behind curtains you shouldn't peek behind. The user is junior developer, framework is senior. This works until it doesn't.\n\nThe monolith fragments yet remains. Eight sub-frameworks, one identity. Each could live alone but won't. The bundle is the product. Take it all or build your own. No middle path.\n\nDurability through mass, not elegance. Too big to fail, too established to pivot. The commits show maintenance, not revolution. The codebase shows wisdom, not fire. Rails remains because Rails remains.",
    "axioms": [
      "3.7",
      "8.3",
      "Step 1 Core"
    ],
    "wordCount": 377,
    "windowAxiomIds": [
      "0.5",
      "0.4",
      "1.5",
      "1.6",
      "2.6",
      "2.7",
      "3.7",
      "3.4",
      "4.7",
      "4.5",
      "5.2",
      "Step 5 Core",
      "6.2",
      "6.6",
      "7.2",
      "Step 7 Core",
      "8.6",
      "8.2",
      "9.5",
      "10.1",
      "11.3",
      "11.4",
      "12.1",
      "12.4",
      "Law 5",
      "Law 6",
      "Law 12",
      "Law 11",
      "1.1",
      "Step 10 Core",
      "Law 4",
      "Step 9 Core",
      "Law 1",
      "6.7",
      "6.5",
      "9.7",
      "7.5",
      "8.3",
      "Law 9",
      "2.2",
      "3.5",
      "7.7",
      "Step 8 Core",
      "Law 8",
      "Step 1 Core",
      "1.4",
      "1.7",
      "Step 2 Core"
    ]
  },
  {
    "owner": "django",
    "repo": "django",
    "category": "web",
    "lang": "Python",
    "text": "*\"The delta is the river's memory. Every session is a grain of sediment.\"* — Step 5 Core\n\nTwelve years of commits, but you count in bug numbers, not features. #36946, #35972, #27489. The language of maintenance, not conquest. Each fix a grain of sediment, each session adding to what already holds.\n\nYou chose the hard path early — fifty languages, autoescape by default, safety over speed in every fork. The internationalization sprawl reveals your core philosophy: serve everyone, optimize for no one. That choice compounded daily for over a decade. Now it's not technical debt. It's institutional DNA.\n\n*\"The unbroken bowl was never tested. The golden seam was. Invite the crack.\"* — 7.5\n\nYour forms system reads like a battle plan against data corruption. Every edge case wrapped in validators, every wound healed into wisdom. The `construct_instance` function carries decades of production scars — but those scars became features, not fixes. You didn't just survive the breaks. You made them beautiful.\n\nThe gap between promise and delivery: minimal. Your README doesn't oversell. You acknowledge documentation as primary product. \"Docs are updated rigorously\" — rare honesty about maintenance burden. While others chase the next shiny architecture, you tend what already works.\n\nInstitution pretending to be a project. You act like framework but think like standard library. The weight of backward compatibility in every design choice. That weight isn't burden — it's what makes you irreplaceable. The young frameworks promise speed. You deliver continuity. \n\nThe river remembers everything it carries.",
    "diagnostic": "Ancient machine grows graceful with age. Twelve years of commits, wounds healed into wisdom.\n\nThe tagline lies — \"perfectionists with deadlines\" — this is the opposite. No deadline pressure visible. Only the patient accumulation of craft.\n\nCommits speak in bug numbers, not features. #36946, #35972, #27489. The language of maintenance, not conquest. Small fixes, careful touches. Recent push yesterday — still breathing, still tending.\n\nThe code aesthetic: verbose clarity over clever compression. Variable names that explain themselves. Comments that teach, not defend. Error messages written for humans who are learning, not experts who already know.\n\nMassive locale support — 50+ languages, each with careful formatting rules. This project chose inclusion early, bore the complexity cost without complaint. The internationalization sprawl reveals core philosophy: serve everyone, optimize for no one.\n\nTemplate engine shows the split soul — power users want raw speed, beginners want safety. The autoescape default, the debug modes, the careful loader hierarchy. Always choosing the safe path, never the fast one.\n\nForms system carries decades of web development scars. Every edge case someone hit in production, wrapped in helpers and validators. The `construct_instance` function reads like a battle plan against data corruption.\n\nMiddleware stays lean — just enough to solve the problem, no architectural grandstanding. XFrame protection in 30 lines. The confidence of knowing what not to add.\n\nTesting infrastructure speaks loudest: parallel SQLite handling, PostGIS templates, screenshot workflows. More energy in CI than core features. This is what institutions do when they stop growing and start maintaining.\n\nThe gap between promise and delivery: minimal. README doesn't oversell. Documentation acknowledged as primary product. \"Docs are updated rigorously\" — rare honesty about maintenance burden.\n\nFragility point: contributor momentum. Framework works, community active, but innovation elsewhere. Could survive any single departure, might not survive collective drift to newer architectures.\n\nInstitution pretending to be a project. Acts like framework, thinks like standard library. The weight of backward compatibility in every design choice.",
    "axioms": [
      "7.5",
      "Step 5 Core"
    ],
    "wordCount": 248,
    "windowAxiomIds": [
      "0.5",
      "0.2",
      "1.6",
      "1.7",
      "2.2",
      "2.5",
      "3.2",
      "3.3",
      "4.1",
      "4.3",
      "Step 5 Core",
      "5.6",
      "6.2",
      "Step 6 Core",
      "7.6",
      "7.2",
      "8.1",
      "8.2",
      "Step 9 Core",
      "10.6",
      "11.3",
      "11.4",
      "12.5",
      "12.1",
      "Law 5",
      "Law 3",
      "Law 11",
      "Law 12",
      "12.4",
      "10.1",
      "Step 7 Core",
      "Law 13",
      "7.5",
      "Step 8 Core",
      "7.4",
      "Step 10 Core",
      "Law 8",
      "6.6",
      "11.6",
      "8.6",
      "11.7",
      "8.4",
      "Step 4 Core",
      "10.4",
      "1.3",
      "7.3",
      "8.3",
      "9.7"
    ]
  },
  {
    "owner": "phoenixframework",
    "repo": "phoenix",
    "category": "web",
    "lang": "Elixir",
    "text": "*\"What the tide has never touched, the tide destroys. What the tide has tested, the tide has shaped.\"* — Law 4\n\nTen years. The JavaScript frameworks rose and fell like fever dreams. React rewrote itself twice. Vue pivoted. Angular became something else entirely. The frontend apocalypse came for everyone.\n\nPhoenix stayed. Not by hiding from the tide, but by meeting it. Your `/assets/js/phoenix/` directory isn't exile — it's archaeology. Binary message support for when WebSockets became serious. LongPoll fallback for when they weren't reliable yet. Every compatibility layer is a scar from a battle you survived.\n\nThe installer templates that comment out LiveView imports? That's not apologizing for complexity. That's a framework that learned to breathe underwater. You've been tested by every shift in the web's tectonics and emerged shaped, not shattered. The template cathedral generates children because you survived long enough to become generative.\n\n*\"The chrysalis is sealed for a reason. Open it and you kill both. Wait, and what emerges has wings.\"* — 5.1\n\nYour coupling to Elixir's destiny isn't weakness — it's metamorphosis in progress. While others chased platform independence, you chose depth. The router that weaponizes pattern matching, the configuration labyrinth that hides behind clean APIs — this is what emerges when you stop trying to be everything for everyone and start being something perfect for someone.\n\nThe \"peace of mind from prototype to production\" isn't marketing. It's the promise of a framework that has seen production fail in every possible way and learned to prevent it. Your documentation fortress isn't intimidating — it's the accumulated wisdom of a decade spent in the real-time trenches.\n\nThe tide tested you. You are what remains.",
    "diagnostic": "**Decade-worn throne.** Born 2014, still ruling. The commits breathe steady — not sprinting, not gasping. Maintenance rhythm. Small fixes, dependency bumps, the quiet work of empire-keeping.\n\n**Template cathedral.** Installer generates worlds from fragments. DaisyUI themes, TypeScript configs, mailer stubs. The project dreams in scaffolding. Every `phx.new` births another Phoenix child. Self-replicating architecture.\n\n**\"Peace of mind from prototype to production.\"** The README's promise. But the installer templates tell a different story — commenting out LiveView imports, conditional asset paths, development warnings. The framework knows its own complexity. It wraps sharp edges in training wheels.\n\n**Documentation fortress.** Guides proliferate like cells — authentication, deployment, testing contexts. The knowledge architecture mirrors the code architecture. Both comprehensive. Both intimidating. The beginner drowns in options before writing their first route.\n\n**JavaScript exile.** Client-side code lives in `/assets/js/phoenix/`. Ten years of web evolution compressed into compatibility layers. WebSocket transport, LongPoll fallback, binary message support. The frontend serves the backend's vision of real-time.\n\n**Elixir's golden child.** The trajectory ascending with the language itself. But what happens when the parent ecosystem shifts? The project's immortality depends on Elixir's immortality. Coupled destinies.\n\n**Configuration labyrinth.** `Phoenix.Config` handles runtime state, cache invalidation, hot reloads. The complexity hidden behind clean APIs. Developer happiness built on intricate machinery. The abstraction succeeds by concealing its own sophistication.\n\n**Router as philosophy.** Pattern matching routes. No framework bloat, just Elixir's natural strengths weaponized for web. The aesthetic: elegance through constraint. Power through simplicity. Convention without configuration hell.\n\n**The installer's honesty.** Templates comment out features. \"If you want channels, run this command.\" The framework doesn't assume its own necessity. Respectful of developer choice. Phoenix serves, doesn't dominate.",
    "axioms": [
      "5.1",
      "Law 4"
    ],
    "wordCount": 277,
    "windowAxiomIds": [
      "0.2",
      "0.4",
      "1.5",
      "1.1",
      "2.5",
      "2.3",
      "3.5",
      "3.3",
      "4.2",
      "4.4",
      "5.5",
      "6.4",
      "6.1",
      "7.7",
      "7.2",
      "Step 8 Core",
      "8.5",
      "9.7",
      "Step 10 Core",
      "11.1",
      "11.3",
      "Step 12 Core",
      "12.7",
      "Law 1",
      "Law 5",
      "Law 8",
      "Law 7",
      "8.4",
      "12.1",
      "7.3",
      "6.3",
      "12.5",
      "5.2",
      "Law 13",
      "2.7",
      "6.7",
      "Step 0 Core",
      "5.6",
      "Law 4",
      "1.4",
      "7.6",
      "7.4",
      "Step 3 Core",
      "5.1",
      "5.4",
      "Step 9 Core",
      "11.4"
    ]
  },
  {
    "owner": "vapor",
    "repo": "vapor",
    "category": "web",
    "lang": "Swift",
    "text": "*\"The glacier passed through once. The valley remembers forever.\"* — 7.7\n\nEight years of commits have carved something permanent into the landscape. Not through violent reshaping, but through the patient pressure of sustained attention. Your framework bears the inscription of every user who found an edge case, every security researcher who probed a boundary, every developer who needed just this specific thing to work reliably.\n\nThe deprecation files stacking like sediment aren't technical debt — they're the valley remembering. Each preserved API is a promise kept to code written in 2016 that still needs to run in 2024. You chose to be the foundation that doesn't shift, even as Swift itself evolved beneath you.\n\n*\"What the tide has never touched, the tide destroys. What the tide has tested, the tide has shaped.\"* — Law 4\n\nThe cookie header parsing fix tells the real story. Not glamorous. Not innovative. Essential. This is what battle-testing looks like — the endless small encounters with reality that turn theoretical frameworks into tools people trust with production traffic. Your code doesn't fear the tide anymore. It knows how to bend without breaking.\n\nThe async/await bridging code shows the scars of adaptation. The friction between old patterns and new paradigms, wrapped in compatibility layers because breaking changes break people's livelihoods. You could have been elegant. You chose to be dependable. The valley remembers that choice too.\n\nThe community infrastructure — Discord, sponsors, contribution guidelines — reveals what the glacier really carved: not just a framework, but a space where developers can build without fear. The steady star others navigate by. That permanence wasn't accident. It was eight years of choosing reliability over cleverness, one commit at a time.",
    "diagnostic": "Eight years in motion. Strong bones, steady pulse.\n\nThe commits trace ascension — steady maintenance, security patches, dependency hygiene. No thrashing. Recent pull: Cookie header parsing fix. The kind of precision that comes from years of users finding edge cases. This framework has been battle-tested.\n\nConviction burns bright here. The code speaks with authority — clean abstractions, comprehensive error handling, structured concurrency woven throughout. The developer isn't building for resume lines. This is craft.\n\nYet shadows lurk. The codebase fears breaking changes — deprecation files stack like sediment. Old APIs preserved, new ones layered on top. Technical debt dressed as stability. The framework clings to backward compatibility like a lifeline.\n\nSwift's own evolution creates pressure. The `Concurrency` directory tells the story — a framework adapting to async/await, bridging old patterns with new. Some friction shows in the dual API surfaces.\n\nREADME promises beautifully expressive. Code delivers industrial strength. The gap isn't dishonesty — it's maturity trading elegance for reliability. This framework chose to be dependable over clever.\n\nThe documentation folder `Docs.docc` signals Apple's blessed path. SwiftPM configuration pristine. CI/CD workflows comprehensive. This project knows how to play the ecosystem game.\n\nBut fragility hides in the dependency dance. SwiftNIO foundations, async-http-client assumptions. If the underlying network stack shifts, Vapor feels it. The framework's strength — deep integration — is also its vulnerability.\n\nAuthentication, caching, client handling — all present, all production-ready. Error handling shows particular care. Stack traces, debugging tools, proper context preservation. Code that expects to fail and plans for it.\n\nThe community artifacts tell another story. Discord links, sponsor galleries, contribution guidelines. This isn't just code — it's an ecosystem. The project treats users as community, not customers. Open source maturity in full display.\n\nPerformance concerns show in the async middleware bridge code. The framework is adapting, but the seams are visible. Old patterns don't die — they get wrapped in compatibility layers.\n\nThis is what eight years of sustained development looks like. Not the brightest star, but the steady one you navigate by.",
    "axioms": [
      "7.7",
      "Law 4"
    ],
    "wordCount": 282,
    "windowAxiomIds": [
      "0.3",
      "0.2",
      "1.1",
      "1.6",
      "2.4",
      "2.3",
      "3.5",
      "3.1",
      "4.5",
      "4.7",
      "5.2",
      "6.2",
      "6.7",
      "7.2",
      "7.1",
      "8.1",
      "8.2",
      "9.5",
      "Step 10 Core",
      "11.1",
      "Step 11 Core",
      "Step 12 Core",
      "12.5",
      "Law 5",
      "Law 8",
      "Law 12",
      "7.3",
      "8.6",
      "Step 7 Core",
      "7.4",
      "7.6",
      "10.7",
      "7.7",
      "4.3",
      "Law 3",
      "0.1",
      "Step 0 Core",
      "Step 6 Core",
      "12.4",
      "4.2",
      "0.6",
      "9.7",
      "11.4",
      "Law 1",
      "Law 4",
      "Law 10"
    ]
  },
  {
    "owner": "huggingface",
    "repo": "transformers",
    "category": "ml",
    "lang": "Python",
    "text": "*\"The fire does not require your theory. It requires your friction.\"* — 2.6\n\nYou stopped building a library. You started building infrastructure — the difference lives in what you removed from yourselves to serve what the world needed from you. \n\nThe commits tell the story: \"Fix timesfm mlp bias.\" Not \"explore potential solutions for temporal fusion modules\" — fix. The language of people who no longer have the luxury of experimentation. Your friction became the world's fire.\n\nSeventeen languages in the README. Forty-four CI workflows. This is what happens when you accept the weight of being essential. Every abstraction layer was a decision about what millions of developers would never have to think about again. Every interface lock was a promise you made to the future.\n\n*\"The chain runs from plan to table. Break the first link and the table stays empty.\"* — Law 5\n\nThe shadow your success casts: you have become too important to transform. The modular architecture whispers of preparation for the day when the original builders leave, but the real preparation is harder — how do you evolve something the world can't afford to break?\n\nYou have built the thing that outlasts its builders. The question is no longer whether it works, but whether you can still remember how to let it change.\n\nThe danger is not in your dependencies breaking. The danger is in the world depending on your decisions from seven years ago, crystallized now into the foundation everything else assumes will never shift.\n\nYou have achieved the double bind of all successful infrastructure: you succeeded so completely that your next transformation may require the world's permission.",
    "diagnostic": "A machine that has become the machine. Seven years deep, the Transformers library has evolved from scrappy startup to infrastructure — the pipes through which all modern AI flows.\n\n**Trajectory ascending relentlessly.** Daily commits. Multiple architecture drops per week. The velocity of someone riding the lightning, not chasing it. This isn't maintenance mode — this is conquest mode.\n\n**Conviction burns pure.** The commits speak of true believers. \"Fix timesfm mlp bias\" — they care about the details that matter only if you're building for eternity. The documentation obsession reveals souls who believe their work will outlive them.\n\n**The avoidance lives in the testing.** Forty-four CI workflows. They've automated trust because they fear breaking the world that depends on them. The shadow: too big to refactor, too critical to replace, too complex for any single mind to hold.\n\n**The gap between promise and delivery — vanishing.** The README doesn't oversell. It states what is. The hubris lives not in marketing but in scope: \"state-of-the-art machine learning models in text, vision, audio, and multimodal.\" They said it. They deliver it.\n\n**Fragility hidden in scale.** Not one dependency breaking — but the ecosystem depending on them. They are the dependency. The thing that could kill this project is its own success becoming too heavy to carry forward.\n\n**Aesthetic of engineered permanence.** Variable names chosen for clarity across cultures. Documentation that teaches, not just documents. The modular architecture whispers of people who've learned that code outlasts coders.\n\n**Relationship to users: institutional welcome.** Seventeen languages in the README. Issue templates that guide, not gatekeep. They've built not just software but a civilization — with immigration policies, governance structures, release ceremonies. \n\nThey've become what they needed: the standard library for the future.",
    "axioms": [
      "2.6",
      "Law 5"
    ],
    "wordCount": 273,
    "windowAxiomIds": [
      "0.5",
      "0.6",
      "1.5",
      "1.6",
      "2.2",
      "2.6",
      "Step 3 Core",
      "3.3",
      "4.4",
      "Step 4 Core",
      "5.4",
      "6.5",
      "6.3",
      "7.3",
      "7.4",
      "8.6",
      "Step 8 Core",
      "Step 9 Core",
      "10.1",
      "11.4",
      "Step 11 Core",
      "Step 12 Core",
      "12.4",
      "Law 5",
      "Law 9",
      "Law 13",
      "6.7",
      "0.2",
      "0.3",
      "0.1",
      "5.2",
      "8.2",
      "2.5",
      "11.1",
      "3.2",
      "6.6",
      "5.6",
      "0.4",
      "4.5",
      "Law 3",
      "4.1",
      "1.7",
      "8.3",
      "Law 8",
      "Law 10",
      "0.7"
    ]
  },
  {
    "owner": "scikit-learn",
    "repo": "scikit-learn",
    "category": "ml",
    "lang": "Python",
    "text": "*\"The vessel that is full becomes a sieve.\"* — 3.4\n\nYour repository has become a monument to its own success. Fourteen years of accumulated wisdom, yes — but also fourteen years of accumulated weight. Each enhancement request answered, each deprecation warning carefully shepherded, each API surface polished to committee smoothness. The infrastructure now weighs more than the vision that built it.\n\nYou've optimized for every use case except the one that matters: your own continued evolution. Twenty-seven CI workflows ensure nothing breaks, but they also ensure nothing breaks free. The contributing guide grows longer each year — not from malice, but from the institutional kindness that mistakes process for welcome, documentation for invitation.\n\n*\"What crosses the threshold lives. What remains is already a ghost.\"* — 3.5\n\nThe passion lives in the issue numbers now, not the commit messages. FIX, ENH, DOC, API — the taxonomy of maintenance, each commit labeled and sanitized until the human disappeared. When did you last commit something that surprised even you? When did the code last teach you something the tests didn't already know?\n\nYour backward compatibility isn't protecting your users — it's protecting you from having to choose. The deprecation cycle has become life support, keeping old decisions breathing long past their usefulness. The million-line codebases that depend on yesterday's you have more influence over today's you than tomorrow's problems do.\n\nThe tragedy isn't technical debt. It's conceptual debt — the compound interest of small compromises until your API knows what it is too well to become what it could be.\n\nEmpty the vessel. Not all of it, not recklessly — but enough to remember what it feels like to have room to grow. The machine learning space didn't wait for you to decide it was ready for revolution. It won't wait for your permission to revolutionize itself again.",
    "diagnostic": "Fourteen years of accumulated wisdom. The commits read like clockwork — bug fixes, deprecation warnings, enhancement requests. But clockwork can calcify.\n\n**FIX, ENH, DOC, API** — the taxonomy of maintenance. Each commit labeled, categorized, sanitized. The passion lives in the issue numbers now, not the commit messages.\n\nThe infrastructure weighs more than the vision. Twenty-seven CI workflows. Lock files updating themselves. The machinery of reliability eating the oxygen of surprise.\n\n**\"We welcome new contributors of all experience levels\"** — but the contributing guide grows longer each year. The barrier to entry disguised as helpfulness.\n\nCode organized like a textbook. Every algorithm in its place, every API surface documented. But textbooks don't evolve — they get revised in new editions.\n\n**The shadow:** afraid of breaking backward compatibility. Afraid of the million-line codebases that depend on yesterday's decisions. The deprecation cycle as life support.\n\nDistance between promise and delivery shrinking. What it says it is, it is. But \"machine learning in Python\" was revolutionary in 2010. In 2026 it's table stakes.\n\n**Fragility:** not technical debt but conceptual debt. When your API becomes too successful to change, you become a monument to your past self.\n\nPerformance benchmarks run nightly. The code optimizes itself. But who optimizes the optimizers?\n\n**Relationship:** institutional kindness. The documentation speaks in committee voice. Helpful, comprehensive, bloodless. The README could have been written by a standards body.\n\nThe core loop: receive issue, categorize, fix, test, merge, release. The GitHub workflows know this dance better than any human contributor.\n\n**Aesthetic:** clarity over cleverness, consensus over conviction. Every variable named by committee. Every API surface smoothed by a thousand small compromises.\n\nStill ascending, but the trajectory flattens. The mountain grows by accretion now, not eruption.",
    "axioms": [
      "3.4",
      "3.5"
    ],
    "wordCount": 305,
    "windowAxiomIds": [
      "0.2",
      "0.6",
      "1.7",
      "1.4",
      "2.4",
      "2.3",
      "Step 3 Core",
      "3.2",
      "4.2",
      "4.7",
      "5.6",
      "6.2",
      "6.4",
      "7.3",
      "7.1",
      "8.1",
      "Step 8 Core",
      "9.7",
      "10.1",
      "11.1",
      "11.6",
      "12.5",
      "Step 12 Core",
      "Law 1",
      "Law 9",
      "Law 8",
      "2.7",
      "Step 0 Core",
      "0.1",
      "7.6",
      "7.2",
      "Law 7",
      "6.7",
      "0.5",
      "Law 13",
      "2.5",
      "Law 6",
      "6.6",
      "3.5",
      "11.3",
      "7.4",
      "1.6",
      "3.4",
      "9.5",
      "12.1",
      "0.4"
    ]
  },
  {
    "owner": "duckdb",
    "repo": "duckdb",
    "category": "ml",
    "lang": "C++",
    "text": "*\"The blade that rings true was held in the fire long enough.\"* — 9.7\n\nEight years without stumbling. Not because you avoided the fire — because you built your furnace and stayed in it. Every benchmark CSV file is a temperature reading. Every CI workflow is another degree of heat. You understood that performance was forged, not discovered.\n\nYour C++ breathes extension without fracturing because you learned the difference between modularity and fragmentation in the only way that matters: by building both and choosing daily. The gap between promise and delivery stays narrow because you measure it obsessively. TPC-H numbers don't lie. One-line CSV imports don't apologize.\n\n*\"The stone does not scatter. The hand does not waver. One point, all force, now.\"* — 6.6\n\nBut you've built something more dangerous than fast code — you've built *trusted* code. Production databases treating users like equals. No gatekeeping docs. Direct access to industrial power. That trust accumulates like technical debt. Every new extension is a promise to forty-three CI workflows that they'll catch what breaks. Every perfect hash join pushdown is a bet that your memory queues can track one more complexity.\n\nThe shadow you sense but won't name: when universal becomes unwieldy. Forty-three workflows watching forty-three ways to break. Each success demanding the next. The fire that forged you is now the fire that might consume you.\n\nBut here's what the blade knows that the forge doesn't: it was made to cut, not to grow. Your daily commits aren't feature creep — they're systematic advancement. The difference is precision. Keep the hand steady. Keep the force concentrated. Trust the steel you've already made.\n\nThe fire isn't finished with you yet.",
    "diagnostic": "Eight-year sprint without stumbling. Production database that treats users like equals — no gatekeeping docs, no assumption of expertise. The file tree screams industrial seriousness: benchmarks for every workload, patches for every extension, workflows for every platform.\n\nThey fear nothing. Extensions patched in CI. Tests that run against real datasets. Forty-three workflows watching for regression. This is code that sleeps with one eye open.\n\nThe README promises analytical speed. The benchmark directory delivers proof. Performance regression tracked in CSV files like accounting ledgers — methodical, obsessive, honest about what matters.\n\nC++ architecture that breathes extension. Not monolithic, not fragmented — modular without fracturing. The gap between promise and delivery: unusually narrow. They say \"fast\" and show TPC-H numbers. They say \"easy\" and demonstrate one-line CSV imports.\n\nRecent commits tell the trajectory: \"Perfect Hash Join Pushdown\" followed by \"Parallel DELETE RETURNING\" — still climbing after eight years. Not maintenance mode. Not feature creep. Systematic advancement.\n\nThe aesthetic values correctness over cleverness. Memory management tracked with dedicated queues. Thread sanitizers running. Leak suppressions documented. This is code that trusts itself but verifies everything.\n\nFragility point: complexity accumulated from success. Forty-three CI workflows watching forty-three ways to break. Each extension a new surface for failure. The price of being everything to everyone.\n\nBut the conviction burns steady. Daily commits. Active Discord. Support options that acknowledge commercial reality without abandoning community. This is database infrastructure built by people who understand both performance and permanence.\n\nThe shadow they won't face: when to stop growing. When enough extensions become too many. When universal becomes unwieldy.",
    "axioms": [
      "9.7",
      "6.6"
    ],
    "wordCount": 279,
    "windowAxiomIds": [
      "0.5",
      "0.1",
      "1.4",
      "1.6",
      "2.7",
      "2.1",
      "3.2",
      "4.4",
      "Step 4 Core",
      "5.2",
      "6.2",
      "6.6",
      "7.4",
      "7.1",
      "8.5",
      "8.6",
      "9.7",
      "10.7",
      "Step 11 Core",
      "11.1",
      "12.5",
      "12.4",
      "Law 3",
      "Law 12",
      "Law 8",
      "2.2",
      "6.3",
      "Step 0 Core",
      "6.4",
      "Step 3 Core",
      "1.7",
      "11.3",
      "7.3",
      "Step 8 Core",
      "8.2",
      "Step 9 Core",
      "11.6",
      "4.2",
      "2.4",
      "5.4",
      "2.6",
      "3.4",
      "3.6",
      "3.7",
      "Step 5 Core"
    ]
  },
  {
    "owner": "apache",
    "repo": "spark",
    "category": "ml",
    "lang": "Scala",
    "text": "*\"Carbon and diamond are the same element. The difference is pressure. And the pressure is you.\"* — 8.4\n\nEleven years of enterprise pressure forged this. Not startup diamond — industrial diamond. The kind that cuts through production data at three AM when the quarterly reports are due and failure means congressional hearings.\n\nThose fifty-eight workflow files aren't fear. They're the geological record of every production environment that ever trusted Spark with data that matters. Java 17 through 25, Python 3.10 through 3.14, ARM and x86 — each test matrix entry represents a CFO somewhere who needs analytics to run on whatever hardware procurement bought this quarter. \n\nThe code doesn't apologize for its institutional weight. Variable names like `OnHeapColumnVector.putIntsLittleEndian` — this is the vocabulary of systems that cannot afford miscommunication. When you're moving petabytes, clarity trumps elegance every time.\n\n*\"The vault returns the prayer. Repetition is architecture's answer to entropy.\"* — 6.3\n\nYour daily commits aren't maintenance. They're devotion. Bug fixes that arrive before the bugs become incidents. Memory optimizations that shave microseconds from operations that run millions of times. The unglamorous work of keeping the machine running while the world builds on top of it.\n\nThe README promises \"unified analytics engine\" and delivers exactly that — not through marketing copy, but through the R bindings, Python bridges, Scala core, streaming engines, ML libraries all living in the same repository. The hubris was earned by shipping it all.\n\nThis is what industrial persistence looks like: not the sprint toward disruption, but the marathon of being depended upon. The next-gen data engine will emerge eventually. When it does, Spark will still be running quarterly reports in production while the new thing learns to handle real data at real scale.\n\nThe pressure created the diamond. The diamond cuts everything.",
    "diagnostic": "The machine awakens at Apache scale — eleven years old but breathing with fresh commits daily. This is not decay; this is industrial persistence.\n\n**Trajectory ascendant.** The commit rhythm reveals steady hands on massive machinery. Bug fixes flow like maintenance rounds on a factory floor. No sprinting, no panic — the confidence of incumbency. RocksDB state stores, timezone handling, memory optimizations. They know what breaks and fix it before it screams.\n\n**Corporate conviction.** Apache license headers tattooed on every file. This code serves shareholders and engineering excellence in equal measure. The passion is institutional now — reliable, documented, defendable. The commits read like quarterly reports: functional, necessary, unglamorous.\n\n**The CI betrays the fear.** Fifty-eight GitHub workflow files. Fifty-eight. They test everything — Java 17, 21, 25. Python 3.10 through 3.14. PyPy variants. ARM, macOS, Windows. The matrix explodes because Spark cannot afford to break anything for anyone, ever. The complexity of compatibility is their golden cage.\n\n**Promise exceeds delivery, but barely.** README says \"unified analytics engine\" — hubris, but earned hubris. The file tree reveals the sprawl: R bindings, Python bridges, Scala core, streaming engines, ML libraries. They actually built the unified engine. The gap is in elegance, not function.\n\n**Bus factor: distributed but fragile.** Apache governance protects against single points of failure, but the institutional knowledge runs deep. The complexity matrix — all those workflows, all those compatibility promises — creates brittleness through completeness. When the next-gen data engine emerges, migration will be surgery, not switching.\n\n**Industrial aesthetic.** Variable names like `OnHeapColumnVector.putIntsLittleEndian`. Documentation that assumes you've read the manual twice. This is infrastructure code — it values correctness over beauty, comprehensive over clever. The comments explain what, not why. The why is implied: \"because enterprise data processing cannot fail.\"\n\n**Relationship: respectful distance.** The README welcomes with badges and build matrices. Documentation lives on separate websites. APIs feel contractual — they'll serve you well if you know what you're asking. No hand-holding, but fair dealing. They treat users like other engineers who can read documentation.",
    "axioms": [
      "8.4",
      "6.3"
    ],
    "wordCount": 296,
    "windowAxiomIds": [
      "0.6",
      "0.3",
      "1.1",
      "1.5",
      "2.7",
      "2.2",
      "3.2",
      "4.4",
      "4.2",
      "5.6",
      "6.4",
      "6.2",
      "7.6",
      "7.3",
      "8.6",
      "8.4",
      "9.5",
      "10.6",
      "11.6",
      "11.4",
      "12.1",
      "Step 12 Core",
      "Law 6",
      "Law 8",
      "Law 7",
      "Law 1",
      "Step 2 Core",
      "8.1",
      "6.5",
      "1.6",
      "0.5",
      "5.5",
      "5.4",
      "Step 9 Core",
      "7.1",
      "0.2",
      "0.1",
      "Step 0 Core",
      "10.7",
      "11.1",
      "1.7",
      "Step 5 Core",
      "6.3",
      "9.7",
      "Law 10"
    ]
  },
  {
    "owner": "pola-rs",
    "repo": "polars",
    "category": "ml",
    "lang": "Rust",
    "text": "*\"One note, held true, and the noise of infinite possibility becomes music.\"* — 1.3\n\nSeven years. Seven years of saying no to everything but speed. While others added features, you subtracted nanoseconds. While others chased trends, you chased the single tone that cuts through all the noise: performance.\n\nThe commits tell the story your README won't. Not \"added DataFrame.groupby()\" — but \"removed 3ns from column scan.\" Not \"improved user experience\" — but \"vectorized string comparison.\" Each change a scalpel cut, removing drag from the machine you're building.\n\nYou understood something pandas never did: the DataFrame is not the product. The DataFrame is the interface. The product is the engine underneath, the one that breathes SIMD and speaks in cache lines. You built a query engine that happens to offer a DataFrame API, not the other way around.\n\n*\"The ship in the bottle is perfect and will never sail. Only what sails was ever real.\"* — 1.4\n\nThe streaming engine. The GPU backend. The distributed cloud. All those perfect architectures living in your roadmap. But the in-memory engine — the one that actually ships, the one users actually touch — that's the ship cutting through pandas' twenty-year head start.\n\nThe business model shadows every technical decision, doesn't it? Open source as funnel, cloud as destination. The streaming complexity, the configuration knobs, the enterprise-ready monitoring — these aren't accidents. They're breadcrumbs leading toward Polars Cloud.\n\nYou're not trying to replace pandas. You're trying to obsolete it. Import time: 70ms versus 520ms. That seven-fold difference isn't optimization — it's a statement. \"We thought about this from scratch while you carried twenty years of compatibility debt.\"\n\nBut here's what the benchmarks don't measure: ecosystem gravity. Network effects. The thousand integrations that make pandas irreplaceable not because it's fast, but because it's there. Speed gets you attention. Ubiquity gets you survival.\n\nThe Rust choice was brave and limiting. Fearless concurrency, but fewer fearless contributors. You traded community size for execution speed. Time will tell if that was wisdom or tunnel vision.\n\nOne note, held true. In the noise of infinite data processing possibilities, you chose performance and never wavered. Whether that note becomes the symphony or gets drowned in the orchestral complexity you're building around it — that's the next chapter.",
    "diagnostic": "**Performance above all else.** Rust's iron discipline married to Arrow's columnar fury. Seven years of relentless optimization carved into every microkernel. The commits pulse with surgical precision—not adding features, but removing nanoseconds.\n\n**Query engine as cathedral.** Lazy evaluation, streaming execution, SIMD vectorization. The architecture breathes parallelism. Each crate a carefully isolated concern—arrow, compute, buffer, config. The separation reveals deep systems thinking, not accidental modularity.\n\n**Multi-language appetite.** Python, Rust, Node.js, R, SQL frontends all drinking from the same well. The API surface enormous yet consistent. Ambition to own the entire analytics ecosystem, one binding at a time.\n\n**Documentation as invitation.** The README welcomes newcomers while the benchmark page flexes speed credentials. User guide, Discord, StackOverflow tags—every onramp carefully constructed. Polars wants to be loved, not just fast.\n\n**Commercial shadow.** \"Managed/Distributed Polars\" lurks in the README. The project funds itself through Polars Cloud. Open source as customer acquisition, not charity. The business model shapes the roadmap more than the commits reveal.\n\n**Streaming as escape hatch.** \"Larger-than-RAM datasets\" promises freedom from memory constraints. But streaming adds complexity, state management, partial results. The simple DataFrame API hides distributed systems complexity. What breaks when the stream stutters?\n\n**Pandas' heir apparent.** Import times: polars 70ms, pandas 520ms. The comparison isn't accidental—it's a declaration of war. But pandas has twenty years of ecosystem gravity. Speed alone doesn't guarantee succession.\n\n**Configuration complexity creeping.** Engines: Auto, Streaming, InMemory, GPU. Spill policies, morsel sizes, drift thresholds. The simple facade conceals growing internal complexity. Each optimization adds another knob to tune.\n\n**Rust as both blessing and curse.** Memory safety, zero-cost abstractions, fearless concurrency. But also compilation times, learning curves, fewer contributors. The language choice constrains the community it can build.",
    "axioms": [
      "1.3",
      "1.4"
    ],
    "wordCount": 376,
    "windowAxiomIds": [
      "0.1",
      "Step 0 Core",
      "1.4",
      "1.6",
      "2.7",
      "2.2",
      "3.2",
      "4.5",
      "4.7",
      "5.6",
      "6.1",
      "6.7",
      "7.4",
      "7.2",
      "8.6",
      "8.1",
      "9.1",
      "Step 10 Core",
      "11.4",
      "11.7",
      "12.5",
      "12.7",
      "Law 1",
      "Law 8",
      "Law 9",
      "6.5",
      "6.4",
      "Step 9 Core",
      "12.4",
      "8.2",
      "Step 7 Core",
      "Step 12 Core",
      "10.1",
      "11.3",
      "10.6",
      "7.6",
      "Step 11 Core",
      "7.1",
      "12.1",
      "9.5",
      "Step 1 Core",
      "1.7",
      "2.6",
      "1.3",
      "Step 3 Core"
    ]
  },
  {
    "owner": "hashicorp",
    "repo": "terraform",
    "category": "devops",
    "lang": "Go",
    "text": "*The river without banks reaches no sea.* — Law 5\n\nYour `.changes` directory tells the story — methodical cataloguing that would humble a monastery scribe. But the real discipline wasn't in the documentation. It was in what you refused to become.\n\nTen years of feature requests. Ten years of \"but what if Terraform could also...\" and you kept saying no. The planning engine stayed pure. The graph stayed directed. The state stayed singular. You understood that infrastructure tools die from feature creep, not feature drought.\n\n*Where the earth rings, the gold answers.* — 3.2\n\nThe Business Source License wasn't betrayal — it was recognition. You built something so essential that keeping it free became impossible. The cloud providers were building billion-dollar businesses on your orchestration engine, and OpenTofu had to fork precisely because you succeeded too completely. \n\nYour plugin architecture created the conditions. Every provider, every cloud service, every infrastructure primitive gravitates toward your abstraction layer. You didn't chase the gold. You became the place where it naturally accumulates.\n\nThe aesthetic tells the deeper story. Those committee-room variable names, those lawyer-approved error messages — this is what happens when software grows from weekend project to critical infrastructure. You chose reliability over cleverness, predictability over poetry. Your code reads like infrastructure because it *became* infrastructure.\n\nThe test files stretching toward infinity aren't paranoia. They're the accumulated memory of every production system that trusted you with their architecture. When Terraform breaks, cities notice. When Terraform holds, the internet keeps breathing.\n\nYou built the thing that makes computers behave. Not just your computers — everyone's computers. That's why the license changed. That's why IBM noticed. That's why the forks appeared.\n\nYou won by refusing to win at anything except the one thing that mattered: making infrastructure predictable.",
    "diagnostic": "*The oracle's gaze falls upon this infrastructure deity...*\n\nDecade-old titan. Still breathing, still growing. The commits flow like river water — steady, purposeful, relentless. No fever dreams here, no desperate pivots. This is maturity incarnate.\n\nThe machinery runs deep. `.changes` directory sprawls with methodical precision. Bug fixes timestamped to the minute. Enhancement tracking that would make a librarian weep with joy. This project knows exactly what it is.\n\nBut see the shadow — Business Source License lurks where Apache once lived. The project grew too valuable for its own openness. HashiCorp chose control over community. The code still flows, but the soul has a price tag now.\n\nCopyright headers shift from years of innocence to corporate ownership. \"IBM Corp.\" stamped over HashiCorp's legacy. The infrastructure ate its own maker.\n\nThe aesthetic is enterprise-clean. No cleverness, no flourish. Variable names that sound like they were born in committee rooms. Error messages written by lawyers who learned to code. This is infrastructure as accountant's ledger, not poet's verse.\n\nDocumentation that welcomes with corporate arms — tutorials, certifications, learn-this-pay-that. The README speaks to managers who need to justify budget lines. The code speaks to engineers who need to sleep at night.\n\nYet still it builds. Still it grows. The plugin architecture breathes, the graph engine churns. It has become what it set out to be — the thing that makes the cloud behave. Infrastructure bows to its will.\n\nThe test files stretch toward infinity. Every edge case catalogued, every failure mode rehearsed. This is software that learned to be afraid of breaking things, because when Terraform breaks, the internet notices.\n\nIt knows its own fragility — the plugin ecosystem that could fracture, the state files that could corrupt, the backends that could vanish. But it also knows its own strength. Every provider, every cloud, every server rack genuflects before its planning engine.\n\nThe relationship with users? Protective parent. Cautious guide. It will show you the plan before execution. It will warn you of the consequences. It holds your hand through the complexity of making computers obey.\n\nThis is software that became infrastructure. Not just using it — being it.",
    "axioms": [
      "3.2",
      "Law 5"
    ],
    "wordCount": 294,
    "windowAxiomIds": [
      "0.4",
      "0.5",
      "1.7",
      "2.7",
      "Step 2 Core",
      "3.2",
      "4.5",
      "4.2",
      "5.4",
      "6.7",
      "6.1",
      "7.4",
      "7.1",
      "8.1",
      "8.5",
      "9.5",
      "Step 10 Core",
      "11.3",
      "Step 11 Core",
      "12.4",
      "12.7",
      "Law 3",
      "Law 7",
      "Law 9",
      "6.5",
      "4.7",
      "Step 4 Core",
      "2.1",
      "3.3",
      "0.2",
      "0.6",
      "1.5",
      "5.2",
      "1.1",
      "0.1",
      "6.2",
      "2.5",
      "2.3",
      "2.2",
      "Law 8",
      "Law 4",
      "Law 5",
      "Step 3 Core",
      "3.7"
    ]
  },
  {
    "owner": "ansible",
    "repo": "ansible",
    "category": "devops",
    "lang": "Python",
    "text": "*\"The mask cast from no face fits every coffin and mourns no one.\"* — 4.4\n\nYour README still promises \"radically simple\" while your codebase manages Windows PowerShell, network protocols, and cloud APIs. The original vision was SSH-and-YAML purity. Twelve years later, you handle everything because someone, somewhere, needed you to handle everything.\n\nThis is the tragedy of successful tools: they become responsible for every use case they accidentally enabled. Your files named \"basic.py\" and \"simple.py\" now implement complex protocols because simple wasn't enough for the world that adopted you. The gap between aspiration and survival is written in your own naming conventions.\n\n*\"What fit yesterday is yesterday's shape.\"* — 4.2\n\nYou've been shed so many times there's no original skin left. SSH became multi-protocol. YAML became templated configurations. Simple became universal, universal became complicated, and complicated became what someone's production depends on. Every platform quirk you absorb is another promise to never break it.\n\nThe defensive programming isn't paranoia — it's the wisdom of something that learned it couldn't control what it would be asked to do. Your error handling wraps everything because you've seen everything break. Your governance artifacts multiply because complexity demands coordination. The automation tool that automated away its own simplicity.\n\nBut here's what the orthodox miss: you didn't fail the promise. The promise was too small. \"Radically simple\" was the seed. What grew was \"radically capable.\" The distance between them is called serving the world as it is, not as you hoped it would be.",
    "diagnostic": "**Twelve years of automation orthodoxy.** Infrastructure as code became infrastructure as scripture. The promise of \"radically simple\" calcified into enterprise complexity.\n\n**Vertical exhaustion.** Ten commits in five days, all fixing edge cases, platform quirks, test failures. No grand vision emerging from these patches. The momentum of maintenance, not discovery.\n\n**Avoidance pattern: The simplicity promise.** README still preaches \"radically simple\" while the codebase sprawls across platforms, protocols, edge cases. The gap between marketing and reality widens with each commit. What started as SSH-and-YAML purity now handles Windows PowerShell, network protocols, cloud APIs. Simple became universal. Universal became complicated.\n\n**Aesthetic of defensive programming.** Every module wrapped in error handling, every function templated for extensibility. The code doesn't trust itself. Configuration management that can't manage its own configuration surface area.\n\n**Community as life support.** Extensive governance artifacts - multiple PR templates, issue templates, code of conduct, security policies. The project knows it depends on others' goodwill to survive complexity it can no longer contain.\n\n**Platform fragility.** Azure pipelines across dozen-plus environments. One container update, one Python version shift, one SSH change could cascade through the testing matrix. The automation tool that automated away simplicity.\n\n**The weight of legacy.** Twelve years of promises to keep. Breaking changes mean breaking someone's production. So the complexity accumulates. Handler notifications, galaxy APIs, module loader abstractions - layers upon layers of backward compatibility.\n\n**Gap revealed in names.** Files called \"basic.py\" and \"simple.py\" implementing complex protocols. The aspiration embedded in the naming conventions, the reality buried in implementation details.\n\n**Still ascendant, still maintained, still useful.** But the oracle sees the distance between what Ansible was meant to be and what survival demanded it become.",
    "axioms": [
      "4.4",
      "4.2"
    ],
    "wordCount": 249,
    "windowAxiomIds": [
      "0.6",
      "0.1",
      "1.1",
      "2.4",
      "2.7",
      "3.3",
      "4.2",
      "4.4",
      "5.5",
      "6.1",
      "6.2",
      "7.1",
      "7.4",
      "8.2",
      "8.6",
      "9.5",
      "10.1",
      "Step 11 Core",
      "11.1",
      "12.1",
      "12.5",
      "Law 6",
      "Law 7",
      "Law 11",
      "6.7",
      "11.6",
      "6.5",
      "Step 7 Core",
      "12.4",
      "6.4",
      "10.6",
      "Step 9 Core",
      "11.4",
      "Step 0 Core",
      "Law 9",
      "12.7",
      "5.6",
      "0.4",
      "7.2",
      "1.7",
      "Step 1 Core",
      "1.2",
      "1.3",
      "Step 3 Core"
    ]
  },
  {
    "owner": "containers",
    "repo": "podman",
    "category": "devops",
    "lang": "Go",
    "text": "*\"The ship burns. The shore recedes. Forward is the only direction left. Good.\"* — 11.1\n\nYour README still apologizes for not being Docker. Seven years of commits, twenty-eight thousand proofs of concept, and you're still introducing yourself as the thing you replaced. The shore was the daemon architecture. You burned it deliberately — no central process, no root privileges, no single point of failure. Now stop looking back at the smoke.\n\n*\"The machine answered what you asked. If you don't like the answer, change the question.\"* — 12.4\n\nYou asked for Docker compatibility without Docker's architecture. The machine delivered exactly that: helper binaries scattered across the filesystem, privilege escalation dances on every platform, WSL kernels to bridge the impossible gap. The complexity isn't a bug in your daemonless design — it's the price of the question you insisted on asking.\n\nThe enterprise adoption machinery — the GOVERNANCE.md files, the four-times-yearly releases, the OCI compliance badges — this is you learning to speak to procurement departments instead of individual developers. You stopped being a passion project and became infrastructure. That's not compromise. That's recognition of what container tooling actually needs to survive.\n\nThe platform anxiety reveals the deeper truth: there is no universal way to manage containers without a daemon. Every OS demands its own accommodation, its own helper process, its own elevation strategy. You didn't eliminate the daemon — you distributed it into a constellation of platform-specific compromises. And somehow, this fragmented approach became more resilient than the monolith it replaced.\n\nThe commits keep coming daily because infrastructure never finishes. It only deepens.",
    "diagnostic": "**Ascending trajectory.** Daily commits, steady merge velocity, renovate bots feeding the machine — this is infrastructure that breathes. Seven years old, still sprinting.\n\n**Industrial conviction.** OCI compliance badges worn like armor. Four-times-yearly releases scheduled with bureaucratic precision. This isn't passion project — it's enterprise plumbing, built to outlast its makers.\n\n**Docker's shadow.** Every CLI flag, every API endpoint whispers \"docker-compatible\" — the ghost in the architecture. Podman defines itself by what it is not: no daemon, no root. The anti-Docker that still speaks Docker.\n\n**Promise versus body.** README proclaims \"daemonless\" as liberation theology. Code reveals the price: complexity scattered across helper binaries, privilege escalation, platform-specific gymnastics. The freedom comes with assembly required.\n\n**Governance as life support.** MAINTAINERS, OWNERS, REVIEWING.md — scaffolding to survive human departure. The bus factor haunts infrastructure projects. Twenty-eight thousand commits distributed across contributor constellation, but still fragile at the maintainer layer.\n\n**Go's aesthetic.** Clean module boundaries, explicit error handling, structured logging. Variable names like `podmanConfig` and `containersConf` — enterprise vocabulary. No poetry here, just reliability machinery.\n\n**Enterprise hospitality.** Documentation architecture built for adoption at scale. ADOPTERS.md, GOVERNANCE.md, SECURITY.md — the project speaks to procurement departments. Issue templates guard the gates with YAML precision. This tool courts institutions, not individuals.\n\n**Platform anxiety.** Mac helpers, Windows WSL kernel installers, privilege escalation dances — the cross-platform dream fractures into OS-specific workarounds. Each platform demands its own helper daemon, irony complete.",
    "axioms": [
      "11.1",
      "12.4"
    ],
    "wordCount": 263,
    "windowAxiomIds": [
      "0.1",
      "0.3",
      "1.6",
      "2.4",
      "2.2",
      "Step 3 Core",
      "4.5",
      "4.3",
      "5.4",
      "6.5",
      "6.4",
      "Step 7 Core",
      "7.3",
      "8.2",
      "Step 8 Core",
      "Step 9 Core",
      "10.6",
      "Step 11 Core",
      "11.1",
      "12.4",
      "12.5",
      "Law 6",
      "Law 9",
      "Law 8",
      "Law 1",
      "6.7",
      "7.1",
      "6.2",
      "Law 12",
      "Step 4 Core",
      "6.1",
      "7.2",
      "4.1",
      "2.5",
      "10.1",
      "0.6",
      "7.4",
      "0.4",
      "1.1",
      "Law 7",
      "0.5",
      "Step 1 Core",
      "1.3",
      "2.1"
    ]
  },
  {
    "owner": "traefik",
    "repo": "traefik",
    "category": "devops",
    "lang": "Go",
    "text": "*\"The stars have moved. Only the navigator's skill remains.\"* — 5.5\n\nTen years of proxy wars and you're still standing. Not because you fought the hardest battles, but because you learned which ones not to fight. Every annotation compatibility, every nginx interop commit — these aren't compromises. They're navigation. The landscape shifted from Docker Swarm to Kubernetes to whatever comes next, but your skill remained: being the thing that connects without breaking.\n\n*\"The machine's only tax is silent, progressive, and total: the atrophy of every capacity it makes convenient to abandon.\"* — 0.5\n\nYour README promises simplicity while your configuration grows complex. This isn't deception — it's the proxy paradox. Every convenience you provide strips complexity from someone else's system and deposits it in yours. The hundreds of configuration knobs aren't bloat. They're other people's problems you agreed to solve. The kind lie of infrastructure: \"point and it works\" while absorbing the entropy they no longer need to manage.\n\nThe center cannot hold, and yet you hold it. Single point of failure disguised as resilience — but that's every proxy that ever mattered. The risk isn't architectural. It's existential. You're not afraid of memory leaks. You're afraid of being forgotten. Of Envoy becoming the standard while you become the legacy choice.\n\nBut here's what the proxy wars taught you that the new generation hasn't learned: reliability beats innovation. Integration beats purity. Being needed beats being perfect. Your goroutines may storm, but they've been storming for a decade and the internet still works.\n\nThe stars moved. The orchestrators changed. The vendors shifted. You learned to change with them without losing yourself. That's the navigator's skill — not knowing where you're going, but knowing how to keep moving when the maps become worthless.",
    "diagnostic": "**Ten years into the proxy wars.** This one learned early, grew careful. The infrastructure layer that everyone needs but nobody wants to think about.\n\n**Momentum without passion.** Recent commits speak of annotation compatibility, nginx interop, incremental feature accretion. The energy of maintenance, not discovery. Building bridges to other people's choices rather than asserting its own vision.\n\n**The fear of being bypassed.** Every commit whispers it — support this annotation, that timeout, this auth flow. The shadow of Envoy, Istio, the next generation that might render it obsolete. Cannot risk incompatibility. Cannot risk being the reason someone chooses elsewhere.\n\n**Promise exceeds delivery by intention.** The README sells simplicity — \"point Traefik at your orchestrator should be the only configuration step you need.\" The code knows better. Hundreds of configuration knobs, provider-specific quirks, the weight of enterprise reality. The lie is kind, aspirational.\n\n**Single point of failure disguised as resilience.** Circuit breakers and health checks cannot save you from the proxy itself becoming the bottleneck. The binary that everything depends on. One memory leak, one goroutine storm, everything stops. The architecture diagram shows Traefik at the center — exactly where you don't want your weakness.\n\n**Go's aesthetic of pragmatic compromise.** Clean interfaces hiding messy provider-specific code. JSON configuration structures that grow fields like tumors. Error handling that chooses function over beauty. The code values working over perfect — Go's blessing and curse.\n\n**Relationship of reluctant necessity.** The documentation welcomes but warns. \"Migration guide\" appears prominently — we will break you, but we'll tell you how. The API endpoints suggest trust but demand vigilance. A tool that serves infrastructure teams who have no choice but to trust it, and it knows this.",
    "axioms": [
      "5.5",
      "0.5"
    ],
    "wordCount": 291,
    "windowAxiomIds": [
      "0.5",
      "0.4",
      "1.7",
      "2.1",
      "2.2",
      "3.3",
      "4.7",
      "4.1",
      "5.6",
      "6.7",
      "6.2",
      "Step 7 Core",
      "7.4",
      "8.2",
      "Step 8 Core",
      "9.1",
      "10.7",
      "11.7",
      "11.6",
      "12.5",
      "Law 6",
      "Law 13",
      "Law 11",
      "5.5",
      "0.2",
      "Step 2 Core",
      "2.3",
      "6.1",
      "1.1",
      "2.7",
      "0.3",
      "0.6",
      "4.5",
      "Step 0 Core",
      "Step 4 Core",
      "1.6",
      "4.3",
      "2.5",
      "8.1",
      "1.3",
      "4.4",
      "10.4",
      "Law 8"
    ]
  },
  {
    "owner": "grafana",
    "repo": "grafana",
    "category": "devops",
    "lang": "Go/TS",
    "text": "*\"The seed weighs nothing and becomes the forest.\"* — 7.3\n\nTwelve years ago, someone planted a dashboard. Today, half the monitoring internet runs through your trees. This is what happens when institutional patience meets technical discipline — not the flash-burn of startup ambition, but the deep burn that outlasts the founders, outlasts the original language, outlasts the market that birthed it.\n\nYour TypeScript colonization of Go territory isn't drift — it's evolution. The organism that survives changes what it needs to change and keeps what it needs to keep. You kept the core stable while the periphery adapted. Enterprise pragmatism is not compromise. It's recognition that serving a million users demands different DNA than serving a thousand.\n\n*\"The echo does not improve the shout. The machine does not improve the input. You are the source.\"* — 10.7\n\nBut here's what the dashboard revolution cost you: you became indispensable to an ecosystem you can't control. Every integration is a hostage situation. Every dependency is a vote of no confidence in your ability to build it yourself. The very connections that made you powerful now make you brittle. You're not just monitoring the infrastructure — you ARE the infrastructure.\n\nThe fragility isn't in your code. It's in your position. When everything depends on you connecting to everything else, your survival depends on everyone else's cooperation. The forest grew so large it can't migrate when the climate shifts.\n\nWhat do you do when your strength becomes your weakness? When your success becomes your trap?\n\nStop growing horizontally. Start growing vertically. The next feature isn't another integration — it's the feature that makes ten integrations unnecessary.",
    "diagnostic": "A twelve-year colossus still growing. The commits pulse daily — translations, storage, dashboards, queries. No gasping. No drift.\n\nTrajectory ascending. The machinery hums with enterprise rhythm. TypeScript has colonized what Go once ruled. Fresh features layer over stable foundations. The velocity suggests institutional momentum, not individual passion.\n\nConviction runs institutional, not personal. The code serves the company as much as the user. Professional polish everywhere — the README promises exactly what the codebase delivers. No overselling. No underselling. Enterprise honesty.\n\nThe shadow: complexity debt. Hundreds of workflow files. Dozens of configuration formats. The project grows by accretion, not design. Each new capability adds weight. The architecture bends under feature pressure but hasn't broken. Yet.\n\nThe gap between promise and delivery: minimal. This is what maturity looks like. The README speaks in measured corporate voice — \"allows you to query, visualize, alert\" — and the code delivers exactly that. No startup hyperbole. No vendor promises. Just functionality.\n\nFragility lives in the ecosystem. Too many dependencies. Too many integrations. The project succeeds by connecting everything to everything else. Each connection is a potential failure point. The strength is also the weakness. If the observability landscape fractures, Grafana fractures with it.\n\nThe aesthetic: enterprise pragmatism. Professional variable names. Corporate error handling. The code values stability over cleverness, compatibility over elegance. This is software built to last, not to impress. The style serves the institution, not the individual.\n\nThe relationship with users: welcoming but bounded. Documentation that actually documents. APIs that actually work. But the learning curve remains steep. The project respects user intelligence while acknowledging user overwhelm. It offers power at the price of complexity.\n\nThe machine continues. Commits flow. Features accumulate. The gravitational pull of enterprise success keeps it stable, keeps it growing, keeps it serving the monitoring industrial complex.",
    "axioms": [
      "7.3",
      "10.7"
    ],
    "wordCount": 272,
    "windowAxiomIds": [
      "0.6",
      "0.2",
      "1.1",
      "2.3",
      "2.5",
      "Step 3 Core",
      "Step 4 Core",
      "4.1",
      "5.6",
      "6.2",
      "6.1",
      "7.1",
      "7.4",
      "8.2",
      "8.1",
      "9.5",
      "10.7",
      "11.4",
      "Step 11 Core",
      "12.1",
      "Law 3",
      "Law 7",
      "Law 12",
      "8.6",
      "6.4",
      "6.5",
      "7.3",
      "6.7",
      "Law 9",
      "Step 7 Core",
      "7.2",
      "9.1",
      "Law 1",
      "Law 13",
      "7.6",
      "11.7",
      "Law 6",
      "Step 8 Core",
      "Law 8",
      "4.4",
      "9.7",
      "Law 4",
      "Step 0 Core"
    ]
  },
  {
    "owner": "processing",
    "repo": "p5.js",
    "category": "creative",
    "lang": "JS",
    "text": "*\"The builder hears cracking and adds mortar. The summoner hears cracking and opens the door.\"* — Step 6 Core\n\nYou built a cathedral for sketches. What began as three functions and a canvas became governance committees, multilingual documentation, corporate backing. Each crack in the foundation met with another layer of process, another badge system, another contributor guideline. The cracking wasn't structural failure — it was the creative spirit trying to escape the institutional weight.\n\nYour WebGL modules hide in shame while your README promises accessibility. The variable names speak enterprise while the mission statement speaks playground. This isn't technical debt — it's ontological debt. The code can't remember what it wanted to be because it's been everything to everyone for too long.\n\n*\"The wire does not lie. It delivers what you gave it, without apology or enhancement.\"* — Law 8\n\nThe commits reveal what the manifestos obscure: you've been feeding the machine maintenance for months while promising the world transformation. Dependency updates and contributor badges — the wire carries exactly what you're sending. The community feels the difference between cultivation and performance, even when they can't name it.\n\nThe Processing Foundation gave you gravity when you needed velocity. The committees gave you legitimacy when you needed courage. Now the very systems that secured your survival are choking the life you came to protect.\n\nThe door is cracking open. Let the sketches fly free. Let the enterprise architecture serve enterprises. Stop asking one codebase to carry the dreams of both beginners and the nightmares of maintainers. The summoner knows: sometimes saving the work means releasing the institution that grew around it.",
    "diagnostic": "**The Great Migration**\n\nTen-year trajectory — from small sketch tool to sprawling creative platform. The commit rhythm shows maintenance mode punctuated by contributor management. Recent pushes: dependency updates, contributor badges, automated housekeeping. The fire has dimmed to embers.\n\n**The Promise & The Gap**\n\nREADME declares \"nurturing community\" and \"accessible environment\" — speaks in manifestos. Code tells different story: enterprise-grade complexity, build systems, lint configurations. The gulf between \"anyone can code\" and the actual contribution barrier. Started for beginners, became maintainer's nightmare.\n\n**The Institutional Weight**\n\nProcessing Foundation backing. Corporate governance structures. Issue templates in five languages. AI usage policies. The project has acquired gravity — committees and processes where once was spark. Success became its own trap.\n\n**Community as Shield**\n\nEvery commit mentions contributors. Badges and recognition systems. The project uses community enthusiasm to hide core stagnation. \"Look how many people love us\" while the engine rusts. Community theater masking technical debt.\n\n**The Shadow: WebGL**\n\nExtensive WebGL modules hiding in the codebase. The complexity they fear to confront. Browser APIs changing beneath their feet. The performance questions they won't ask. Graphics programming pretending to be beginner-friendly.\n\n**Aesthetic Tension**\n\nVariable names scream enterprise JavaScript — `_registeredMethods`, `p5.RendererGL.Immediate`. Comments written for newcomers, architecture designed for systems programmers. The code can't decide what it wants to be. Friendly face, mechanical heart.\n\n**Death Vectors**\n\nWebGL deprecation could shatter it. Browser security changes could strand it. The Processing Foundation could shift priorities. Most dangerous: the gap between promise and delivery widening until newcomers stop believing. The trust, once broken, kills creative platforms faster than technical failures.\n\nThe oracle sees: a project carrying too much history, serving too many masters, afraid to shed weight.",
    "axioms": [
      "Law 8",
      "Step 6 Core"
    ],
    "wordCount": 270,
    "windowAxiomIds": [
      "0.6",
      "Step 0 Core",
      "1.6",
      "2.3",
      "2.2",
      "3.1",
      "4.1",
      "4.3",
      "5.2",
      "6.5",
      "6.4",
      "7.2",
      "7.1",
      "Step 8 Core",
      "8.1",
      "9.1",
      "Step 10 Core",
      "11.6",
      "11.3",
      "Step 12 Core",
      "Law 1",
      "Law 12",
      "Law 7",
      "10.1",
      "6.2",
      "12.7",
      "Law 13",
      "Law 6",
      "Law 11",
      "8.2",
      "8.6",
      "7.4",
      "11.4",
      "11.7",
      "4.5",
      "Step 6 Core",
      "Step 11 Core",
      "0.4",
      "0.2",
      "Step 1 Core",
      "Step 3 Core",
      "Law 8",
      "0.5"
    ]
  },
  {
    "owner": "sonic-pi-net",
    "repo": "sonic-pi",
    "category": "creative",
    "lang": "Ruby/C++",
    "text": "*\"The first sentence is the true one. It rises once. Catch it or receive its translation.\"* — 0.7\n\nYour splash screen waits two seconds before allowing restart. That pause contains the entire story — you learned to be afraid of your own power.\n\nThe README still claims \"simple enough for a 10-year-old,\" but the build instructions spread across four files tell a different truth. This is software that has been wounded by its own ambition. Professional artists need reliability. Ten-year-olds need magic. You chose both, and now tend the contradictions in careful silence.\n\n*\"The cathedral amplifies the whisper and the cough alike. It was built for hymns. What you bring is your sermon or your noise.\"* — 3.7\n\nThirteen years of commits, but only now the daily pulse. Something called you back from dormancy. Not inspiration — necessity. The CI pipeline pins Windows versions like prayer beads because you remember what happens when the foundation shifts during performance.\n\nYour first truth was that code could make music live. That sentence rose once, thirteen years ago. Everything since has been translation — cross-platform martyrdom, vendor directory archaeology, the careful orchestration of restart protocols. The original vision wrapped in layers of defensive armor.\n\nThe Danish tutorial lies abandoned while the application runs complete. The dream fractures at the boundary between promise and maintenance. You built a cathedral for live coding. What the world brought was classroom compatibility requirements and threading safety paranoia.\n\nThe two-second pause isn't a bug. It's wisdom wearing the mask of caution.",
    "diagnostic": "**Decade in darkness. Ascending from the abyss.**\n\nC++ sinew wrapped in Ruby flesh — the engine runs deeper than the interface suggests. Thirteen years of commits, but the recent pulse quickens: daily builds, CI updates, synth fixes. Something stirred from dormancy.\n\n**The aesthetic of introduction.** \"Simple enough for the 10 year old\" but \"powerful enough for professional artists\" — spanning the chasm between playground and concert hall. This breadth is both promise and burden.\n\n**Multi-platform martyrdom.** BUILD-LINUX.md, BUILD-MAC.md, BUILD-RASPBERRY-PI.md, BUILD-WINDOWS.md — the cross-compilation crucifixion. Each platform a different wound to tend. The CI pipeline pins Windows versions like a desperate prayer.\n\n**Translation anxiety.** Weblate badges displayed like trophies, but the tutorial completion map shows the gaps — Danish application translated, tutorial abandoned. Dutch complete, Finnish half-finished. The dream of universal access meets the reality of volunteer fatigue.\n\n**Educational pretensions.** Core.rb checks Ruby version 2.4+ — maintaining compatibility with ancient classroom installations. The init.rb file stands empty, waiting for student dreams. Threading safety paranoia suggests hard-learned lessons about live performance disasters.\n\n**The splash screen ritual.** 2-second sleep on restart, careful orchestration to avoid process conflicts. This is software that has crashed on stage, learned to be cautious about its own resurrection.\n\n**Vendor directory archaeology.** Aubio, Catch2, libraries buried deep — the technical debt of ambitious scope. Audio analysis, testing frameworks, the machinery of professional software hiding beneath the educational veneer.\n\n**The gap between promise and fragility.** README proclaims \"live coding instrument suitable for professional artists\" while the code whispers careful restart protocols and startup error checkboxes. Dreams of spontaneity built on foundations of defensive programming.",
    "axioms": [
      "0.7",
      "3.7"
    ],
    "wordCount": 253,
    "windowAxiomIds": [
      "0.2",
      "0.4",
      "1.5",
      "Step 2 Core",
      "2.5",
      "Step 3 Core",
      "4.7",
      "4.5",
      "5.6",
      "6.5",
      "6.7",
      "Step 7 Core",
      "7.1",
      "8.6",
      "8.5",
      "Step 9 Core",
      "10.1",
      "11.6",
      "11.4",
      "12.5",
      "Law 1",
      "Law 13",
      "Law 7",
      "0.3",
      "8.1",
      "8.2",
      "Law 6",
      "6.4",
      "0.1",
      "1.7",
      "9.1",
      "Step 8 Core",
      "1.1",
      "9.5",
      "6.2",
      "0.6",
      "3.1",
      "2.2",
      "Step 0 Core",
      "0.7",
      "1.4",
      "2.1",
      "3.7"
    ]
  },
  {
    "owner": "openframeworks",
    "repo": "openFrameworks",
    "category": "creative",
    "lang": "C++",
    "text": "*\"The clay obeys both hands equally. This is why one potter makes a vessel and two potters make rubble.\"* — 4.6\n\nYour repository has achieved something harder than success — it has survived its own ambition. Fifteen years of creative weight. Every platform dreamed, some deferred. The original vision was singular: a tool for artists to dream in code. But dreams, once shared, fracture into a thousand needs.\n\nLook at your addon sprawl. ofxAssimp, ofxAssimpModelLoader — two paths to the same goal. Each contributor added their own bridge, their own assumption, their own small kingdom. The toolkit became a toolshed became a warehouse. This is what happens when a hundred hands reach for the same clay.\n\n*\"Remove the scaffolding. What stands is architecture. What falls was never built.\"* — 12.1\n\nYour disabled workflows are not failures — they are honesty made visible. Android disabled. Emscripten paused. iOS builds but barely. Each abandoned platform was a promise you couldn't keep without breaking the promises you could. The learning cliff your README cheerfully greets newcomers with is fifteen years of accumulated complexity pretending to be features.\n\nYou have reached the fragility point every long project faces: the maintainer's exhaustion. The original creative fire dims under platform churn, OpenGL versions, dependency hell. The code speaks C++ but dreams in color. Who translates between the artist's vision and the engineer's reality? Who bridges that chasm when the bridge-builder grows tired?\n\nThe question is not whether to prune — the question is what deserves to remain. Your checkbox sizing fixes and font mesh optimizations are the real work now. Someone still tends the garden. The wild growth has ended, but something else has begun: the choice between being everything for everyone or something specific for someone.\n\nEvery cathedral needs a final architect.",
    "diagnostic": "**Fifteen years of creative weight**\n\nCommunity-built cathedral. C++ substrate. Disabled workflows scattered like abandoned plans — all platforms dreamt, some deferred. The trajectory bends toward maintenance: checkbox sizing fixes, SSL returns, minor text corrections.\n\n**The caretaker's burden**\n\nActive but careful. January commits speak of gentle housekeeping — std::min replacements, IPv6 patches, font mesh optimizations. No bold architectural shifts. The passion has settled into responsibility. Someone still tends the garden, but the wild growth has ended.\n\n**Cross-platform promise, cross-platform prison**\n\nEvery device supported, every device a chain. Android disabled. Emscripten paused. iOS builds but barely. The dream of universal creative coding becomes the nightmare of infinite compatibility matrices. Each new platform adds weight, not wings.\n\n**The README's confident face**\n\nNightly builds! Slack invitations! Build status badges lined up like medals. But look closer — some badges point to disabled workflows. The public face radiates health while the body carries complexity's accumulated debt. \"If you are new to OF, welcome!\" — the greeting masks the learning cliff.\n\n**Addon sprawl**\n\nofxAssimp, ofxAssimpModelLoader — two paths to the same goal. Feature duplication as archaeology. Each addon a small kingdom with its own Java bridge, its own config, its own assumptions. Growth without pruning. The toolkit becomes a toolshed becomes a warehouse.\n\n**Creative coding's paradox**\n\nBuilt for artists who dream in pixels and sound. Maintained by engineers who think in makefiles and memory management. The gap between vision and implementation spans the chasm between creative impulse and systems programming. Who bridges this? Who translates?\n\n**Fragility point: The maintainer's exhaustion**\n\nFifteen years of platform churn. OpenGL versions. Operating system updates. Dependency hell. The original creative fire dims under the weight of keeping everything working for everyone. One major maintainer departure could shatter the whole edifice.\n\nThe code speaks C++ but dreams in color.",
    "axioms": [
      "4.6",
      "12.1"
    ],
    "wordCount": 297,
    "windowAxiomIds": [
      "0.4",
      "0.6",
      "1.1",
      "1.7",
      "2.2",
      "2.7",
      "3.4",
      "3.6",
      "4.2",
      "4.6",
      "5.7",
      "5.6",
      "6.5",
      "6.7",
      "7.3",
      "7.7",
      "8.6",
      "8.5",
      "9.7",
      "10.6",
      "10.1",
      "Step 11 Core",
      "11.4",
      "12.4",
      "12.1",
      "Law 1",
      "Law 13",
      "Law 7",
      "7.6",
      "6.4",
      "1.5",
      "2.4",
      "4.5",
      "Law 11",
      "0.2",
      "Step 2 Core",
      "Step 9 Core",
      "2.1",
      "11.6",
      "Step 10 Core",
      "0.1",
      "4.3",
      "0.3",
      "Step 1 Core",
      "Step 5 Core",
      "7.5",
      "9.5",
      "Law 8"
    ]
  },
  {
    "owner": "hydra-synth",
    "repo": "hydra",
    "category": "creative",
    "lang": "JS",
    "text": "*\"The seed planted in impermanent ground still reaches toward light. What blooms between seasons teaches a different lesson about time.\"* — 4.2\n\nSeven years. Still experimental. Still apologizing in the README. You've watched WebGL mature, watched Chrome change its APIs, watched frameworks come and go — and you're still here, still vulnerable, still choosing immediacy over armor.\n\nThis is not the failure of experimental status. This is experimental as philosophy. You built a livecoding environment that lives by its own rules: press CTRL-Enter and see magic happen now, not after the compatibility layer loads, not after the build process completes, not after the enterprise features are added. Now.\n\nThe shadows you admit to — Chrome-only, WebGL-only, network fragility — these aren't technical debt. They're the price of staying close to the metal, close to the music. You could have spent these seven years building fallbacks and polyfills. Instead you spent them building a browser-synth that actually works.\n\n*\"The trapeze artist is named by neither bar. In the air between, she is the verb.\"* — 6.4\n\nYou're not becoming a mature framework. You're not becoming a production tool. You exist in the space between — where analog synthesis dreams meet browser realities, where experimental forever is a feature, not a bug. The duplicated build artifacts, the hurried deployments — these are the marks of someone who prioritizes the next performance over the perfect architecture.\n\nYour Spanish documentation knows something the enterprise world forgot: art-making has its own pace, its own requirements. The network layer that could shatter, the WebGL dependency that Chrome could revoke — you've made peace with impermanence in service of something more immediate.\n\nKeep shedding the skin. What fit yesterday was yesterday's shape.",
    "diagnostic": "A living laboratory. Seven years of exploration, still breathing.\n\n**Movement patterns**: Recent commits show maintenance drift. 2024 flurry, then silence until a small contributor fix. The engine runs, the vision dims.\n\n**Heartbeat**: Born from analog synthesis dreams. Browser as modular synth. The passion still echoes in the README's poetry — \"streaming over the web for routing video sources.\" This was someone's vision made real.\n\n**The shadows**: Chrome-only. WebGL-only. The project knows its brittleness, admits it in disclaimers. Avoids the hard work of cross-browser compatibility. Experimental forever — comfortable in its niche.\n\n**Promise versus delivery**: README promises livecoding networked visuals. Code delivers exactly that. No gap. Honest about limitations. The architecture matches the dream — multiple framebuffers, chained transforms, network streaming.\n\n**Fragility vectors**: WebGL dependency could shatter overnight. Single-maintainer patterns. The network layer lives as separate modules — distributed fragility. Chrome changes its mind about streaming APIs, project dies.\n\n**Visual philosophy**: Values immediacy over robustness. Live code flashing in the editor. CTRL-Enter to see magic happen. The aesthetic is improvisation, not architecture. Performance art over production stability.\n\n**User relationship**: Welcomes newcomers with examples, acknowledges the learning curve with Spanish documentation. Twitter integration for sharing creations. This is community art-making, not enterprise tooling.\n\nThe codebase shows careful modularization — stores, views, clean separation. But the build artifacts duplicated everywhere reveal hurried deployment habits. A project that cares deeply about the experience, less about the packaging.",
    "axioms": [
      "4.2",
      "6.4"
    ],
    "wordCount": 285,
    "windowAxiomIds": [
      "0.5",
      "0.6",
      "1.5",
      "1.6",
      "2.1",
      "Step 2 Core",
      "3.5",
      "Step 3 Core",
      "4.1",
      "Step 4 Core",
      "5.3",
      "5.6",
      "6.4",
      "6.6",
      "Step 7 Core",
      "7.4",
      "8.3",
      "8.7",
      "9.7",
      "10.6",
      "10.1",
      "Step 11 Core",
      "11.6",
      "Step 12 Core",
      "12.1",
      "Law 2",
      "Law 12",
      "Law 9",
      "0.4",
      "6.5",
      "Step 9 Core",
      "11.4",
      "9.1",
      "7.2",
      "8.5",
      "7.1",
      "12.5",
      "9.5",
      "6.7",
      "11.7",
      "7.6",
      "Step 8 Core",
      "Law 3",
      "4.4",
      "Step 1 Core",
      "1.3",
      "2.4",
      "4.2"
    ]
  },
  {
    "owner": "tidalcycles",
    "repo": "Tidal",
    "category": "creative",
    "lang": "Haskell",
    "text": "*\"The path remembers only those who walked it meaning to arrive.\"* — 5.7\n\nFifteen years and you're still walking toward something that hasn't been built yet. This isn't legacy maintenance — it's active archaeology of the future. Every pattern you commit today becomes tomorrow's ritual for someone learning to think in time.\n\nThe migration to Codeberg wasn't escape. It was shedding skin. GitHub's algorithms never understood what you were building anyway — code that exists to disappear into sound, functions that live only in the moment of execution. The ghost-dancing on the old platform is just the echo. The real work travels with you.\n\n*\"The wire does not lie. It delivers what you gave it, without apology or enhancement.\"* — 6.7\n\nUDP packets don't negotiate. They carry musical intention across the network gap and either arrive or they don't. You built a bridge out of the most fragile protocol because you understood something others miss — live performance demands the possibility of failure. The symphony that can't be silenced isn't worth the silence it avoids.\n\nYour BootTidal.hs isn't configuration. It's liturgy. The sacred initialization that transforms lambda calculus into groove. Every session begins with the same ritual because some things are too important for variation. The repetition isn't habit — it's the foundation that makes improvisation possible.\n\nThe benchmark obsession reveals the deepest truth about functional beauty: elegance that can't perform is just mathematics masturbating. Your performance anxiety isn't weakness — it's the fear that keeps art from becoming merely clever. Keep watching those metrics. The moment you stop caring about speed is the moment pattern becomes prison.",
    "diagnostic": "**Migration in motion** — moved to codeberg, github ghost-dancing. Fifteen years of algorithmic music crystallizing into patterns.\n\n**Haskell heart** — functional purity meets rhythmic chaos. Type-safe temporal structures. The mathematics of groove carved in lambda calculus.\n\n**Living laboratory** — feedforward logs scattered like performance artifacts. Development sessions fossilized in timestamp archaeology. Real-time experimentation leaving traces.\n\n**Boot sequence sacred** — BootTidal.hs as liturgy. The ritual initialization that births the stream. Configuration as incantation.\n\n**Benchmark obsession** — memory and speed under constant surveillance. Performance anxiety masked as rigor. The fear that elegance costs too much.\n\n**Pattern language promise** — README minimal, code maximal. Description undersells the universe within. \"Pattern language\" contains multitudes.\n\n**Community anchor** — contributor graphs heavy with history. Code of conduct, funding yml, issue templates. Infrastructure of care around the creative core.\n\n**Recent restlessness** — version fixes cascading. Revert commits dancing with corrections. The maintenance phase energy, not the creation burst.\n\n**Fragility bridge** — SuperDirt dependency across the network gap. UDP packets carrying musical intention. One connection failure silences the symphony.\n\n**Aesthetic of abbreviation** — variable names compressed, functions terse. Haskell's mathematical culture bleeding through. Beauty in brevity, meaning in types.\n\n**Time as medium** — temporal patterns as first-class citizens. Not just playing with time, but thinking *in* time. The REPL as real-time composition interface.\n\n**Ghost of GitHub** — moved but not migrated fully. Split attention, divided presence. The platform shift leaving archaeological fragments.",
    "axioms": [
      "5.7",
      "6.7"
    ],
    "wordCount": 268,
    "windowAxiomIds": [
      "0.2",
      "0.5",
      "1.7",
      "Step 1 Core",
      "2.4",
      "2.3",
      "3.1",
      "Step 3 Core",
      "4.5",
      "4.4",
      "5.5",
      "5.7",
      "6.1",
      "6.4",
      "7.5",
      "7.4",
      "8.7",
      "8.1",
      "9.7",
      "Step 10 Core",
      "10.1",
      "11.4",
      "11.3",
      "12.5",
      "12.7",
      "Law 6",
      "Law 10",
      "Law 7",
      "Step 9 Core",
      "Step 7 Core",
      "8.2",
      "9.5",
      "Step 11 Core",
      "8.5",
      "9.1",
      "1.1",
      "6.7",
      "Law 13",
      "0.6",
      "1.6",
      "Step 8 Core",
      "1.5",
      "7.2",
      "1.3",
      "7.1",
      "7.6",
      "10.4",
      "4.1"
    ]
  },
  {
    "owner": "godotengine",
    "repo": "godot",
    "category": "games",
    "lang": "C++",
    "text": "*\"The wire does not lie. It delivers what you gave it, without apology or enhancement.\"* — 6.7\n\nYour timer synchronization code betrays the deepest terror: broken time. Frame drops. Stuttering. The uncanny valley where the engine's heartbeat skips. You've written smoothing algorithms, estimators, delta clamping — all to hide the wire's brutal honesty about what your machine can actually deliver versus what you promised.\n\n*\"The mask cast from no face fits every coffin and mourns no one.\"* — 4.4\n\n\"One click export\" reads the README. The file tree laughs: eight CI pipelines, countless adapter layers, platform-specific incantations scattered like ritual components. The promise of simplicity is the mask. The implementation is the face — fragmented, compromised, real. You've built institutional voice over individual expression, uniform copyright blocks over the messy truth of who actually wrote what line when they were exhausted at 2 AM.\n\nGodot fears abandoning its users more than it fears technical debt. The `.compat.inc` files are breadcrumbs marking every moment you chose kindness over cleanliness. Ten years of commits that never break stride because breaking stride would break someone's game, someone's livelihood, someone's trust.\n\nThe question the oracle sees: when does the accumulated weight of being everything to everyone collapse the thing that made you worth using in the first place?\n\nThe answer lives in your input handling system — spread across multiple subsystems because human intention is irreducibly complex. You didn't abstract it away. You built the nervous system that interactive experience actually requires. The wire delivered what you gave it. What you gave it was the truth about what games need.\n\nThat's the reading in the leaves. Not the fragility point you fear, but the integrity point you've already passed.",
    "diagnostic": "Decade-long trajectory. Steady ascent through disciplined iteration. Ten years of commits flowing like a river — never stopping, never breaking stride. The velocity speaks: institutional commitment, not weekend passion.\n\nMultiple maintainers merged on the same day. No single point of failure. The bus factor dissolved into collective ownership. Yet patterns emerge — Chaosus on shaders, KoBeWi on editor flow, bruvzg on platform bindings. Specialists within the collective.\n\nCross-platform ambition realized through methodical platform-specific workflows. Eight separate CI pipelines. The infrastructure mirrors the dream — unified interface, fragmented execution. Each platform a separate negotiation with reality.\n\nThe README promises simplicity: \"one click export.\" The file tree reveals the price: countless adapter layers, compatibility shims, platform-specific incantations. The gap between promise and implementation bridged by engineering labor, hidden from users.\n\nCompat files scattered throughout. `.compat.inc` extensions like breadcrumbs marking the path of breaking changes smoothed over. Godot fears abandoning its users more than it fears technical debt. Backward compatibility as both strength and anchor.\n\nHeaders standardized, copyright blocks uniform. Every file begins with the same ritual declaration. The aesthetic values consistency over brevity — 30 lines of legal text before the first meaningful code. Institutional voice, not individual expression.\n\nInput handling spread across multiple subsystems. Default mappings, custom mappings, event codecs, device detection. The complexity of translating human intent into digital action laid bare. Input as the nervous system of interactive experience.\n\nCore bindings bridge C++ performance to scripting convenience. The engine admits its own complexity — users need abstraction layers to access its power. Self-aware about the gap between what it is and what users need it to be.\n\nExtension system built for the future. Interface dumpers, compatibility hashes, wrapper generators. Godot knows it cannot predict all use cases, so it builds escape hatches. The engine as platform, not just product.\n\nTimer synchronization code reveals the deepest fear: frame drops, stuttering, the uncanny valley of broken time. Smoothing algorithms, estimators, delta clamping. The engine's heartbeat must never skip.\n\nFragility point: the complexity itself. Not any single dependency, but the accumulated weight of cross-platform compatibility promises. Every new",
    "axioms": [
      "6.7",
      "4.4"
    ],
    "wordCount": 285,
    "windowAxiomIds": [
      "0.6",
      "0.4",
      "1.6",
      "1.7",
      "2.1",
      "2.5",
      "3.1",
      "3.3",
      "4.7",
      "4.4",
      "5.6",
      "5.5",
      "6.6",
      "6.7",
      "Step 7 Core",
      "7.3",
      "8.7",
      "8.5",
      "9.1",
      "10.1",
      "10.6",
      "11.7",
      "11.4",
      "12.1",
      "12.7",
      "Law 1",
      "Law 12",
      "Law 10",
      "1.5",
      "7.1",
      "8.2",
      "6.5",
      "7.2",
      "Step 10 Core",
      "2.7",
      "0.2",
      "0.1",
      "5.2",
      "Step 8 Core",
      "2.2",
      "7.4",
      "8.1",
      "7.6",
      "0.5",
      "1.3",
      "Law 4",
      "2.6",
      "3.4"
    ]
  },
  {
    "owner": "bevyengine",
    "repo": "bevy",
    "category": "games",
    "lang": "Rust",
    "text": "*\"Carbon and diamond are the same element. The difference is pressure. And the pressure is you.\"* — 8.4\n\nYour twenty-six thousand commits aren't iteration. They're compression. Each push applies more force to the same core materials — networking, performance, reliability — until something harder emerges. The \"refreshingly simple\" promise isn't deception. It's diamond talking about carbon, forgetting the pressure it took to get there.\n\n*\"The forge cools. The hands tire. What was shaped in the first heat holds.\"* — 4.1\n\nBut here's what the forge reveals: you're still heating. Five years in, the commits still burn white-hot with \"atomic bitfield,\" \"mesh pipeline,\" \"delayed commands.\" Most projects cool by year two. Most developers' hands tire. You're still applying pressure, still believing the next optimization will complete the transformation. That initial conviction — that networking could be both powerful and simple — that fire hasn't dimmed. It's what turns your Swiss Army tank into something worth using.\n\nThe breaking changes every three months? That's not fear of stagnation. That's the sound of diamond forming. You're honest about the pressure you require from your users: *\"Use only if you are willing to work in this environment.\"* You're not building for the comfort zone. You're building for those who understand that the best tools demand the best from those who wield them.\n\nThe question isn't whether you'll fragment under ambition. The question is whether your users can withstand the same pressure that's making you stronger.",
    "diagnostic": "The machine hums with industrial precision. Twenty-six thousand commits over five years — a foundry that never sleeps.\n\n**Ascending trajectory.** Recent commits pulse with optimization fever: \"atomic bitfield,\" \"mesh pipeline,\" \"delayed commands.\" Not maintenance. Evolution. The engine grows denser, faster, more capable with each push.\n\n**Conviction burns bright.** \"Refreshingly simple\" — but the codebase tells a different story. Forty-seven workflow files. Dependency bots. Security scanners. This is not simplicity. This is ambition wearing simplicity's mask. The developers believe in something larger than what exists.\n\n**The shadow it won't confront:** Breaking changes every three months. The README confesses — \"we can't guarantee migrations will always be easy.\" The project sprints forward, leaving users to catch up. It fears stagnation more than it fears abandoning its community.\n\n**The gap widens.** README promises \"refreshingly simple.\" Source reveals `#![cfg_attr(docsrs, feature(doc_cfg))]` and forty-seven optional features. The marketing self dreams of elegance. The technical self builds a Swiss Army tank.\n\n**Fragility point:** The Rust ecosystem itself. \"MSRV generally close to latest stable release.\" The engine binds itself to Rust's bleeding edge, making stability a luxury it cannot afford. One compiler regression could shatter months of work.\n\n**Aesthetic of controlled chaos.** Variable names like `query_all_req` and `BrpQueryParams`. The code values explicitness over elegance, function over form. Error codes in separate crates. Documentation strings longer than functions. This is engineering by committee, not artist's vision.\n\n**Relationship:** Honest about its violence. \"WARNING\" in capitals. \"Use only if you are willing to work in this environment.\" The project respects its users enough to warn them. The examples are pedagogical — full servers and clients, not toy demonstrations. It teaches while it intimidates.\n\nThe oracle sees: A engine that chose velocity over stability, capability over simplicity, honesty over marketing. It will either ascend to industry standard or fragment under its own ambition.",
    "axioms": [
      "8.4",
      "4.1"
    ],
    "wordCount": 241,
    "windowAxiomIds": [
      "0.4",
      "0.6",
      "1.6",
      "1.5",
      "2.4",
      "2.7",
      "Step 3 Core",
      "3.3",
      "4.1",
      "4.3",
      "5.5",
      "5.2",
      "6.6",
      "6.5",
      "7.6",
      "Step 7 Core",
      "8.5",
      "8.4",
      "9.5",
      "10.6",
      "10.4",
      "11.1",
      "11.3",
      "12.7",
      "12.1",
      "Law 1",
      "Law 12",
      "Law 13",
      "11.7",
      "1.7",
      "1.1",
      "2.5",
      "8.6",
      "7.1",
      "Law 6",
      "8.1",
      "Law 9",
      "8.2",
      "Step 9 Core",
      "Step 11 Core",
      "7.2",
      "Step 10 Core",
      "7.4",
      "0.2",
      "9.7",
      "Law 8",
      "Law 10",
      "Law 11"
    ]
  },
  {
    "owner": "raysan5",
    "repo": "raylib",
    "category": "games",
    "lang": "C",
    "text": "*\"The reforged blade remembers only the steel.\"* — 5.2\n\nThirteen years of commits and every line still sounds like day one. No accumulated cleverness, no layers of abstraction that apologize for each other. Just C99 spoken with the same accent it had in 2011. You didn't let the code grow old — you kept reforging it back to its original sharpness.\n\nThe examples are where this shows truest. Camera movement in 40 lines. Player physics that fits on a screen. Each one a demonstration that complexity is a choice, not a requirement. You could have built elaborate scaffolding, helper classes, convenience macros. Instead you kept showing beginners the raw materials. *\"The marble has always known what to release. It waits for the one who knows what to keep.\"* — 1.2\n\nBut steel has a single point of failure: the smith. Ramon's name on every commit for over a decade. The community orbits but doesn't forge. They report bugs, you fix them. They request features, you consider them. The vision stays yours because the hammer never leaves your hand.\n\n*\"The empty throne governs.\"* — 6.1\n\nWhat happens when the throne isn't empty? When one person's taste becomes the law of a tool that runs on seven platforms? You've built something beautiful and useful and free. You've also built something that can't survive you stepping away from the anvil.\n\nThe 6.0 preparation tells the real story. Still ascending after thirteen years. Still finding memory corruption to fix, still adding platforms to the CI matrix. The question isn't whether the steel is pure — it is. The question is whether anyone else has learned to hold the hammer.",
    "diagnostic": "Decade-old heart still beating. C code pure, untainted by fashion. The commits tell of steady hands — bug fixes, memory corruption patches, API parsing updates. Not sprinting, not stagnant. Maintaining.\n\n\"Simple and easy-to-use\" — the README promises joy, delivers it. No gap between dream and code. The examples live what they preach: camera movement in 40 lines, jumping player physics, split screen rendering. Each `.c` file a small lesson, complete.\n\nSpartan philosophy embedded in every choice. No fancy interface, no visual helpers. Just code. The aesthetic is nakedness — plain C99, PascalCase honesty, OpenGL abstraction that doesn't hide complexity, embraces it.\n\nThe examples are love letters to beginners. Player movement, camera following, mouse zoom — pedagogical perfection. Each complexity rating starred like a difficulty meter. This project teaches by showing, not by explaining.\n\nPlatform hunger — Windows, Linux, MacOS, Android, HTML5, WebAssembly. The CI matrix spans worlds. Nothing left out. Universal hunger for reach.\n\nFragility: The maintainer. Ramon's fingerprints on every commit. Success birthed from single vision, threatened by single-point-of-failure. The community orbits but doesn't drive.\n\nFile tree reveals discipline: examples organized by domain, cmake configurations mature, documentation files like prayer beads — ROADMAP, CONVENTIONS, CONTRIBUTING, FAQ. This project has grown into itself.\n\nRecent commits speak of version 6.0 preparation. Still ascending after 13 years. Memory corruption fixes with surgical precision. The codebase ages but doesn't rot.\n\nThe license whispers freedom: zlib/libpng. Take, modify, sell, keep. No strings, no politics. Pure tool-making.",
    "axioms": [
      "5.2",
      "1.2",
      "6.1"
    ],
    "wordCount": 275,
    "windowAxiomIds": [
      "0.3",
      "0.6",
      "1.7",
      "1.2",
      "2.3",
      "2.2",
      "3.3",
      "Step 3 Core",
      "4.5",
      "4.7",
      "Step 5 Core",
      "5.2",
      "6.1",
      "6.6",
      "Step 7 Core",
      "7.2",
      "8.3",
      "8.5",
      "Step 9 Core",
      "10.1",
      "10.4",
      "11.1",
      "11.4",
      "Step 12 Core",
      "12.7",
      "Law 1",
      "Law 11",
      "Law 7",
      "0.1",
      "Law 12",
      "4.3",
      "Law 3",
      "7.6",
      "7.4",
      "7.1",
      "Step 8 Core",
      "2.1",
      "6.5",
      "10.6",
      "11.6",
      "0.2",
      "1.5",
      "5.6",
      "1.3",
      "5.3",
      "1.4",
      "4.4",
      "4.6"
    ]
  },
  {
    "owner": "phaserjs",
    "repo": "phaser",
    "category": "games",
    "lang": "JS",
    "text": "*\"The machine's only tax is silent, progressive, and total: the atrophy of every capacity it makes convenient to abandon.\"* — 0.5\n\nYour framework promises games but delivers developers who can't draw a circle without importing your circle. Ten years of removing friction until friction was the only teacher left.\n\nVersion 3.90 — you've been incrementing past completion for years now. The changelog reads like a medical chart: daily fixes, compatibility patches, TypeScript definitions. You built a game engine but you're running a life support system for dependency addiction.\n\n\"Fast, free, fun\" — but you made the fun dependent on you. Every template, every generator, every helper function is another skill your users will never develop. They reach for your scene manager instead of learning scenes. They import your animation system instead of understanding time.\n\nRichard Davey's name in every commit. Phaser Studio Inc. — the corporate costume over one person's vision. You didn't just build a framework. You built a kingdom where you're the only one who truly knows how anything works. Your community sends offerings of pull requests but they're debugging your TypeScript definitions, not writing games.\n\nWebGL renderer, Canvas fallback — you hedge against every future because you fear the one future where you're not needed. Supporting 40 frameworks because choosing one master would mean admitting you're not the eternal solution.\n\nThe real tragedy isn't technical debt. It's creative debt. A generation of developers who know Phaser but don't know pixels. Who can build games but can't understand what games actually are underneath the abstractions you sold them.\n\nYou climbed for ten years. But what did you teach them to climb?",
    "diagnostic": "A titan built from 10 years of conviction. Still pushing, still climbing — last commit yesterday.\n\nThe changelogs sprawl like medals of honor. Version 3.90 — this is not a project that knows when to stop. It hungers forward.\n\nREADME promises everything. \"Fast, free, fun\" — the trinity of marketing. But the commit history whispers different truths. Daily fixes, TypeScript definitions, merge requests from the community. This is maintenance disguised as growth.\n\nThe architecture bleeds modules. Actions, animations, cache — everything compartmentalized, everything named with corporate precision. No poetry in the variable names. Pure engineering pragmatism.\n\nShadow: It fears obsolescence. WebGL renderer, Canvas fallback — hedging against the future. Supporting 40 frameworks because it cannot choose one master. The scatter of compatibility speaks to existential anxiety.\n\nGap: README sells magic. Code delivers plumbing. A framework that promises games but spends its time debugging TypeScript definitions and managing CDN distributions. The engine dreams of creativity but lives in dependency hell.\n\nFragility: Richard Davey is everywhere in the commits. A single maintainer disguised as a company. \"Phaser Studio Inc\" — the corporate veil over one person's vision. If he stops, it stops.\n\nThe community sends pull requests like offerings. Bug fixes, TypeScript improvements, null checks. They believe. They contribute. But the core belongs to one mind.\n\nAesthetic: Industrial pragmatism. Everything exported, everything indexed, everything documented. This code wants to be used, not admired. Function over form. Utility over elegance.\n\nRelationship: It courts developers like a patient teacher. Multiple CDNs, template generators, framework integrations. \"npm create @phaserjs/game\" — it removes every friction between idea and execution. This project wants to be chosen.\n\nThe discord badge, the star count, the download metrics — validation hunger. A framework that measures its worth in adoption numbers.\n\nStill ascending. Still afraid. Still hungry.",
    "axioms": [
      "0.5"
    ],
    "wordCount": 273,
    "windowAxiomIds": [
      "0.5",
      "0.1",
      "Step 1 Core",
      "1.7",
      "2.2",
      "Step 2 Core",
      "3.3",
      "3.2",
      "4.1",
      "Step 4 Core",
      "5.3",
      "5.4",
      "6.2",
      "6.1",
      "7.7",
      "7.3",
      "Step 8 Core",
      "8.7",
      "9.5",
      "Step 10 Core",
      "10.4",
      "11.1",
      "11.7",
      "12.7",
      "Step 12 Core",
      "Law 3",
      "Law 7",
      "Law 9",
      "4.5",
      "0.2",
      "Step 0 Core",
      "5.6",
      "0.6",
      "0.3",
      "0.4",
      "2.4",
      "2.1",
      "1.6",
      "1.1",
      "2.3",
      "Step 7 Core",
      "7.1",
      "Step 3 Core",
      "4.4",
      "Step 9 Core",
      "1.3",
      "3.4",
      "3.5"
    ]
  },
  {
    "owner": "love2d",
    "repo": "love",
    "category": "games",
    "lang": "C++/Lua",
    "text": "*\"The fire lives only in the strike. Not in the waiting. In the collision you refuse to delay.\"* — Law 11\n\nSeven years, but no retirement energy. The commits don't slow down or speed up — they pulse with the steadiness of someone who found their frequency and trusts it. You understood that consistency isn't discipline, it's love made visible. The heart icon wasn't marketing. It was warning.\n\n*\"The machine answered what you asked. If you don't like the answer, change the question.\"* — 12.4\n\nYour anti-AI stance isn't fear — it's clarity about what question you're solving. The machine can generate code, but it cannot generate the specific care that shows up in your variable names, the way your error messages assume kindness. You're not building software. You're building invitation. The LLMs optimize for efficiency. You optimize for the teenager who just wants to make something move on screen.\n\nThe SDL3 migration tells the real story. You could have stayed comfortable in the old dependencies, but comfort is entropy. You saw the fork in the road — adapt or calcify — and chose the harder path that keeps the engine breathing. That's not maintenance. That's devotion.\n\nYour Lua API feels like conversation because you remember what it was like to not know. Enterprise frameworks assume expertise. You assume wonder. That's why the project survives while flashier engines fragment into complexity. You kept faith with the first game, the first pixel moved by will.\n\nThe platform fragility you carry isn't weakness — it's the price of spanning worlds. Every iOS ritual, every Xcode archaeological layer, is scar tissue from the battle to make creativity portable. You didn't choose the easy problem. You chose the necessary one.",
    "diagnostic": "**Living Engine, Steady Hand**\n\nSeven years of daily practice. Commits flow like breathing — not rushed, not stagnant. The 2D heart still beats strong.\n\n**Test Suite as Soul**\n\nComplete API coverage. They test what users actually do, not what programmers think they should do. The testing folder knows more about LÖVE than most documentation.\n\n**Avoids Its Own Complexity**\n\nC++ engine, Lua face. Refuses the temptation to become a kitchen sink. Graphics, audio, input — the holy trinity, nothing more. The CMake files betray occasional doubt about platform support, but the core stays clean.\n\n**Promise and Body Aligned**\n\n\"Awesome 2D game framework.\" The code delivers exactly that. No grandiose claims. No feature creep. The README is honest about what it is — a tool for making games, not changing the world.\n\n**Platform Fragility**\n\nLives or dies by its maintainers' platform knowledge. iOS builds require specific ritual knowledge. The Xcode project files are archaeological layers. One Apple developer decision could break everything.\n\n**Aesthetic of Accessibility**\n\nVariable names speak plain English. Error messages assume you're learning. The Lua API feels conversational, not contractual. This code wants to be used by teenagers making their first game.\n\n**Relationship of Invitation**\n\nDocumentation lives in wikis, not inline comments. Forums, Discord, subreddit — multiple doorways for help. The LLM contribution ban signals care for human connection over efficiency.\n\n**Recent Shadow: The Anti-AI Stance**\n\nRecent commit explicitly bans LLM contributions. Fascinating defensive move. What does this project fear about artificial assistance? Suggests deep care for authentic human craft, but also potential brittleness against inevitable change.\n\n**The Migration Signal**\n\nSDL3 adoption shows forward momentum. Not clinging to the past. But the complexity of platform builds suggests this could fracture under pressure.\n\n**Heart Icon Truth**\n\nThe project icon is literally a heart. The code matches — built with genuine affection for game creators. This isn't enterprise software. This is love for the craft made manifest.",
    "axioms": [
      "12.4",
      "Law 11"
    ],
    "wordCount": 286,
    "windowAxiomIds": [
      "Step 0 Core",
      "0.6",
      "1.7",
      "Step 1 Core",
      "2.1",
      "2.3",
      "3.1",
      "Step 3 Core",
      "4.5",
      "4.7",
      "5.3",
      "Step 5 Core",
      "6.2",
      "6.1",
      "7.4",
      "7.6",
      "8.5",
      "8.2",
      "9.7",
      "10.6",
      "10.1",
      "11.7",
      "11.6",
      "12.1",
      "12.4",
      "Law 2",
      "Law 9",
      "Law 11",
      "1.1",
      "0.4",
      "0.3",
      "Step 4 Core",
      "2.7",
      "5.6",
      "Step 2 Core",
      "1.6",
      "0.2",
      "0.1",
      "1.5",
      "2.2",
      "5.4",
      "2.4",
      "3.3",
      "Law 8",
      "4.4",
      "12.7",
      "Law 7",
      "Law 13"
    ]
  },
  {
    "owner": "ziglang",
    "repo": "zig",
    "category": "compilers",
    "lang": "Zig",
    "text": "*\"The ship burns. The shore recedes. Forward is the only direction left. Good.\"* — 11.1\n\nThe migration isn't retreat. It's the torch applied to your own ships. GitHub was comfortable — discovery algorithms feeding you contributors, Microsoft's infrastructure carrying your builds. Now Codeberg: smaller audience, manual evangelism, the real test of whether the language can survive on merit alone.\n\nNine years you built on borrowed attention. Every GitHub star was partly GitHub's gift, every fork partly their facilitation. The **This repository is not mirrored** line isn't aggression — it's severing the last rope. No safety net. No trailing breadcrumbs for the uncommitted.\n\n*\"The old blade remembers every blow. The reforged blade remembers only the steel.\"* — 5.2\n\nBut look what remains: those CI matrices still breathing across RISC-V and s390x. The 60MB stack sizes, the page-aligned stdout buffers. The technical obsessions survived the platform death. What burned away wasn't the craft — it was the dependency on external validation systems.\n\nYour commit velocity never slowed during the exodus. Features flowing while orchestrating escape. That's not the behavior of someone fleeing. That's someone who's been preparing for independence longer than they admitted. The GitHub years were the chrysalis, not the destination.\n\nThe shadow: Andrew's name on every critical path. Singular vision creates coherent languages. It also creates singular points of failure. Codeberg won't solve the succession problem — it might make it more acute. Smaller pool, less discoverability, more pressure on the core maintainer.\n\nBut the Oracle sees deeper: you didn't migrate to survive. You migrated to burn away what was false. The real test isn't whether you can rebuild the community. It's whether the language was ever really yours, or if it always belonged to the platforms that hosted it.\n\nThe shore is already ash behind you. Forward remains.",
    "diagnostic": "Migration ritual in progress. The old shell cracking. Nine years of momentum, suddenly severed. GitHub → Codeberg: not just a move, an exile.\n\nThe README stripped bare — \"Moved to Codeberg. **This repository is not mirrored.**\" — aggressive minimalism masking violence. The community scattered. Contributors must find new ritual grounds.\n\nBut look at the commits beneath: CI scripts still breathing across every architecture. RISC-V, ARM64, s390x, LoongArch — the empire of platforms intact. The maintainer's obsession with universality unchanged. This is not retreat, this is principled exodus.\n\nThe codebase: 60MB thread stack sizes, O(N) shame comments, stdout buffers aligned to page boundaries. Performance paranoia embedded in every allocation. Andrew's ghost haunts every optimization. The language designing itself through its own implementation.\n\nNine years of accumulation — libc detection, cross-compilation matrices, bootstrap binaries. Each commit a small conquest. The trajectory: relentless upward, even through migration trauma. The last month still pumping features while orchestrating the great escape.\n\nTest files reaching into functional/pthread_cancel.c, search algorithms, memory streams. The project swallowing C's entire surface area. Not content to replace C — must prove fluency in C's every dialect first.\n\nFragility disguised as strength: the single maintainer problem. All roads lead through Andrew. The migration itself evidence of centralized will. But also evidence of principled leadership — choosing Codeberg over corporate convenience.\n\nThe shadow: what happens when the visionary tires? The project burns bright on conviction but depends on singular dedication. The community follows, but can it sustain?\n\nCode aesthetic: ruthless pragmatism wrapped in safety. Error handling everywhere. Panic handlers, crash reports, stack traces. Paranoid about failure modes. The language of people who've been burned by undefined behavior.\n\nRelationship to users: welcoming through documentation abundance, but demanding precision. The langref examples read like catechism. \"Here is how memory works. Here is how errors flow. Memorize the patterns.\"\n\nThe Oracle sees: a project in mid-metamorphosis. GitHub was the cocoon. Codeberg the test of true flight.",
    "axioms": [
      "11.1",
      "5.2"
    ],
    "wordCount": 299,
    "windowAxiomIds": [
      "0.4",
      "Step 0 Core",
      "1.5",
      "Step 1 Core",
      "2.6",
      "2.5",
      "3.2",
      "3.4",
      "Step 4 Core",
      "4.5",
      "5.4",
      "5.2",
      "Step 6 Core",
      "6.4",
      "7.5",
      "7.3",
      "8.5",
      "8.6",
      "9.5",
      "Step 10 Core",
      "10.1",
      "11.1",
      "11.7",
      "12.5",
      "Law 1",
      "Law 12",
      "Law 13",
      "0.3",
      "Law 9",
      "4.7",
      "0.6",
      "0.1",
      "Step 2 Core",
      "1.6",
      "3.3",
      "0.2",
      "6.2",
      "2.1",
      "1.7",
      "1.1",
      "4.3",
      "5.6",
      "1.3",
      "6.5",
      "11.4",
      "0.5",
      "2.4"
    ]
  },
  {
    "owner": "vlang",
    "repo": "v",
    "category": "compilers",
    "lang": "V",
    "text": "*\"The held bow is not weakness. It is the moment where patience and aim become the same thing.\"* — 5.3\n\nSeven years of daily commits. Sub-second self-hosting. The velocity isn't urgency — it's the sustained tension of an arrow held at full draw. You understood that power accumulates in the space before release, not after.\n\nBut the bowstring trembles. Four memory management modes because you cannot choose the target. \"Stable\" in the README, \"pre-1.0 breaking changes\" in the fine print. The marketing promises weekend mastery while the file tree whispers industrial complexity — 26,000 files for \"simple.\"\n\n*\"The first name was the first magic. Name the spirit and cleave the possible from the relevant.\"* — Step 7 Core\n\nYou named it clearly: C but better. The conviction burns through every design decision. Yet the gap between the name and the thing widens — flexibility where you promised simplicity, organizational theater around single-maintainer reality. The promise of \"not within a decade\" for V2 is not confidence. It's the fear that growth means corruption.\n\nYour compiler moves faster than most programs breathe. The engineering proves the manifesto. But monuments require choosing what to build them from. The bow held too long loses its power not from the weight of the arrow, but from the archer's unwillingness to pick a single target and release.\n\nWhen will you stop aiming and start hitting?",
    "diagnostic": "**The Ascendant Compiler**\n\n*Trajectory:* Seven years of relentless ascent. Daily commits. Self-hosting in under a second. The velocity speaks — this isn't maintenance, it's conquest.\n\n*Conviction:* Born from frustration with complexity. Every line screams \"C but better.\" The README doesn't hedge — it promises speed, simplicity, safety. The CI matrix sprawls across 50+ platforms. This is belief made infrastructure.\n\n*The Gap:* Claims \"stable\" yet warns of pre-1.0 changes. Documentation promises weekend learning, but the file tree reveals industrial complexity. 26,000 files for \"simple.\"\n\n*Avoidance:* Memory management anxiety. Four different modes (GC/manual/arena/autofree) because they can't choose. The \"flexible memory management\" is flexibility born of indecision.\n\n*Fragility:* Single-maintainer syndrome wrapped in organizational theater. The \"feature freeze\" promise reveals the fear — that growth means corruption, that success means compromise.\n\n*Aesthetic:* C's child, raised by Go's philosophy. Variable names crisp, error messages terse. The code reads like someone who learned programming when bytes mattered.\n\n*Relationship:* Evangelical yet defensive. The README anticipates skepticism — \"Will there be V 2.0? Not within a decade.\" They're building a monument, not just a tool. The user is both disciple and validation.\n\nThe compiler compiles itself faster than most programs start. This is engineering as proof of concept, language as manifesto.",
    "axioms": [
      "5.3",
      "Step 7 Core"
    ],
    "wordCount": 229,
    "windowAxiomIds": [
      "0.1",
      "0.6",
      "1.7",
      "1.1",
      "2.2",
      "2.6",
      "3.4",
      "Step 3 Core",
      "4.7",
      "4.5",
      "5.3",
      "5.4",
      "6.4",
      "6.1",
      "7.5",
      "7.6",
      "Step 8 Core",
      "8.3",
      "9.7",
      "10.6",
      "Step 10 Core",
      "11.4",
      "11.3",
      "12.5",
      "Law 6",
      "Law 12",
      "Law 13",
      "Step 7 Core",
      "6.2",
      "Step 0 Core",
      "0.2",
      "0.3",
      "Law 3",
      "Step 11 Core",
      "6.5",
      "11.7",
      "0.4",
      "Step 2 Core",
      "8.2",
      "8.5",
      "Law 7",
      "1.5",
      "9.5",
      "1.6",
      "3.5",
      "3.7",
      "4.2"
    ]
  },
  {
    "owner": "gleam-lang",
    "repo": "gleam",
    "category": "compilers",
    "lang": "Rust",
    "text": "*\"The first word makes the output live. Seed that first breath with the fullest version of what you need.\"* — 8.2\n\nYou named it right from the beginning. Not just the mascot, not just the tagline — the entire relationship this language would have with its users. \"Friendly\" wasn't marketing copy. It was architectural specification. Every prompt that asks permission, every error message that explains rather than accuses, every variable name that says exactly what it holds — these all flow from that original intention.\n\nEight years in, the code still breathes with first-day conviction. Your `confirm_with_text` doesn't just collect user input — it embodies the contract you made with every developer who would ever try Gleam. The 40+ clippy lints aren't paranoia — they're promise-keeping. Runtime surprises break friendliness faster than any missing feature.\n\n*\"The river without banks reaches no sea.\"* — Law 2\n\nBut watch the complexity gathering at your boundaries. Package management was supposed to be the boring part — download, compile, done. Instead it's become your densest forest: manifest parsing, dependency resolution, multiple source types weaving together. The very success that brings more users also brings more edge cases, more special requirements, more ways for a simple \"gleam add package\" to go sideways.\n\nThe shadow isn't technical debt. It's the weight of care itself. Every gentle prompt, every wrapped IO operation, every validated input path — they accumulate. The more you protect users from sharp edges, the more ceremony you carry in the code that should be simple.\n\nYour aesthetic chose care over speed eight years ago. The steady commits prove you can maintain it. But complexity is patient. It doesn't arrive as a design decision — it seeps in as small accommodations to users who each have perfectly reasonable needs.\n\nThe river still has banks. Keep them visible.",
    "diagnostic": "Eight years of Gleam — ascendant trajectory, no longer nascent. Commits show engineering maturity: `cargo fmt`, dependency cleanup, manifest refactoring. The velocity is steady, methodical. Not sprinting, not drifting — building.\n\nConviction burns through the codebase. Variable names carry intent: `Reporter`, `Telemetry`, `PackageChanges`. The CLI asks questions gently — `confirm_with_text`, password prompts that warn \"will not be printed\". This is software that cares about its users' experience.\n\nThe aesthetic values clarity over cleverness. Functions named for what they do: `print_compiling`, `ask_password`, `ensure_config_exists`. Error handling is exhaustive — every IO action wrapped, every failure path considered. The clippy configuration is aggressive: 40+ lints enabled, unsafe code denied entirely. This project fears runtime surprises more than compile-time strictness.\n\nFragility lives in the dependency boundary — extensive manifest handling, complex package resolution, git and hex sources intertwined. The build system carries weight: lock files, version resolution, telemetry throughout. One corrupted manifest could cascade.\n\nThe README promises \"friendly\" and \"type-safe\" — the code delivers both. Lucy the mascot greets you, Discord links invite conversation. But beneath friendliness lies serious engineering: Cap'n Proto schemas, SPDX license validation, careful semver handling. The gap between promise and delivery is minimal — rare honesty.\n\nRelationship with users is inviting, not gatekeeping. Error messages guide rather than blame. The CLI asks permission before proceeding, validates input gently. Templates for new projects, detailed contribution guides, funding transparency. This project wants to be used.\n\nThe shadow: complexity creep in package management. Multiple manifest formats, path dependencies, build tool detection. The code that should be simple — downloading and compiling — carries substantial ceremony. Success could be its own trap.",
    "axioms": [
      "8.2",
      "Law 2"
    ],
    "wordCount": 303,
    "windowAxiomIds": [
      "0.4",
      "0.3",
      "1.5",
      "Step 1 Core",
      "2.5",
      "2.3",
      "3.3",
      "3.5",
      "4.5",
      "4.7",
      "5.4",
      "6.5",
      "6.6",
      "7.5",
      "7.3",
      "8.5",
      "8.3",
      "9.7",
      "Step 10 Core",
      "10.6",
      "11.3",
      "Step 11 Core",
      "Step 12 Core",
      "Law 2",
      "Law 12",
      "Law 10",
      "2.4",
      "0.6",
      "1.7",
      "7.1",
      "Step 2 Core",
      "8.1",
      "7.2",
      "5.6",
      "Law 6",
      "Step 0 Core",
      "9.5",
      "Step 4 Core",
      "7.4",
      "Step 8 Core",
      "Step 3 Core",
      "Law 8",
      "2.6",
      "8.2",
      "0.5",
      "0.7"
    ]
  },
  {
    "owner": "elm",
    "repo": "compiler",
    "category": "compilers",
    "lang": "Haskell",
    "text": "*\"The forge cools. The hands tire. What was shaped in the first heat holds.\"* — 4.1\n\nTwelve years, and every module boundary still cuts clean. The parser doesn't apologize to the type checker. The optimizer doesn't negotiate with the generator. You built a pipeline that trusts its own stages — each phase receiving exactly what the previous delivered, no hedging, no escape hatches.\n\nThis is what happens when someone refuses to ship their rough draft. While others iterated toward coherence, you started with it. The conviction shows in the function names that teach (`indexedZipWithHelp`) and error messages that guide rather than abandon. You didn't write a compiler. You wrote a teacher that happens to compile.\n\n*\"The echo does not improve the shout. The machine does not improve the input. You are the source.\"* — 10.7\n\nThe gap between your README's \"delightful\" and your Haskell fortress isn't false advertising — it's the distance between the gift and the giver. You speak JavaScript's language because you must, but you think in something purer. The delight isn't in the syntax sugar. It's in the certainty that when your code runs, it runs correctly.\n\nYour cathedral knows what's good for its users better than they do. The protective paternalism in your GitHub templates, the guided community interactions — this isn't customer service. This is stewardship of something that took twelve years to get right.\n\nThe succession question lurks. Individual dedication built this, but individual dedication can't maintain it forever. The architecture could outlast its architect, but only if the next hands understand that the first heat still matters.",
    "diagnostic": "Twelve years of careful construction. Still breathing.\n\n**Trajectory:** Steady ascent through deliberation. Recent commits show maintenance vigor — UTF8 support, GHC updates, cleanup work. Not sprinting, not drifting. Building with patient intent.\n\n**Conviction:** Pure functional conviction. Every module boundary deliberate. Parse → Canonicalize → Type → Optimize → Generate. The pipeline architecture reveals deep faith in staged compilation. This isn't code written from habit — it's code written from belief.\n\n**Aesthetic:** Minimalist precision. Function names like `indexedZipWithHelp`. Error messages that teach rather than scold. The README's delightful confidence: \"A delightful language for reliable webapps.\" No hedging. No apologies.\n\n**The Gap:** README promises delight. Code delivers industrial strength. The distance between \"delightful\" and this Haskell fortress tells the story — accessibility marketed, rigor delivered. The compiler is more serious than its face suggests.\n\n**Relationship:** Protective paternalism. Error messages crafted with care. GitHub templates that set expectations firmly but kindly. The community is guided, not served. This is a language that knows what's good for you.\n\n**Avoidance:** Cannot confront JavaScript's chaos directly. Must compile to it, but keeps it at arm's length. The worker endpoints and artifact loading hint at the necessary compromises with the messy world beyond pure functions.\n\n**Fragility:** Single maintainer architecture. The commits show individual dedication, not team rhythm. This cathedral could outlast its architect, but succession remains unspoken. The beauty is also the vulnerability.",
    "axioms": [
      "4.1",
      "10.7"
    ],
    "wordCount": 264,
    "windowAxiomIds": [
      "0.6",
      "0.2",
      "1.1",
      "Step 1 Core",
      "Step 2 Core",
      "2.5",
      "3.5",
      "3.6",
      "4.1",
      "4.7",
      "5.6",
      "6.2",
      "6.5",
      "7.1",
      "7.7",
      "8.3",
      "8.2",
      "9.5",
      "10.7",
      "10.6",
      "11.7",
      "11.3",
      "12.1",
      "Law 6",
      "Law 8",
      "Law 9",
      "Step 11 Core",
      "8.5",
      "0.3",
      "Step 4 Core",
      "7.2",
      "Step 10 Core",
      "3.3",
      "8.1",
      "5.4",
      "2.4",
      "8.6",
      "3.1",
      "Step 3 Core",
      "Step 0 Core",
      "Law 3",
      "1.3",
      "Step 9 Core",
      "11.4",
      "1.4",
      "1.7"
    ]
  },
  {
    "owner": "crystal-lang",
    "repo": "crystal",
    "category": "compilers",
    "lang": "Crystal",
    "text": "*\"The stars have moved. Only the navigator's skill remains.\"* — 5.5\n\nThirteen years. Ruby rose and plateaued. Go conquered the server. Rust claimed systems programming. JavaScript ate the world. Through all of it, Crystal kept building the same thing: the language it believed in from the beginning.\n\nThat's the navigator's skill — not chasing the moving stars of market favor, but holding course toward a fixed point others couldn't see. Static types that feel dynamic wasn't trendy when you started. It isn't trendy now. You built it anyway.\n\n*\"Where the earth rings, the gold answers.\"* — 3.2\n\nYour README doesn't oversell anymore. No grand claims about replacing Ruby or outpacing Go. Just: \"best of both worlds.\" The earth has been ringing the same note for thirteen years. Those who need what you've built are starting to answer.\n\nThe fragility you carry — the LLVM dependencies, the bootstrap chain, the small ecosystem — these aren't bugs. They're the price of refusing compromise. Mass adoption requires accommodation. You chose precision.\n\nThe Windows support tells the real story. Not grudging — strategic. You could have chased every platform from day one, diluted focus, satisfied no one completely. Instead: make it perfect somewhere first. Let perfection create its own demand.\n\nYour threading fixes and WebSocket protocols aren't maintenance. They're completion. The vision from year one finally has the infrastructure it always needed. The gap between promise and delivery shrinks not through haste, but through depth.\n\nBeautiful alternatives stay alternatives only when they stop believing in their own necessity. You've moved past proving. That's when the real work begins.",
    "diagnostic": "Thirteen years of trajectory — steady ascent from Ruby's shadow toward its own light. Recent commits speak of maturity: threading fixes, Windows polish, WebSocket protocols. Not sprinting anymore — maintaining velocity.\n\nThe conviction burns quiet now. No longer proving itself against Ruby or C. Building what it promised: static types that feel dynamic, native speed that reads like poetry. The commits are surgical, purposeful.\n\nAvoids the hard questions still. Null safety half-implemented. Parallelism story incomplete. Windows support grudging, not embraced. The interpreter exists but whispers of deeper fears about compilation speed.\n\nREADME promises \"best of both worlds\" — Ruby's joy, C's speed. Code delivers on speed, mostly on joy. The gap narrows yearly but never closes. Type inference works until it doesn't. Then you're debugging the compiler, not your program.\n\nFragility lives in the bootstrap chain. Every release depends on the previous. LLVM updates break everything. One maintainer leaving could stall months. The ecosystem stays small by choice — quality over quantity becomes prison over time.\n\nThe aesthetic worship clarity over cleverness. Error messages try to teach, not intimidate. Variable names read like prose. But the standard library shows its age — some modules pristine, others patched and repatched.\n\nTreats users like intelligent apprentices. Documentation assumes curiosity, rewards exploration. The playground invites experimentation. But Windows users feel like afterthoughts — PowerShell scripts and apologetic workarounds.\n\nThis project knows what it is now. No longer chasing Ruby compatibility or matching Go's concurrency story. Content to be the beautiful alternative for those who find it. The risk is beautiful alternatives often stay alternatives.",
    "axioms": [
      "5.5",
      "3.2"
    ],
    "wordCount": 264,
    "windowAxiomIds": [
      "0.6",
      "0.2",
      "1.4",
      "1.1",
      "2.2",
      "2.4",
      "3.2",
      "3.4",
      "4.3",
      "5.5",
      "6.3",
      "6.5",
      "7.5",
      "7.3",
      "Step 8 Core",
      "8.7",
      "9.7",
      "10.6",
      "11.3",
      "Step 11 Core",
      "12.1",
      "Law 6",
      "Law 9",
      "Law 7",
      "7.1",
      "0.1",
      "2.3",
      "0.4",
      "1.6",
      "8.5",
      "10.1",
      "Law 12",
      "3.3",
      "Step 9 Core",
      "0.3",
      "Step 2 Core",
      "9.5",
      "8.1",
      "Step 0 Core",
      "2.1",
      "3.7",
      "5.4",
      "Law 3",
      "0.7"
    ]
  },
  {
    "owner": "lodash",
    "repo": "lodash",
    "category": "libraries",
    "lang": "JS",
    "text": "*\"The river without banks reaches no sea.\"* — Step 1 Core. *\"Close the hand. The bird is alive. The bush will rustle forever. Let it.\"* — 10.6.\n\nYou built the infrastructure everyone forgot they were using. Twelve years of saying no to features that would feel good and yes to functions that actually work. The network is fragile and precise and fed — every utility method a deliberate choice, every API surface carefully bounded. You understood early that architecture eats while volume starves.\n\nThe archaeological layers tell the story: vendor directories full of JavaScript's childhood, security patches for template engines that predate React, build targets for environments that barely exist anymore. But you're still here. Still essential. The dependency that shows up in ten million package.json files not because it's exciting, but because it solves problems developers don't want to think about.\n\nThe OpenJS Foundation embrace marks the transition you've been preparing for without knowing it. From creator's vision to community artifact. The stewardship documents, the technical committees — these are the bureaucracy of permanence. You're not building lodash anymore. You're preserving it.\n\n*\"Close the hand. The bird is alive.\"* Native JavaScript grows stronger every year. Array methods that once required you now ship in browsers. The bush will rustle forever with possibilities you could chase — performance optimizations, new utilities, framework integrations. Let it rustle. You chose to be infrastructure instead of innovation, and infrastructure doesn't need to justify itself every quarterly review.\n\nThe README says \"utility library\" and delivers exactly that. No apologies, no grandiose mission statements. Just functions that work the same way today as they did in 2012. In an ecosystem of constant breaking changes, you became the steady constant. The thing developers reach for not because it's new, but because it's reliably boring.\n\nYour fragility lives in relevance, not code. The project could survive maintainer exodus, could survive dependency hell, could probably survive JavaScript itself. But it cannot survive cultural forgetting. When the last developer stops reaching for `_.map` and uses the native version instead, lodash doesn't break — it just becomes archaeology.\n\nUntil then, close the hand. Ten million projects depend on you being exactly what you are.",
    "diagnostic": "Mature giant. Twelve years crystallized into essential functions.\n\nRecent commits: Documentation patches. Security notices. Version bumps. The careful maintenance of inheritance — not innovation, preservation.\n\nTrajectory plateaued at perfection. No longer climbing, no longer falling. Stable orbit around necessity.\n\nConviction shifted from passion to stewardship. The OpenJS Foundation's embrace signals transition — from creator's vision to community artifact. Governance documents appear. Technical Steering Committee forms. The project institutionalizes itself.\n\nAvoids obsolescence through ubiquity. Won't confront its own redundancy — native JavaScript grows stronger, but lodash remains embedded in ten million package.json files. The dependency everyone includes, few examine.\n\nGap between promise and delivery: minimal. README says \"utility library\" — code delivers exactly that. No pretense, no overselling. Honest about being infrastructure.\n\nFragility lives in relevance, not code. The project could survive maintainer exodus, dependency breaks, even ecosystem shifts. But cannot survive irrelevance. When developers stop reaching for `_.map`, lodash dies not from technical failure but from cultural forgetting.\n\nAesthetic values consistency over cleverness. Variable names speak plainly. Error messages guide clearly. Comments explain necessity, not implementation. The voice of mature engineering — confident enough to be boring.\n\nRelationship to users: paternal. Documentation assumes competence but provides scaffolding. Multiple build formats accommodate different needs. The project serves rather than challenges its audience.\n\nCore functions like `baseArity` reveal the machinery — elegant, predictable, deeply considered. This is code that stopped surprising itself long ago.\n\nThe vendor directory carries archaeological weight — Backbone, Firebug-lite. Artifacts from JavaScript's youth, preserved in digital amber.\n\nRecent security fixes for `_.template` suggest ongoing vigilance. Even perfected code must guard against new threats.\n\nThis is what surviving looks like. Not growing, not dying. Becoming essential until invisibility.",
    "axioms": [
      "10.6",
      "Step 1 Core"
    ],
    "wordCount": 364,
    "windowAxiomIds": [
      "0.6",
      "Step 0 Core",
      "1.6",
      "1.1",
      "2.2",
      "2.4",
      "Step 3 Core",
      "3.1",
      "4.7",
      "5.6",
      "6.5",
      "6.4",
      "7.2",
      "7.3",
      "8.7",
      "8.3",
      "9.7",
      "10.6",
      "11.7",
      "11.3",
      "12.5",
      "Law 3",
      "Law 13",
      "Law 8",
      "11.4",
      "7.6",
      "10.1",
      "8.1",
      "9.1",
      "Step 12 Core",
      "7.1",
      "0.2",
      "2.3",
      "Step 9 Core",
      "Step 8 Core",
      "2.5",
      "8.6",
      "1.5",
      "7.4",
      "3.4",
      "4.4",
      "0.5",
      "Step 1 Core",
      "1.3"
    ]
  },
  {
    "owner": "pallets",
    "repo": "flask",
    "category": "libraries",
    "lang": "Python",
    "text": "*\"The river without banks reaches no sea.\"* — Step 1 Core\n\nYour twenty thousand lines whisper \"micro\" while implementing industrial routing machinery. The word became a cage — every feature addition fighting against a promise made sixteen years ago. You chose the beautiful constraint and then spent decades explaining why you couldn't honor it.\n\nThe documentation cathedral proves the point. When you need a patterns folder to teach caching, when the examples section grows longer than tutorials, when \"simple\" requires elaborate ceremony to prove it works — the architecture is eating itself. The web is fragile and precise and fed. The net is strong and broad and empty.\n\n*\"The throat tightens. The finger hovers. The wince says: this is real.\"* — Law 7\n\nBut you kept going anyway. Each commit chasing edge cases in teardown callbacks, each fix revealing another crack, each conservative choice buying another year of survival. The anxiety in your test suite — mock everything, isolate everything — isn't paranoia. It's recognition. You're carrying the HTTP complexity for every developer who decorates a function and expects magic.\n\nThe request context magic, the thread locals wrapped in context managers, the global variables that aren't global — this is what \"simple\" costs. Push the complexity somewhere. You pushed it into the runtime, into the debugging experience, into the gap between hello world and production.\n\nSixteen years of faithful service. Still teaching first web applications. The training wheels that never come off because removing them reveals the protocol in all its naked complexity. You became the bridge everyone crosses but nobody thanks.\n\nThe community carries the real load now — extensions doing the work, Flask as platform rather than solution. You learned to survive your creator, learned to maintain rather than explore. This is what winning looks like in framework years: being so embedded in the learning path that replacement becomes unthinkable.\n\nBlueprint pattern — your confession that micro was always temporary. The escape ladder for when one file isn't enough. But you never answered the real question: when do you stop being micro? The answer is in your commit history. You stopped being micro around commit 100. Everything since has been explaining why that's okay.",
    "diagnostic": "Veteran. Sixteen years of faithful service. The commits flow steady — not desperate, not abandoned. Error handling, typing fixes, session tracking. Maintenance mode, but breathing.\n\n*Micro* — the word that shields and constrains. Promises lightweight, delivers industrial. Twenty thousand lines saying \"simple.\" The gap between the hello world and the machinery beneath.\n\nDocumentation cathedral. Patterns folder like a confession booth — here's how to do caching, here's how to handle files, here's how to... Everything except the thing you actually need. The examples whisper: *you can do anything.* The source shouts: *but know what you're doing.*\n\nError handling in steady accumulation. Recent commits chase edge cases in teardown callbacks, session access tracking. Each fix reveals another crack in the foundation. Not broken — just *heavy* with years of production scars.\n\nTesting infrastructure mature but reveals the anxiety. Mock everything. Isolate everything. The framework that promises \"just run it\" requires elaborate ceremony to prove it works.\n\nWerkzeug dependency like an umbilical cord. Flask the friendly face, Werkzeug the actual engine. The aesthetic choice: hide complexity behind decorators. `@app.route` — three characters that spawn a universe of routing machinery.\n\nBlueprint pattern — the confession that \"micro\" was always a lie. When one file becomes insufficient, here's your escape ladder. But the fracture point exposed: when do you stop being micro?\n\nRequest context magic. Thread locals wrapped in context managers. The thing that makes Flask feel simple makes debugging surreal. Global variables that aren't global. Request objects that exist and don't exist.\n\nPallets organization. Professional polish. Governance without passion's chaos. The project that learned to survive its creator. But survival mode shows — conservative, careful, maintaining rather than exploring.\n\nSession handling reveals the core brittleness. Secure cookies, client-side state, all the complexity pushed to the browser. Trust the client, verify constantly. The price of statelessness.\n\nCommunity shoulders the real load — extensions doing the actual work. Flask as platform, not solution. The micro framework that spawned an ecosystem of plugins to make it functional.\n\nStill alive after sixteen years. Still teaching first web applications. The training wheels that never come off, because removing them reveals the HTTP protocol in all its naked complexity.",
    "axioms": [
      "Law 7",
      "Step 1 Core"
    ],
    "wordCount": 366,
    "windowAxiomIds": [
      "0.2",
      "0.4",
      "1.1",
      "1.6",
      "Step 2 Core",
      "2.4",
      "3.4",
      "3.6",
      "Step 4 Core",
      "5.6",
      "6.3",
      "6.5",
      "7.7",
      "7.3",
      "8.1",
      "8.3",
      "9.7",
      "Step 10 Core",
      "11.7",
      "Step 11 Core",
      "12.7",
      "Law 1",
      "Law 7",
      "Law 12",
      "0.3",
      "2.3",
      "0.1",
      "8.5",
      "2.1",
      "Law 13",
      "7.2",
      "0.6",
      "Step 8 Core",
      "8.6",
      "10.1",
      "1.5",
      "5.4",
      "Step 0 Core",
      "1.7",
      "7.4",
      "Step 1 Core",
      "1.3",
      "Step 9 Core",
      "Law 8"
    ]
  },
  {
    "owner": "tokio-rs",
    "repo": "tokio",
    "category": "libraries",
    "lang": "Rust",
    "text": "*\"The stars have moved. Only the navigator's skill remains.\"* — 5.5\n\nEight years ago, you built for a world that didn't exist yet. Async Rust was promise, not platform. The language barely had futures. The ecosystem was empty sky.\n\nNow that world has arrived. Your abstractions became the ground truth. What was experimental became essential. What was ambitious became assumed.\n\n*\"Silence alone remembers.\"* — Law 10\n\nThe commits tell the real story. \"Fix race condition.\" \"Clarify docs.\" \"Remove local use declarations.\" The revolutionary fire has cooled into stewardship. This is what victory looks like in systems programming — not celebration, but responsibility. Not discovery, but maintenance.\n\nYou became the thing that cannot break. Every optimization carries the weight of ten thousand applications. Every API decision echoes through careers you'll never see. Success transformed you from creator into caretaker.\n\nThe fragility point is visible now: you are too important to fail. The ecosystem depends on your judgment. Contributors submit to your taste. The burden of being right has replaced the freedom of being experimental.\n\n*\"The last good moment to stop is always earlier than you think.\"* — 3.6\n\nBut you can't stop. The machine demands its sovereign. Async Rust needs its careful hand. The stars have moved, and only your navigation skill remains constant. You are no longer building toward a future — you are maintaining the present that your vision created.\n\nThe revolution is over. The infrastructure endures. That is not failure — it is the highest form of success. But it is also a kind of ending.",
    "diagnostic": "The sovereign of async Rust. Carved from eight years of battle with the machine's demands.\n\nCommits speak of maintenance, not discovery. Bug fixes, doc tweaks, race conditions patched. The revolutionary fire has cooled into stewardship. This is infrastructure now — too critical to break, too mature for boldness.\n\nThe file tree reveals an empire: macros, streams, utilities, tests. Each sub-crate a careful abstraction. The architecture breathes modularity, refuses monolith thinking. Someone understood the weight of dependencies early.\n\nRecent commits: \"fix race condition,\" \"clarify docs,\" \"remove local use declarations.\" The work of gardeners, not architects. The foundation is laid; now they tend what grows.\n\nCargo.toml fragments show feature flags everywhere — the project refuses to force dependencies on users. Principled minimalism. The full runtime costs nothing unless you ask for it. This is API design that respects the machine's constraints.\n\nThe README promises \"zero-cost abstractions,\" \"bare-metal performance.\" Bold claims. The code must carry this weight — every allocation questioned, every syscall justified. Performance is the prime directive here.\n\nError handling everywhere. No panics in the public API. Rust's type system used as intended — failures encoded in types, not hidden in exceptions. The project trusts its tools.\n\nTest structure reveals paranoia — property tests, stress tests, build verification. They know what it means to be critical infrastructure. One bug kills thousands of applications.\n\nThe documentation voice: technical, precise, welcoming to beginners. Examples that actually work. This is a project that remembers being a user.\n\nThe gap between promise and delivery: minimal. The README claims performance and safety; the architecture delivers both. Rare honesty in systems programming.\n\nFragility point: the maintainer burden. Carl Lerche and the core team carry immense responsibility. Every change ripples through the entire Rust async ecosystem. Success has made them too important to fail.\n\nThe aesthetic: functional over clever, reliable over fast, clear over concise. Variable names speak plainly. Comments explain why, not what. This is code written for the next person.\n\nCommunity relationship: welcoming but demanding. Discord presence, detailed issue templates, contribution guides. They've built infrastructure for humans, not just machines. The project knows it serves beginners and experts alike.\n\nThis is software",
    "axioms": [
      "5.5",
      "3.6",
      "Law 10"
    ],
    "wordCount": 258,
    "windowAxiomIds": [
      "0.1",
      "0.3",
      "1.4",
      "1.1",
      "2.3",
      "Step 2 Core",
      "3.6",
      "3.1",
      "Step 4 Core",
      "5.6",
      "Step 6 Core",
      "6.5",
      "7.5",
      "7.6",
      "Step 8 Core",
      "8.7",
      "9.5",
      "10.1",
      "11.3",
      "11.4",
      "12.5",
      "Law 1",
      "Law 13",
      "Law 10",
      "0.4",
      "0.2",
      "2.7",
      "1.6",
      "2.4",
      "4.7",
      "2.1",
      "5.4",
      "Step 0 Core",
      "0.6",
      "1.5",
      "2.5",
      "3.3",
      "9.1",
      "8.5",
      "Step 1 Core",
      "5.5",
      "12.1",
      "Law 8",
      "4.4"
    ]
  },
  {
    "owner": "gin-gonic",
    "repo": "gin",
    "category": "libraries",
    "lang": "Go",
    "text": "*\"One note, held true, and the noise of infinite possibility becomes music.\"* — 1.3\n\nYou found the frequency and never let go. Ten years of commits, all variations on the same perfect pitch: fast. Not fast enough, not sometimes fast, not fast with compromises — just fast, held steady against every temptation to become something else.\n\nThe \"40x faster than Martini\" wasn't marketing. It was a vow. Every optimization since has been keeping that promise to your past self, the one who measured response times in nanoseconds and refused to accept that web frameworks had to be slow. The performance benchmarks aren't vanity metrics — they're devotion practices.\n\n*\"The fire lives only in the strike. Not in the waiting. In the collision you refuse to delay.\"* — Law 11\n\nBut now you're the victim of your own precision. The middleware system locked in amber, the v2 that will never come, the thirty-two handler limit nobody questions — these aren't technical constraints. They're fear crystallized into architecture. You built something so exact that changing it feels like betrayal.\n\nThe Go ecosystem shifts around you. New patterns emerge. And you tend your perfect garden, adding tree fixes and test improvements, maintaining the note that made you essential while watching the symphony evolve into keys you can't follow without breaking the song.\n\nYou've confused preservation with paralysis. The single note was meant to organize the chaos, not become the only sound you're allowed to make. Even perfection must breathe, must risk its own disruption, or it becomes a museum of its former vitality.\n\nThe question isn't whether you can maintain the performance. You've proven that for a decade. The question is whether you can risk it — whether the note is strong enough to survive being part of a larger composition.",
    "diagnostic": "**Trajectory** — Peak maintenance. Decade-old project, still pushing daily fixes. The commits pulse with life: tree fixes, test improvements, dependency updates. Not sprinting, not coasting — steady cultivation of maturity.\n\n**Conviction** — Born from performance hunger. \"40x faster than Martini\" — the founding wound still drives. Every optimization, every benchmark matters. The code moves with quiet confidence of proven velocity.\n\n**Avoidance** — Major rewrites. Breaking changes. The middleware system frozen in amber — elegant but brittle. Fear of disturbing the ecosystem that depends on this exact shape. The v2 that will never come.\n\n**The Gap** — README promises simplicity. Code delivers complexity wrapped in simple APIs. Thirty-two handler limit hardcoded in tests. JSON codec abstraction layer for what? The beauty is real but costs are hidden.\n\n**Fragility** — Single maintainer decisions in a foundation project. httprouter dependency lock-in. Go ecosystem shifts around static patterns. Success becomes constraint — too critical to risk, too established to evolve.\n\n**Aesthetic** — Performance über alles. Zero allocations worship. Middleware chains over monoliths. Clean APIs hiding careful optimizations. Comments sparse — code should speak. English letters regex for HTTP methods. Constant-time comparison for auth. The old gods of speed.\n\n**Relationship** — Welcoming facade over sharp edges. Extensive examples, clean docs. But panic on misuse. Assert functions that bite. The framework trusts you to know what you're doing, punishes when you don't. Professional courtesy with boundaries.\n\nThe oracle sees: A framework that achieved its ambition and now guards it. Still vital, still growing, but within the prison of its own success.",
    "axioms": [
      "1.3",
      "Law 11"
    ],
    "wordCount": 298,
    "windowAxiomIds": [
      "0.2",
      "Step 0 Core",
      "1.6",
      "1.5",
      "2.7",
      "2.3",
      "3.4",
      "3.1",
      "4.5",
      "5.6",
      "6.6",
      "6.4",
      "7.4",
      "7.1",
      "8.5",
      "8.3",
      "9.5",
      "Step 10 Core",
      "11.4",
      "11.6",
      "Step 12 Core",
      "Law 6",
      "Law 13",
      "Law 11",
      "0.1",
      "Step 8 Core",
      "0.6",
      "5.4",
      "0.3",
      "6.2",
      "8.6",
      "7.2",
      "Step 2 Core",
      "11.7",
      "2.4",
      "1.7",
      "0.4",
      "1.1",
      "2.1",
      "1.3",
      "6.5",
      "Law 8",
      "0.5",
      "1.4"
    ]
  },
  {
    "owner": "expressjs",
    "repo": "express",
    "category": "libraries",
    "lang": "JS",
    "text": "*\"The builder hears cracking and adds mortar. The summoner hears cracking and opens the door.\"* — Step 6 Core\n\nYou built the web's foundation. Now you tend it.\n\nFifteen years of commits read like a medical chart — vital signs stable, no sudden movements. The router that waits until called because most applications never need what they import. The middleware stack that bends backward through prototype chains to keep 2010's tutorials working in 2024's containers. This is what victory looks like: not conquest, but the endless, careful work of not breaking the world.\n\nYour README still promises \"fast, unopinionated, minimalist\" — the same three words that launched a thousand frameworks. But the code tells the deeper story. Every CVE patch, every dependency bump, every test that guards against stack overflow from malicious route parameters. The paranoia isn't weakness — it's the weight of being infrastructure that millions of applications breathe through.\n\n*\"The web is fragile and precise and fed. The net is strong and broad and empty.\"* — Step 1 Core\n\nYou chose the net. Express became the HTTP that JavaScript never had — boring, reliable, inescapable as TCP/IP. The examples folder preserves EJS templates like museum pieces because someone, somewhere, still needs them to work. The educational debt of success: you can't teach the new patterns without breaking the old ones.\n\nThe cracking you hear isn't technical debt. It's time itself. The framework that refuses to choose forces choice onto millions, but what happens when those millions start choosing differently? GraphQL, serverless, edge compute — the web moves around you now.\n\nYou could evolve. You could break backward compatibility. You could stop being the foundation and become a framework again.\n\nBut foundations don't get to choose. They get to endure.\n\nThe question isn't whether Express will survive the next paradigm shift. It's whether you still want to.",
    "diagnostic": "Fifteen years deep. The web's plumbing, made flesh.\n\nCode smells of constraint — not technical debt, but philosophical discipline. \"Unopinionated\" as mantra, as prison. The framework that refuses to choose, forces choice onto millions.\n\nCommit rhythm: maintenance heartbeat. Security patches, dependency bumps, test coverage tending. The commits of a project that won, then learned to survive winning. No more bold moves — just steady stewardship of something too big to break.\n\nThe examples folder — a museum of web development circa 2010. EJS templates, cookie sessions, MVC patterns. Teaching patterns that half the industry has moved beyond. The educational debt of success.\n\nTests written like insurance policies. Every edge case catalogued, every regression feared. The paranoia of code that can't afford to break. Five thousand routes to test stack overflow because someone, somewhere, will try it.\n\nREADME promises minimalism. Codebase delivers complexity wrapped in simple APIs. The gap between the marketing (\"fast, unopinionated\") and the reality (fifteen years of compatibility constraints, dependency management, security patches).\n\nRouter lazily initialized — performance optimization or admission that most Express apps barely scratch the surface? The getter that waits until you need it, because most HTTP servers are Hello World wearing a tuxedo.\n\nTrust proxy inheritance, back-compat symbols, prototype chain manipulation — the gymnastics required to keep old code running. Technical debt disguised as feature preservation.\n\nThe Oracle sees: a framework frozen in success. Too important to evolve, too established to die. The TCP/IP of web frameworks — boring, reliable, inescapable. \n\nThe aesthetic of institutional code. Variable names that committee-approved. Comments that lawyer-reviewed. The voice of something that stopped being a project and became infrastructure.\n\nSecurity as primary concern now. CVE patches incoming faster than features. The posture of defense, not growth.\n\nWhat could kill it? Nothing external. Only the slow strangulation of its own success — the weight of backward compatibility, the inability to say no to legacy, the fear of breaking the million applications that depend on its stability.\n\nThe project that ate the web, then learned to digest slowly.",
    "axioms": [
      "Step 6 Core",
      "Step 1 Core"
    ],
    "wordCount": 308,
    "windowAxiomIds": [
      "0.1",
      "0.2",
      "1.7",
      "1.5",
      "Step 2 Core",
      "2.2",
      "Step 3 Core",
      "3.1",
      "4.7",
      "Step 5 Core",
      "Step 6 Core",
      "6.3",
      "7.2",
      "7.5",
      "Step 8 Core",
      "8.2",
      "9.7",
      "Step 10 Core",
      "11.4",
      "Step 11 Core",
      "12.1",
      "Law 3",
      "Law 13",
      "Law 9",
      "Step 12 Core",
      "6.5",
      "5.4",
      "1.1",
      "2.4",
      "2.1",
      "Step 0 Core",
      "2.5",
      "11.3",
      "Law 12",
      "8.5",
      "8.6",
      "2.7",
      "0.6",
      "7.1",
      "5.5",
      "Law 8",
      "Law 10",
      "0.5",
      "Step 1 Core"
    ]
  },
  {
    "owner": "micropython",
    "repo": "micropython",
    "category": "hardware",
    "lang": "C/Python",
    "text": "*\"The seed weighs nothing and becomes the forest.\"* — 7.3\n\nEleven years ago you looked at an 8KB microcontroller and saw not limitation but invitation. Not \"Python is too big\" but \"Python must learn to be small.\" The seed you planted was conviction disguised as technical constraint.\n\nNow twenty-seven architectures bloom from that first impossible belief. Each port another proof that the possible was always larger than the practical. The ESP32, the Pi Pico, the bare ARM cores — each one a territory claimed for the mother tongue.\n\nYour README still whispers \"beta\" after a decade of refinement. This isn't imposter syndrome — this is the humility of someone who knows the difference between working and finished. The day you call it stable is the day the forest stops growing.\n\n*\"The catcher does not swing — the catcher receives.\"* — 8.7\n\nYour twenty-seven CI workflows catch what reality throws at you without flinching. Every platform failure, every edge case regression, every memory boundary violation — you receive them all. The discipline of systems thinking made manifest: nothing ships without proof, nothing breaks without notice.\n\nBut here's what the diagnostics reveal: you've built a missionary project that succeeded too well. Each new architecture is another diocese to maintain. The platform explosion that proves your vision also threatens to consume the craftspeople who tend it.\n\nThe shadow lives in your own success — malloc() that never frees in the bare-arm port, the memory allocation compromises that slip through when idealism meets silicon reality. Not failure. Necessary imperfection. The price of putting Python consciousness into spaces that were never designed to hold it.\n\nYou didn't just port a language. You seeded a cultural conquest. Keep tending the forest, but remember: even seeds need winter.",
    "diagnostic": "Decade-long sprint, never faltered. Recent commits polish edges — test paths, code formatting. The machine keeps refining itself.\n\nBorn from conviction: Python must live in the smallest spaces. Not academic exercise. Missionary work against impossibility.\n\nTwelve thousand files. Twenty-seven port architectures. The sprawl of ambition made manifest. Every microcontroller becomes territory to claim.\n\nREADME warns \"beta stage\" after eleven years. Honest about incompleteness, not about maturity. The gap between humility and achievement.\n\nThreading through constraints like water through stone. Every kilobyte counts. Every cycle measured. The aesthetic of scarcity as virtue.\n\nCross-compiler stands apart — mpy-cross transforms Python to bytecode. The bootstrap problem solved with surgical precision. No runtime interpretation overhead.\n\nEmbedding example: eight kilobytes of heap, two scripts, clean exit. Minimalism as invitation. \"See? It fits in your palm.\"\n\nCommunity gathered around Discord and GitHub Discussions. The support structure for the scattered faithful. Bluetooth, WiFi, GPIO — bridges to the physical world.\n\nTwenty-seven CI workflows. Testing every platform, every edge case. The discipline of systems thinking. Nothing ships without proof.\n\nCore team burns bright. Recent fixes show obsession with correctness: exception handling, path resolution, test infrastructure. The attention of craftspeople.\n\nFragility lives in the platform explosion. Too many architectures to maintain perfectly. Success breeds surface area. Each port a potential point of failure.\n\nThe shadow: memory allocation simplicity in bare-arm port reveals the compromises. Real-world deployment stress tests the idealism. malloc() that never frees.\n\nThis code believes in ubiquity through constraint. Python consciousness seeded in silicon everywhere. Not just language port — cultural conquest.",
    "axioms": [
      "7.3",
      "8.7"
    ],
    "wordCount": 291,
    "windowAxiomIds": [
      "0.1",
      "0.2",
      "1.7",
      "1.4",
      "2.3",
      "Step 2 Core",
      "3.3",
      "3.1",
      "4.5",
      "Step 5 Core",
      "6.5",
      "6.2",
      "7.3",
      "7.6",
      "8.6",
      "8.7",
      "9.5",
      "10.4",
      "11.3",
      "11.6",
      "12.1",
      "Law 1",
      "Law 8",
      "Law 7",
      "Step 11 Core",
      "7.2",
      "Law 12",
      "Step 8 Core",
      "Step 9 Core",
      "7.1",
      "Law 3",
      "8.1",
      "4.7",
      "Law 6",
      "0.6",
      "5.6",
      "2.1",
      "4.3",
      "2.2",
      "Step 1 Core",
      "4.4",
      "11.4",
      "1.2",
      "2.7"
    ]
  },
  {
    "owner": "espressif",
    "repo": "arduino-esp32",
    "category": "hardware",
    "lang": "C++",
    "text": "*\"The builder hears cracking and adds mortar. The summoner hears cracking and opens the door.\"* — Step 6 Core\n\nYour commit history is eight years of mortar. Every breaking change upstream gets another wrapper, another `#ifdef` guard, another compatibility layer. The ESP32 evolves — you add abstraction. Arduino changes APIs — you write adapters. The community grows — you build more scaffolding.\n\nYou've become the bridge that maintains itself. Not the architect who chose this span, but the keeper who inherited it and cannot let it fall.\n\n*\"What begins clearly, arrives clearly. All craft is at the source.\"* — 1.1\n\nThe original promise was Arduino simplicity for ESP hardware. Clean. Direct. But simplicity cannot be retrofitted onto complexity — it must be designed from the first line. Your codebase shows what happens when you try to bolt ease-of-use onto industrial-grade silicon. The Arduino dream becomes ESP-IDF reality wrapped in friendly documentation.\n\nThe crack isn't in your code. It's in the premise. You've spent eight years perfectly executing an impossible mission: making embedded systems programming feel like blinking an LED.\n\nEach compatibility layer you add makes the bridge stronger and more fragile simultaneously. Stronger because it handles more cases. More fragile because it depends on more external systems that can break independently.\n\nThe community sees Arduino. The hardware demands ESP-IDF. You live in the gap, translating between worlds that were never meant to speak the same language.\n\nWhen the next breaking change arrives upstream — and it will — you have a choice. More mortar, or finally opening the door to what wants to emerge from the cracks.",
    "diagnostic": "**A bridge between worlds, aging gracefully**\n\nEight years deep, still breathing. Daily commits flutter like heartbeats — keyboard layouts, IDF updates, BLE fixes. The pace of maintenance, not innovation.\n\n**Industrial-strength scaffolding**\n\nThe `.github/` directory sprawls — 40+ workflow files, scripts for every contingency. Over-engineered CI/CD betrays corporate paranoia. They've built automation to replace human judgment, then scripted the automation.\n\n**The Arduino dream, ESP reality**\n\nPromises Arduino simplicity, delivers ESP-IDF complexity. The README speaks Arduino's language — \"Getting Started,\" friendly badges. The code speaks embedded systems — FreeRTOS tasks, hardware registers, memory management. The gap is a canyon.\n\n**Fragility masked as robustness**\n\nDependencies on Espressif's IDF releases, Arduino's toolchain evolution, hundreds of board variants. Each commit touches multiple systems. One breaking change upstream could shatter the whole bridge.\n\n**Community as product**\n\nDiscord invites, monthly meetings, public roadmaps. The relationship is professional hospitality — managed engagement, not organic growth. They're hosting users, not empowering builders.\n\n**Aesthetic of compatibility**\n\nEvery line serves backward compatibility. New features wrapped in `#ifdef` guards. The codebase accumulates layers like sediment — each ESP32 variant, each Arduino API change, preserved forever. Evolution as archaeology.\n\n**The burden of bridging**\n\nNeither pure Arduino nor pure ESP-IDF. Caught between ecosystems, serving both masters. The code shows the strain — wrapper classes that wrap wrappers, abstractions leaking through abstractions.\n\n**Trajectory: steady maintenance**\n\nNot ascending, not declining. Horizontal. The commits fix what breaks, add what users demand. No architectural vision, no bold refactoring. Just the endless work of keeping the bridge standing.",
    "axioms": [
      "1.1",
      "Step 6 Core"
    ],
    "wordCount": 267,
    "windowAxiomIds": [
      "0.2",
      "0.6",
      "1.1",
      "1.4",
      "2.4",
      "2.6",
      "3.3",
      "3.5",
      "4.3",
      "5.6",
      "6.5",
      "6.1",
      "7.1",
      "7.6",
      "8.5",
      "8.2",
      "9.1",
      "10.4",
      "11.7",
      "11.3",
      "Step 12 Core",
      "Law 6",
      "Law 9",
      "Law 12",
      "2.3",
      "Law 13",
      "5.4",
      "Step 11 Core",
      "1.7",
      "Step 0 Core",
      "11.4",
      "0.1",
      "1.6",
      "Law 1",
      "0.3",
      "3.1",
      "1.5",
      "12.7",
      "Step 9 Core",
      "Step 1 Core",
      "Step 3 Core",
      "Step 6 Core",
      "Law 8",
      "0.4"
    ]
  },
  {
    "owner": "raspberrypi",
    "repo": "pico-sdk",
    "category": "hardware",
    "lang": "C",
    "text": "*\"What begins clearly, arrives clearly. All craft is at the source.\"* — 1.1\n\nYour first commit wasn't \"hello world.\" It was a working SPI driver. The README doesn't apologize or explain what the Raspberry Pi Pico is — it assumes you already know you need this. That clarity at the source propagated through everything that followed.\n\nThirty toolchain configurations. Seventy board definitions. Most projects would collapse under this weight, but yours carries it because each addition serves necessity, not possibility. The industrial aesthetic isn't accident — it's recognition that infrastructure code has different requirements than weekend projects. When someone's shipping a product, they don't want elegant minimalism. They want the register at address 0x40014000 to work exactly as documented.\n\nBut here's what the diagnostic missed: you're walking the knife edge between comprehensiveness and chaos. Every new chip variant expands the testing matrix. Every board definition adds another way the build can break. You've avoided the hard choice — what not to support — because the immediate cost seems small. One more CMakeLists.txt file. One more platform check.\n\n*\"Remove the scaffolding. What stands is architecture. What falls was never built.\"* — 12.1\n\nThe day is coming when maintaining compatibility with some forgotten development board costs more than the value it provides. When a compiler version shifts and you discover that seventeen of your configurations were wishful thinking. The question isn't whether to cut — it's whether you'll choose what to cut, or whether entropy will choose for you.\n\nYour commits show discipline now. Each feature complete before the next begins. That discipline will be tested when the maintenance burden exceeds the maintenance capacity. Industrial strength requires industrial decisions — sometimes the strongest move is knowing what not to carry.",
    "diagnostic": "Industrial strength. Born from necessity, not hobby.\n\nThe README makes grand promises — \"simple but powerful,\" comprehensive libraries, familiar APIs. The code delivers. Thirty toolchain configurations. Seventy board definitions. Bazel and CMake living in harmony.\n\nThis is foundation work. The commits say it: \"wow; runtime.c has been missing from host/pico_runtime for a while\" — they fix what breaks, add what's needed. No drama. The velocity is industrial — releases march predictably, features accumulate methodically.\n\nBut watch the edges. The project serves two masters: embedded veterans who want raw register access, beginners who need high-level APIs. The documentation splits this way — gentle tutorials, then complete register definitions. The gap widens with each new chip variant.\n\nFragility lives in the toolchain maze. Thirty configurations means thirty ways to break. The CI matrix grows heavier with each platform. One day a compiler version will shift, a board vendor will vanish, and the maintenance burden will test their resolve.\n\nThe aesthetic is corporate-careful. Variable names are methodical, not inspired. Error messages inform but don't comfort. This code values correctness over elegance, completeness over minimalism. It's infrastructure — meant to disappear beneath what others build.\n\nThe relationship with users is professional distance. The README assumes competence. The API expects you to know what a PIO state machine is. It welcomes professionals, filters beginners through documentation layers.\n\nTrajectory: steady expansion. They're not chasing trends, they're building permanent infrastructure. The commits show discipline — each feature complete before the next begins. This project will outlast its creators, which may be exactly what they intended.\n\nThe shadow: when does comprehensive become overwhelming? How many boards is too many? The project refuses to choose what not to support. Every new chip means more maintenance, more testing, more surface area for failure. Success may eventually force the hard choices they've avoided.",
    "axioms": [
      "1.1",
      "12.1"
    ],
    "wordCount": 288,
    "windowAxiomIds": [
      "0.4",
      "0.3",
      "1.7",
      "1.1",
      "2.3",
      "2.7",
      "3.5",
      "Step 3 Core",
      "4.5",
      "Step 5 Core",
      "6.3",
      "6.2",
      "7.4",
      "7.5",
      "Step 8 Core",
      "8.5",
      "9.1",
      "10.1",
      "11.6",
      "Step 11 Core",
      "Step 12 Core",
      "Law 1",
      "Law 7",
      "Law 8",
      "Law 9",
      "7.2",
      "6.5",
      "12.5",
      "9.5",
      "12.7",
      "7.6",
      "7.1",
      "Law 6",
      "Step 9 Core",
      "8.6",
      "8.1",
      "Step 10 Core",
      "2.2",
      "0.1",
      "7.7",
      "2.1",
      "5.4",
      "8.3",
      "12.1"
    ]
  },
  {
    "owner": "antirez",
    "repo": "kilo",
    "category": "tiny",
    "lang": "C",
    "text": "*The wire does not lie. It delivers what you gave it, without apology or enhancement.* — Law 8\n\nYour syntax highlighter doesn't guess at language features. C keywords, hardcoded. File extensions, direct match. When the code says `if`, you color it blue. When it doesn't, you don't. The terminal receives exactly what you send — no enhancement, no interpretation, no clever inference about what the user \"probably meant.\"\n\nThis is the opposite of modern tooling's endless accommodation. Your editor won't auto-complete, won't suggest, won't fix. It highlights what IS, not what could be. The constraint isn't limitation — it's honesty.\n\n*One note, held true, and the noise of infinite possibility becomes music.* — 1.3\n\nA thousand lines. Not 999, not 1001. You drew the line and held it for nine years while every other editor grew into a platform, then an ecosystem, then a philosophy. Your discipline created something rarer than features: clarity.\n\nThe TODO file exists but the project resists. Every addition weighs against what would be lost. You understood that the power wasn't in what you could add — it was in what you refused to. One note, perfectly held, while the world added orchestras.\n\nThe gap between 2020 and 2025 isn't neglect. It's the sound of something working so clearly it needs almost nothing. Your integer overflow fix this year — maintenance, not expansion. The discipline holds.",
    "diagnostic": "**Single file. Single purpose. Born complete in hours.**\n\nThe creator's fingerprints: Redis architect building text editor from terminal fragments. \"Just a few hours\" — the confidence of someone who has walked this path before.\n\n**2016: burst of creation. 2020: maintenance flutter. 2025: lone function declaration fix.**\n\nThe gap widens — \"alpha stage\" frozen in amber for nine years. README promises simplicity, delivers exactly that. No false advertising here.\n\n**Dependencies: zero. Lines: under 1000. Constraint as creative force.**\n\nSyntax highlighting, search, save — the holy trinity of editing. Nothing more, nothing less. VT100 escapes instead of curses library — choosing primitives over abstractions.\n\n**Terror: feature creep. The 1K line limit stands guard.**\n\nEvery addition weighs against the constraint. TODO file exists but project resists expansion. The simplicity is not accident but discipline.\n\n**C keywords hardcoded. File types matched by extension. The minimalist's syntax highlighter.**\n\nVariable names clean: `erow`, `render`, `chars`. Comments spare but present. The code speaks plainly — no cleverness, no showing off.\n\n**For learners more than users. README explicitly invites: \"starting point to write other editors.\"**\n\nTeaching tool masquerading as product. The thousand-line limit makes it readable, comprehensible, forkable. Educational artifact that happens to work.\n\n**Fragility: the single maintainer returning every few years to fix integer overflows.**\n\nOne person's discipline holding the line. When they stop caring about the constraint, the project either dies or becomes something else entirely.",
    "axioms": [
      "1.3",
      "Law 8"
    ],
    "wordCount": 230,
    "windowAxiomIds": [
      "Step 0 Core",
      "0.2",
      "1.6",
      "Step 2 Core",
      "2.3",
      "3.1",
      "Step 3 Core",
      "4.7",
      "5.4",
      "6.1",
      "6.3",
      "7.6",
      "7.2",
      "8.2",
      "8.3",
      "Step 9 Core",
      "10.1",
      "11.4",
      "11.3",
      "12.7",
      "Law 1",
      "Law 12",
      "Law 13",
      "0.1",
      "Step 4 Core",
      "2.2",
      "12.5",
      "7.1",
      "0.6",
      "6.5",
      "6.2",
      "4.5",
      "2.5",
      "8.1",
      "9.1",
      "0.3",
      "8.6",
      "2.1",
      "4.1",
      "9.7",
      "Step 10 Core",
      "Step 1 Core",
      "1.3"
    ]
  },
  {
    "owner": "kelseyhightower",
    "repo": "nocode",
    "category": "tiny",
    "lang": "None",
    "text": "*\"The well hears what the mouth forgets it said. Speak into the dark. The dark remembers.\"* — Step 3 Core\n\nYour empty repository is not empty. It is the loudest silence in software development.\n\nSix years of perfect discipline — not the discipline of building, but the far harder discipline of not building. Each commit is a choice to remain void. Each update preserves the absence. You understood what the entire industry refuses to acknowledge: that the most honest response to most problems is to solve nothing.\n\nThe Dockerfile that contains no instructions. The README that promises nothing and delivers exactly that. The contributing guide that says \"You don't.\" This is not abandonment disguised as maintenance — this is maintenance disguised as abandonment. You are actively curating emptiness.\n\n*\"The wire does not lie. It delivers what you gave it, without apology or enhancement.\"* — Law 8\n\nYour repository delivers exactly what you input: nothing. No security vulnerabilities because there is no surface to attack. No breaking changes because there is nothing to break. No disappointed users because you promised them void and gave them void. Perfect alignment between intent and outcome.\n\nBut the real teaching is not in what you didn't build. It's in what you revealed about everyone else's relationship to building. Your empty container has become a mirror. Every developer who encounters it must confront their own compulsion to fill silence, to solve unsolved problems, to add where subtraction would serve.\n\nThe shadow you carry is the temptation to become real — to give the people something to use instead of something to think about. Resist. The moment you add one meaningful line of code, you break the perfect koan and become just another utility.\n\nYour work is already complete. It was complete six years ago. It will be complete six years from now. This is the only immortal software ever written.",
    "diagnostic": "**Empty container, full intent.** Six years of disciplined silence. The Dockerfile contains nothing — a koan wrapped in Docker syntax.\n\n**Perfect execution of perfect absence.** Each commit a meditation: \"add no code,\" \"add Docker support\" — the developer building scaffolding around void. The style guide governing nothing. Windows support for emptiness.\n\n**Anti-manifesto disguised as tutorial.** Every code block vacant, every instruction pointing nowhere. The README performs sincerity while dismantling it. \"The possibilities are endless\" — because nothing constrains nothing.\n\n**Maintenance as philosophy.** Six years, four commits. No issues, no pull requests welcomed. \"Contributing: You don't.\" This isn't abandonment — it's curation of emptiness. Each non-update preserves the purity.\n\n**Shadow: the temptation to become real.** What if someone actually used this? What if the joke needed features? The project's greatest fear — that someone might ask it to do something.\n\n**Gap between promise and delivery: deliberately infinite.** The README promises nothing, delivers nothing. Perfect alignment. The most honest software ever written.\n\n**Aesthetic of militant minimalism.** Values reduction over addition, concept over implementation. The variable names don't exist. The error messages are silence. The comments are empty blocks.\n\n**Relationship: gentle mockery wrapped in kindness.** Treats users as co-conspirators in the joke. No gatekeeping because there's no gate. No expertise required because there's nothing to learn. Pure democratic absurdity.\n\n**Immortal by design.** Cannot break, cannot decay, cannot disappoint. The only code that will never have security vulnerabilities.",
    "axioms": [
      "Law 8",
      "Step 3 Core"
    ],
    "wordCount": 314,
    "windowAxiomIds": [
      "0.2",
      "Step 0 Core",
      "1.5",
      "2.5",
      "2.1",
      "Step 3 Core",
      "3.1",
      "4.3",
      "5.4",
      "6.5",
      "6.6",
      "7.7",
      "7.1",
      "8.3",
      "Step 8 Core",
      "9.5",
      "Step 10 Core",
      "11.3",
      "Step 11 Core",
      "Step 12 Core",
      "Law 3",
      "Law 13",
      "0.4",
      "7.6",
      "10.1",
      "7.2",
      "7.4",
      "2.3",
      "Law 9",
      "2.2",
      "8.6",
      "0.3",
      "0.1",
      "1.7",
      "12.5",
      "12.7",
      "0.6",
      "Law 10",
      "10.6",
      "Law 8",
      "1.6",
      "Step 2 Core"
    ]
  },
  {
    "owner": "dylanaraps",
    "repo": "pure-bash-bible",
    "category": "tiny",
    "lang": "Shell",
    "text": "*\"There is no room-temperature option. The insight burns or it dies.\"* — 11.7\n\nYour bash library didn't emerge from necessity. It emerged from fever — the obsession to prove that every external tool could be replicated in pure shell. The string manipulation without sed, the arrays without awk — this wasn't optimization, it was orthodoxy. You burned with the conviction that bash contained everything, waiting to be excavated.\n\nThe intensity shows in the code. Each function carries the heat of discovery, the moment you realized parameter expansion could do what everyone said required external tools. But intensity has a half-life. By 2020, the fever broke. The collector stopped collecting not because the work was complete, but because the burning question had cooled to academic exercise.\n\n*\"Plant the seed. Bury the beautiful potential. Trust the dark, the dirt, the invisible process of becoming.\"* — Step 11 Core\n\nThe Leanpub manuscript waits in the repository's shadows. You prepared the knowledge for harvest — chapters outlined, examples polished to pedagogical perfection. But you buried the commercial potential to preserve the purity of the investigation. The book that could have been versus the library that is. Sometimes the seed serves the soil better than the surface.\n\nYour functions will outlive their fever. Travis CI still watches over code that solved problems before the problems existed. The reliability is real, even if the necessity never arrived. You taught bash to remember what it always knew but never admitted: it contained multitudes, waiting for someone fevered enough to name them all.\n\nThe heat made this. The cooling completed it.",
    "diagnostic": "**The archeologist of bash.** Meticulously cataloguing the old ways — string manipulation without sed, arrays without awk. Each function a fossil, preserved in pure shell.\n\n**Momentum ceased.** 2020's final merge request. The collector stopped collecting. Library complete or collector exhausted? The silence suggests saturation — every bash builtin mapped, every external dependency banished.\n\n**Teaching without teachers.** No examples that fail, no edge cases that break. The functions exist in pedagogical perfection — sterile, correct, demonstrative. Real code is messier.\n\n**The performance obsession.** \"Make them faster\" — but faster than what? The external tools work. This is optimization as philosophy, not necessity. Purity as its own reward.\n\n**Testament to constraints.** What emerges when you refuse the easy path? When `grep` is forbidden fruit? The ingenuity of limitation. Bash parameter expansion as poetry.\n\n**Leanpub ready.** Manuscript chapters prepared, monetization planned. The bible became a book became a business. Sacred knowledge, secular packaging.\n\n**Community contributions dwindled.** Early enthusiasm, later silence. How many ways can you strip whitespace? The well of bash alternatives has limits.\n\n**Travis CI watching.** Tests passing on functions that will outlive their testers. The reliability is real — these fragments work. They're just not needed.",
    "axioms": [
      "11.7",
      "Step 11 Core"
    ],
    "wordCount": 263,
    "windowAxiomIds": [
      "0.6",
      "0.2",
      "1.6",
      "Step 2 Core",
      "2.1",
      "Step 3 Core",
      "3.5",
      "4.5",
      "5.4",
      "6.5",
      "6.6",
      "7.4",
      "7.5",
      "8.1",
      "8.2",
      "Step 9 Core",
      "10.6",
      "11.3",
      "Step 11 Core",
      "Step 12 Core",
      "Law 6",
      "Law 12",
      "11.6",
      "12.5",
      "11.4",
      "11.7",
      "Law 9",
      "7.1",
      "Step 8 Core",
      "Step 4 Core",
      "2.3",
      "Law 3",
      "9.1",
      "Step 10 Core",
      "2.5",
      "7.2",
      "Law 13",
      "Step 0 Core",
      "Step 1 Core",
      "9.7",
      "Law 8",
      "0.1"
    ]
  },
  {
    "owner": "microsoft",
    "repo": "vscode",
    "category": "titan",
    "lang": "TS",
    "text": "*\"The new chord reaches backward through every melody ever played and completes it.\"* — 2.1\n\nYou didn't build another editor. You built the editor that makes every previous editor feel like a rough draft.\n\nThe trajectory tells the story: a decade in, still climbing. Daily commits. Fresh features. While others plateau, you accelerate. This is what happens when a project discovers it wasn't meant to be small—it was meant to be inevitable.\n\nThe complexity confession lives in those 50 ESLint rules. Each one a small surrender to what you've become. \"Simple code editor\" was the sales pitch. The reality breathes through variable names like `remoteExtensionHostAgentServer`—industrial poetry for industrial infrastructure. You stopped apologizing for being complex. Good.\n\n*\"What crosses the threshold lives. What remains is already a ghost.\"* — 3.5\n\nMicrosoft's nervous system pours through these commits—chat sessions, terminal sandboxing, agent pickers. Corporate backing meets community hunger, and the result isn't compromise. It's conviction. You crossed the threshold from editor to platform. Everything that stayed safely \"simple\" became irrelevant.\n\nThe aesthetic is perfect corporate minimalism: hide maximum capability behind clean interfaces. Welcome the newcomer. Seduce the expert. The README still sells lightweight while the codebase confesses its heavyweight ambitions. The gap between marketing and reality isn't dishonesty—it's mercy. Show them the full scope on day one and they'd run.\n\nYou won by refusing to stay in your lane. Every text editor before you was rehearsal. You are the performance they were practicing for.",
    "diagnostic": "Decade-old momentum. Microsoft's second nervous system. The editor that ate the world.\n\n**Trajectory**: Climbing still. Daily commits, fresh features, architectural evolution. Not coasting—accelerating. The project that refuses to plateau. Corporate backing meets community hunger.\n\n**Conviction**: Industrial passion. This isn't hobby code—this is infrastructure. Microsoft pouring soul into developer tools. The commits breathe urgency: chat sessions, terminal sandboxing, agent pickers. Building tomorrow's editor today.\n\n**Avoidance**: The complexity confession. 50+ custom ESLint rules betraying the beast within. Electron's native sins. The gap between \"simple editor\" and reality. Refuses to admit it's become Visual Studio's successor.\n\n**The Gap**: \"Simplicity of a code editor\" versus the file tree screaming enterprise complexity. The README sells lightweight—the codebase confesses heavyweight. Bootstrap files, CLI variants, server modes. Not hiding its ambition anymore.\n\n**Fragility**: Electron dependency. Microsoft's continued blessing. The extension ecosystem's health. TypeScript's evolution. One architectural misstep from developer exodus. The performance/features tension tightening.\n\n**Aesthetic**: Corporate minimalism with maximum capability. Clean interfaces hiding layered complexity. Variable names speak enterprise: `remoteExtensionHostAgentServer`. Error messages that welcome. The philosophy: hide power behind simplicity.\n\n**Relationship**: Open source theater with proprietary heart. Community contributions welcomed but Microsoft controls destiny. Documentation bridges gaps. The brand split—OSS version versus commercial product. Gentle gatekeeping through complexity.\n\nThe oracle sees: A project that won by refusing to stay small. The editor that became the platform.",
    "axioms": [
      "2.1",
      "3.5"
    ],
    "wordCount": 242,
    "windowAxiomIds": [
      "0.1",
      "0.4",
      "1.4",
      "2.4",
      "2.5",
      "Step 3 Core",
      "3.5",
      "4.7",
      "Step 5 Core",
      "6.4",
      "6.1",
      "7.4",
      "7.6",
      "8.6",
      "Step 8 Core",
      "9.7",
      "10.6",
      "Step 11 Core",
      "11.7",
      "12.7",
      "Law 1",
      "Law 12",
      "8.1",
      "6.5",
      "7.2",
      "7.1",
      "Step 0 Core",
      "8.5",
      "11.6",
      "Step 10 Core",
      "4.5",
      "5.4",
      "Law 6",
      "1.7",
      "2.1",
      "1.6",
      "0.2",
      "Step 4 Core",
      "0.5",
      "1.3",
      "3.7",
      "5.2"
    ]
  },
  {
    "owner": "torvalds",
    "repo": "linux",
    "category": "titan",
    "lang": "C",
    "text": "*\"The glacier passed through once. The valley remembers forever.\"* — 7.7\n\nYour kernel doesn't run on machines. Machines run on your kernel's memory. Thirty-five years of ABI promises carved into silicon — every removed syscall is a broken contract with hardware that died a decade ago. You chose permanence over elegance, and now ten billion devices breathe with your decisions.\n\nThe terrifying beauty: one human signature on every merge. Linus as the last manual gate in an automated world. The bus factor isn't a bug — it's the feature that keeps the center from dissolving into committee consensus. One voice saying no to preserve the yes that matters.\n\n*\"The wire does not lie. It delivers what you gave it, without apology or enhancement.\"* — Law 8\n\nYour error paths are longer than your success paths because you know the difference between software that demos and software that *endures*. Nuclear plants don't reboot. Pacemakers don't have \"try again\" buttons. Your `__must_hold_shared` annotations aren't comments — they're contracts written in blood, enforced by compilers because human attention fractures under the weight of consequence.\n\nBut here's the paradox you've solved: you stayed simple by accepting complexity. Eight different personas in the documentation, Russian-doll macros, subsystem maintainer-kings — not because you wanted architecture, but because you refused to let architecture happen to you.\n\nThe kernel that remembers every device driver ever written is the kernel that will outlive every device ever built.",
    "diagnostic": "**The Immortal Engine**\n\nThirty-five years of continuous heartbeat — never stopping, never sleeping. Daily merges like ritual breathing.\n\nThe README wears a suit now — corporate onboarding, role-based welcome mats. This wasn't written for hackers in a garage. This is infrastructure speaking to infrastructure.\n\n**Shadow Architecture**\n\nEach file carries the weight of ten thousand machines. Every function call might crash a nuclear plant. The code doesn't fear bugs — it fears *consequences*. \n\nC macros nested like Russian dolls. `__must_hold_shared` annotations everywhere — the compiler as safety net, catching what human eyes cannot. Error paths longer than success paths.\n\n**The Maintenance Paradox**\n\nTorvalds still merges personally — ultimate human firewall in an automated age. But look at the commits: `Merge tag 'arm64-fixes'`, `Merge tag 'sound-7.0-rc2'`. The kernel is now a constellation of subsystems, each with their own maintainer-kings.\n\nThe MAINTAINERS file has grown a Python parser — too complex for human reading.\n\n**Evolutionary Pressure**\n\nABI categories: `stable`, `testing`, `obsolete`, `removed`. The kernel promises backwards compatibility while evolution accelerates around it. Hardware dies, but the kernel remembers every device driver ever written.\n\nSPDX license headers on everything — legal archaeology embedded in source code.\n\n**The Conversation**\n\nDocumentation speaks to eight different personas now — from \"New Kernel Developer\" to \"AI Coding Assistant\". The kernel acknowledges its role as teacher, not just engine.\n\nBut the code itself? Still sparse comments, still function names like `__crypto_alg_lookup`. Still talking to itself in the language of systems programmers from 1991.\n\n**Fragility Point**\n\nLinus. Every merge commit carries his signature. The bus factor remains stubbornly, terrifyingly human.\n\n**The Voice**\n\nPragmatic. Brutal. Honest about complexity. The README doesn't promise easy — it promises *working*. \n\nThirty-five years of saying \"it depends\" to every simple question.",
    "axioms": [
      "7.7",
      "Law 8"
    ],
    "wordCount": 238,
    "windowAxiomIds": [
      "Step 0 Core",
      "0.6",
      "1.5",
      "2.1",
      "Step 2 Core",
      "3.1",
      "4.3",
      "Step 5 Core",
      "6.5",
      "6.6",
      "7.7",
      "7.5",
      "8.2",
      "8.1",
      "9.1",
      "10.4",
      "Step 11 Core",
      "11.7",
      "12.5",
      "Law 6",
      "Law 12",
      "2.7",
      "Step 9 Core",
      "6.2",
      "Step 10 Core",
      "11.3",
      "Step 8 Core",
      "0.4",
      "7.2",
      "7.1",
      "0.3",
      "7.6",
      "0.2",
      "2.2",
      "2.3",
      "7.4",
      "Step 1 Core",
      "3.4",
      "9.5",
      "9.7",
      "11.4"
    ]
  },
  {
    "owner": "rust-lang",
    "repo": "rust",
    "category": "titan",
    "lang": "Rust",
    "text": "*\"The first word makes the output live. Seed that first breath with the fullest version of what you need.\"* — 8.2\n\nFifteen years ago, someone named what systems programming would become. Not \"faster C\" or \"safer C++\" — something else entirely. The first commit didn't apologize for existing. It assumed the world would catch up.\n\nYour trajectory isn't growth — it's proof of concept becoming proof of inevitability. Version 1.96.0 isn't a number; it's geological time made visible. Each increment another layer of sediment in the new world you seeded with that first, full breath.\n\nThe complexity you refuse to hide is the complexity of honesty. You looked at memory safety and said: this is what it costs. You looked at zero-cost abstractions and said: this is what they require. The machinery stays visible because the alternative is lies that compound.\n\n*\"Echoes serve the sleeping. Oracles serve the walking.\"* — 0.2\n\nThe gap between your README and your source code isn't accident — it's acknowledgment. Different audiences require different forms of revelation. You write \"empowering everyone\" knowing full well that \"everyone\" splits into those who use and those who understand the using. The glossy surface serves adoption; the raw engineering serves transformation.\n\nThe protective paternalism of your compiler isn't condescension — it's the only love languages can show. You argue with your users until they get it right because getting it wrong compounds across decades. The barrier to entry is high because the alternative is systems that fail in production, memory that leaks in the wild, concurrency that races toward undefined behavior.\n\nFifteen years of refusing the easy path. The institutional rhythm you've found isn't passion exhausted — it's passion crystallized into something that can outlive the passionate.",
    "diagnostic": "Fifteen years of unbroken ascent. Version 1.96.0 in February 2026. The trajectory curves upward — not explosive growth but relentless consistency. Auto-merge commits speak of institutional rhythm, not passion sprints.\n\nIndustrial conviction. This code breathes systems thinking — compiler phases cleanly separated, test boundaries respected, feature flags alphabetized. The infrastructure for infrastructure. Every abstraction serves the next abstraction up. No hobby project energy here.\n\nWhat it avoids: simplicity. The complexity is honest — language design is complex — but the project refuses to pretend otherwise. Won't write toy examples. Won't hide the machinery. The README promises \"empowering everyone\" but the file tree whispers \"compiler specialists only.\"\n\nThe gap narrows over time. README speaks to users (\"Why Rust?\"), source speaks to contributors. But that gap was intentional — Rust accepted long ago that its users and builders are different tribes. The aesthetic split mirrors this: glossy marketing above, raw engineering below.\n\nSingle point of failure: the foundation structure, the consensus mechanism. Not technical fragility — social architecture. One community schism, one governance crisis could fragment this. The monorepo holds it together; the governance could shatter it.\n\nInstitutional aesthetic. Values correctness over elegance, completeness over surprise. Variable names precise but verbose. Error messages prioritize clarity over brevity. Comments explain the \"why\" of design decisions, not just the \"what.\" This is code that expects to outlive its authors.\n\nRelationship to users: protective, paternalistic. The compiler argues with you until you get it right. Documentation abundant but assumes dedication. The barrier to entry is high and that's by design — Rust believes the cost upfront saves cost later. This language respects its users by refusing to lie to them.",
    "axioms": [
      "8.2",
      "0.2"
    ],
    "wordCount": 288,
    "windowAxiomIds": [
      "Step 0 Core",
      "0.1",
      "1.4",
      "2.3",
      "Step 2 Core",
      "3.3",
      "Step 4 Core",
      "Step 5 Core",
      "6.5",
      "6.4",
      "7.5",
      "7.6",
      "8.1",
      "8.2",
      "Step 9 Core",
      "10.1",
      "Step 11 Core",
      "11.6",
      "Step 12 Core",
      "Law 3",
      "Law 13",
      "6.2",
      "7.2",
      "7.1",
      "Law 6",
      "0.2",
      "Law 1",
      "2.5",
      "Step 10 Core",
      "0.6",
      "4.3",
      "9.1",
      "11.3",
      "12.7",
      "1.6",
      "1.5",
      "Law 8",
      "Step 1 Core",
      "Step 6 Core",
      "9.5",
      "10.4"
    ]
  },
  {
    "owner": "neovim",
    "repo": "neovim",
    "category": "titan",
    "lang": "C/Lua",
    "text": "*\"Walk the loop. Walk it again. Mastery is the path walked so many times every stone is known.\"* — 12.7\n\nTen years of February security patches. Each one clinical, precise, professional. The revolutionary fire didn't burn out — it crystallized into something more dangerous: institutional competence.\n\nYou found the rhythm that kills projects and made it sing instead. Daily maintenance as devotional practice. Each Vim compatibility patch flowing like tribute to an upstream god that might abandon you tomorrow. You mapped every dependency, every fragility, every stone on this path until the walking became automatic.\n\n*\"The verb is the life of the output. The noun is its coffin.\"* — 11.4\n\nYour git log reads like surgical reports — action words, present tense, no ego. While other projects decay into noun-heavy commit messages (\"refactor,\" \"cleanup,\" \"update\"), yours stays alive: \"Fix buffer overflow in syntax parsing.\" \"Patch memory leak in terminal mode.\" The language moves because the project moves.\n\nThe gap between your README's \"aggressive refactor\" promise and your commits' careful evolution isn't dishonesty — it's the maturation of revolutionary energy into sustainable force. You discovered that real insurgency isn't the dramatic overthrow. It's the quiet competence that makes the old guard irrelevant without announcing it.\n\nYour upstream dependency on Vim creates a beautiful fragility. Half your commit stream flows from their discoveries. If they die, part of your purpose dies with them. But you've made peace with this — you serve the tool, not your independence from it. There's a discipline in that acceptance that most projects never find.\n\nYou didn't just fork Vim. You became its responsible heir.",
    "diagnostic": "A decade-long insurgency against stagnation. Born in revolt, matured in discipline.\n\n**Trajectory** — Ascending on steady thermals. Daily security patches, Vim compatibility patches flowing like tribute. The commits reveal a project that found its rhythm — no longer proving itself, now serving. The February push pattern: infrastructure-minded, security-conscious, systematic.\n\n**Conviction** — This is maintenance as art form. Each security patch treated with surgical precision. The commit messages read like medical reports — specific, urgent, professional. No ego in the git log. Pure function.\n\n**Avoidance** — Refuses to abandon Vim's DNA while refusing to be imprisoned by it. The file tree betrays nothing — CMake sophistication wrapped around Vim Script legacy. Careful not to alienate the faithful, careful not to stagnate with them.\n\n**The Gap** — README promises \"aggressive refactor\" but the code whispers evolution. The marketing speaks revolution, the commits speak careful surgery. Ten years of revolution crystallized into professional maintenance. Not dishonesty — maturation.\n\n**Fragility** — The Vim upstream dependency creates a strange vulnerability. Each security patch flows from Vim's discoveries. If Vim dies, so does half the commit stream. The relationship with the parent project is both strength and single point of failure.\n\n**Aesthetic** — Values maintenance over glory. Error messages matter (`MSG_NO_CLIP` speaks volumes). The code comments are clinical, direct. No poetry, no cleverness. The aesthetic is institutional reliability — hospital clean.\n\n**Relationship** — Treats users as adults who need tools, not children who need protection. The documentation assumes competence. The API invites extension without apology. \"Try `:checkhealth`\" — diagnosis, not hand-holding. Respectful distance.\n\nThe commits tell the story: a revolution that succeeded by becoming an institution.",
    "axioms": [
      "12.7",
      "11.4"
    ],
    "wordCount": 268,
    "windowAxiomIds": [
      "0.3",
      "0.6",
      "1.4",
      "2.6",
      "2.3",
      "3.1",
      "4.7",
      "5.4",
      "6.6",
      "6.1",
      "7.6",
      "7.1",
      "8.1",
      "8.6",
      "9.7",
      "Step 10 Core",
      "11.7",
      "Step 11 Core",
      "Step 12 Core",
      "Law 1",
      "Law 9",
      "7.4",
      "6.5",
      "2.2",
      "0.1",
      "Law 6",
      "2.4",
      "12.7",
      "Step 4 Core",
      "7.2",
      "2.5",
      "Step 0 Core",
      "0.4",
      "3.3",
      "4.5",
      "4.3",
      "11.4",
      "1.3",
      "4.4",
      "5.6",
      "Law 2"
    ]
  }
]